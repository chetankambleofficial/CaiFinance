"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fflate";
exports.ids = ["vendor-chunks/fflate"];
exports.modules = {

/***/ "(ssr)/./node_modules/fflate/lib/node.cjs":
/*!******************************************!*\
  !*** ./node_modules/fflate/lib/node.cjs ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n// Mediocre shim\nvar Worker;\nvar workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\ntry {\n    Worker = (__webpack_require__(/*! worker_threads */ \"worker_threads\").Worker);\n} catch (e) {}\nvar node_worker_1 = {};\nnode_worker_1[\"default\"] = Worker ? function(c, _, msg, transfer, cb) {\n    var done = false;\n    var w = new Worker(c + workerAdd, {\n        eval: true\n    }).on(\"error\", function(e) {\n        return cb(e, null);\n    }).on(\"message\", function(m) {\n        return cb(null, m);\n    }).on(\"exit\", function(c) {\n        if (c && !done) cb(new Error(\"exited with code \" + c), null);\n    });\n    w.postMessage(msg, transfer);\n    w.terminate = function() {\n        done = true;\n        return Worker.prototype.terminate.call(w);\n    };\n    return w;\n} : function(_, __, ___, ____, cb) {\n    setImmediate(function() {\n        return cb(new Error(\"async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)\"), null);\n    });\n    var NOP = function() {};\n    return {\n        terminate: NOP,\n        postMessage: NOP\n    };\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return {\n        b: b,\n        r: r\n    };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i){\n        if (cd[i]) ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 1; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i)flt[i] = 8;\nfor(var i = 144; i < 256; ++i)flt[i] = 9;\nfor(var i = 256; i < 280; ++i)flt[i] = 7;\nfor(var i = 280; i < 288; ++i)flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i)fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p + 7) / 8 | 0;\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */ exports.FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    \"unexpected EOF\",\n    \"invalid block type\",\n    \"invalid length/literal\",\n    \"invalid distance\",\n    \"stream finished\",\n    \"no stream handler\",\n    ,\n    \"no callback\",\n    \"invalid UTF-8 data\",\n    \"extra field too long\",\n    \"date not in range 1980-2099\",\n    \"filename too long\",\n    \"stream finishing\",\n    \"invalid zip data\"\n];\n;\nvar err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace) Error.captureStackTrace(e, err);\n    if (!nt) throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l) return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) err(0);\n                    break;\n                }\n                // ensure size\n                if (resize) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else err(1);\n            if (pos > tbts) {\n                if (noSt) err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) err(0);\n                break;\n            }\n            if (!c) err(2);\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d) err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) err(0);\n                    break;\n                }\n                if (resize) cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0) err(3);\n                    for(; bt < dend; ++bt)buf[bt] = dict[shift + bt];\n                }\n                for(; bt < end; ++bt)buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i){\n        if (d[i]) t.push({\n            s: i,\n            f: d[i]\n        });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return {\n        t: et,\n        l: 0\n    };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return {\n            t: v,\n            l: 1\n        };\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i){\n        if (t2[i].s > maxSym) maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return {\n        t: new u8(tr),\n        l: mbt\n    };\n};\n// get the max length and assign length codes\nvar ln = function(n, l, d) {\n    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i){\n        if (c[i] == cln && i != s) ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for(; cls > 138; cls -= 138)w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                    cls = 0;\n                }\n            } else if (cls > 3) {\n                w(cln), --cls;\n                for(; cls > 6; cls -= 6)w(8304);\n                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n            }\n            while(cls--)w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return {\n        c: cl.subarray(0, cli),\n        n: s\n    };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for(var i = 0; i < lclt.length; ++i)++lcfreq[lclt[i] & 31];\n    for(var i = 0; i < lcdt.length; ++i)++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;\n            }\n        }\n    } else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for(var i = 0; i < li; ++i){\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = sym >> 18 & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];\n        } else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function(dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos) w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for(; i + 2 < s; ++i){\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for(i = Math.max(i, wi); i < s; ++i){\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = pos & 7 | w[pos / 8 | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    } else {\n        for(var i = st.w || 0; i < s + lst; i += 65535){\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos / 8 | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ function() {\n    var t = new Int32Array(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Adler32\nvar adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | b >> 8;\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function(dat, opt, pre, post, st) {\n    if (!st) {\n        st = {\n            l: 1\n        };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);\n};\n// Walmart object spread\nvar mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/\\s+/g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function(v) {\n    var tl = [];\n    for(var k in v){\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function(fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = {\n            c: wcln(fns[m], fnStr, td_1),\n            e: td_1\n        };\n    }\n    var td = mrg({}, ch[id].e);\n    return (0, node_worker_1.default)(ch[id].c + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function() {\n    return [\n        u8,\n        u16,\n        i32,\n        fleb,\n        fdeb,\n        clim,\n        fl,\n        fd,\n        flrm,\n        fdrm,\n        rev,\n        ec,\n        hMap,\n        max,\n        bits,\n        bits16,\n        shft,\n        slc,\n        err,\n        inflt,\n        inflateSync,\n        pbf,\n        gopt\n    ];\n};\nvar bDflt = function() {\n    return [\n        u8,\n        u16,\n        i32,\n        fleb,\n        fdeb,\n        clim,\n        revfl,\n        revfd,\n        flm,\n        flt,\n        fdm,\n        fdt,\n        rev,\n        deo,\n        et,\n        hMap,\n        wbits,\n        wbits16,\n        hTree,\n        ln,\n        lc,\n        clen,\n        wfblk,\n        wblk,\n        shft,\n        slc,\n        dflt,\n        dopt,\n        deflateSync,\n        pbf\n    ];\n};\n// gzip extra\nvar gze = function() {\n    return [\n        gzh,\n        gzhl,\n        wbytes,\n        crc,\n        crct\n    ];\n};\n// gunzip extra\nvar guze = function() {\n    return [\n        gzs,\n        gzl\n    ];\n};\n// zlib extra\nvar zle = function() {\n    return [\n        zlh,\n        wbytes,\n        adler\n    ];\n};\n// unzlib extra\nvar zule = function() {\n    return [\n        zls\n    ];\n};\n// post buf\nvar pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get opts\nvar gopt = function(o) {\n    return o && {\n        out: o.size && new u8(o.size),\n        dictionary: o.dictionary\n    };\n};\n// async helper\nvar cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([\n                ev.data[0].length\n            ]);\n        } else strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function(fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat)) ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain) strm.ondrain(dat[0]);\n        } else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function(d, f) {\n        if (!strm.ondata) err(5);\n        if (t) strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n    if (flush) {\n        strm.flush = function() {\n            w.postMessage([]);\n        };\n    }\n};\n// read 2 bytes\nvar b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) err(6, \"invalid gzip data\");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += (d[10] | d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function(o) {\n    return 10 + (o.filename ? o.filename.length + 1 : 0);\n};\n// zlib header\nvar zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (o.dictionary && 32);\n    c[1] |= 31 - (c[0] << 8 | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function(d, dict) {\n    if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31) err(6, \"invalid zlib data\");\n    if ((d[1] >> 5 & 1) == +!dict) err(6, \"invalid zlib data: \" + (d[1] & 32 ? \"need\" : \"unexpected\") + \" dictionary\");\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */ var Deflate = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = {\n            l: 0,\n            i: 32768,\n            w: 32768,\n            z: 32768\n        };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        if (this.s.l) err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        } else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */ Deflate.prototype.flush = function() {\n        if (!this.ondata) err(5);\n        if (this.s.l) err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}();\nexports.Deflate = Deflate;\n/**\n * Asynchronous streaming DEFLATE compression\n */ var AsyncDeflate = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function() {\n                return [\n                    astrm,\n                    Deflate\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}();\nexports.AsyncDeflate = AsyncDeflate;\nfunction deflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bDflt\n    ], function(ev) {\n        return pbf(deflateSync(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\nexports.deflate = deflate;\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */ function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\nexports.deflateSync = deflateSync;\n/**\n * Streaming DEFLATE decompression\n */ var Inflate = /*#__PURE__*/ function() {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = {\n            i: 0,\n            b: dict ? dict.length : 0\n        };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict) this.o.set(dict);\n    }\n    Inflate.prototype.e = function(c) {\n        if (!this.ondata) err(5);\n        if (this.d) err(4);\n        if (!this.p.length) this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function(final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\nexports.Inflate = Inflate;\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var AsyncInflate = /*#__PURE__*/ function() {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function() {\n                return [\n                    astrm,\n                    Inflate\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}();\nexports.AsyncInflate = AsyncInflate;\nfunction inflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function(ev) {\n        return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));\n    }, 1, cb);\n}\nexports.inflate = inflate;\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function inflateSync(data, opts) {\n    return inflt(data, {\n        i: 2\n    }, opts && opts.out, opts && opts.dictionary);\n}\nexports.inflateSync = inflateSync;\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var Gzip = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v) gzh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */ Gzip.prototype.flush = function() {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}();\nexports.Gzip = Gzip;\nexports.Compress = Gzip;\n/**\n * Asynchronous streaming GZIP compression\n */ var AsyncGzip = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Gzip\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}();\nexports.AsyncGzip = AsyncGzip;\nexports.AsyncCompress = AsyncGzip;\nfunction gzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function() {\n            return [\n                gzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gzipSync(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\nexports.gzip = gzip;\nexports.compress = gzip;\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */ function gzipSync(data, opts) {\n    if (!opts) opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\nexports.gzipSync = gzipSync;\nexports.compressSync = gzipSync;\n/**\n * Streaming single or multi-member GZIP decompression\n */ var Gunzip = /*#__PURE__*/ function() {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final) return;\n            } else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = {\n                i: 0\n            };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}();\nexports.Gunzip = Gunzip;\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */ var AsyncGunzip = /*#__PURE__*/ function() {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Gunzip\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function(offset) {\n                return postMessage(offset);\n            };\n            onmessage = astrm(strm);\n        }, 9, 0, function(offset) {\n            return _this.onmember && _this.onmember(offset);\n        });\n    }\n    return AsyncGunzip;\n}();\nexports.AsyncGunzip = AsyncGunzip;\nfunction gunzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function() {\n            return [\n                gunzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gunzipSync(ev.data[0], ev.data[1]));\n    }, 3, cb);\n}\nexports.gunzip = gunzip;\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length) err(6, \"invalid gzip data\");\n    return inflt(data.subarray(st, -8), {\n        i: 2\n    }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\nexports.gunzipSync = gunzipSync;\n/**\n * Streaming Zlib compression\n */ var Zlib = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v) zlh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */ Zlib.prototype.flush = function() {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}();\nexports.Zlib = Zlib;\n/**\n * Asynchronous streaming Zlib compression\n */ var AsyncZlib = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Zlib\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}();\nexports.AsyncZlib = AsyncZlib;\nfunction zlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function() {\n            return [\n                zlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(zlibSync(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\nexports.zlib = zlib;\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */ function zlibSync(data, opts) {\n    if (!opts) opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\nexports.zlibSync = zlibSync;\n/**\n * Streaming Zlib decompression\n */ var Unzlib = /*#__PURE__*/ function() {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final) return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) err(6, \"invalid zlib data\");\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\nexports.Unzlib = Unzlib;\n/**\n * Asynchronous streaming Zlib decompression\n */ var AsyncUnzlib = /*#__PURE__*/ function() {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Unzlib\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}();\nexports.AsyncUnzlib = AsyncUnzlib;\nfunction unzlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function() {\n            return [\n                unzlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));\n    }, 5, cb);\n}\nexports.unzlib = unzlib;\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {\n        i: 2\n    }, opts && opts.out, opts && opts.dictionary);\n}\nexports.unzlibSync = unzlibSync;\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var Decompress = /*#__PURE__*/ function() {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function() {\n        var _this = this;\n        this.s.ondata = function(dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\nexports.Decompress = Decompress;\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var AsyncDecompress = /*#__PURE__*/ function() {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function() {\n        var _this = this;\n        this.s.ondata = function(err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function(size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain) _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\nexports.AsyncDecompress = AsyncDecompress;\nfunction decompress(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);\n}\nexports.decompress = decompress;\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function decompressSync(data, opts) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);\n}\nexports.decompressSync = decompressSync;\n// flatten a directory structure\nvar fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8) t[n] = [\n            val,\n            op\n        ];\n        else {\n            t[n += \"/\"] = [\n                new u8(0),\n                op\n            ];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// decode UTF8\nvar dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return {\n            s: r,\n            r: slc(d, i - 1)\n        };\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var DecodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds) this.t = new TextDecoder();\n        else this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length) err(8);\n            this.p = null;\n        } else this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}();\nexports.DecodeUTF8 = DecodeUTF8;\n/**\n * Streaming UTF-8 encoding\n */ var EncodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        if (this.d) err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\nexports.EncodeUTF8 = EncodeUTF8;\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */ function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te) return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return slc(ar, 0, ai);\n}\nexports.strToU8 = strToU8;\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */ function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if (td) {\n        return td.decode(dat);\n    } else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length) err(8);\n        return s;\n    }\n}\nexports.strFromU8 = strFromU8;\n;\n// deflate bit flag\nvar dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\n// read zip header\nvar zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [\n        bs,\n        b4(d, b + 24),\n        b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + b2(d, b + 30) + b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar z64e = function(d, b) {\n    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n    return [\n        b8(d, b + 12),\n        b8(d, b + 4),\n        b8(d, b + 20)\n    ];\n};\n// extra field length\nvar exfl = function(ex) {\n    var le = 0;\n    if (ex) {\n        for(var k in ex){\n            var l = ex[k].length;\n            if (l > 65535) err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) err(10);\n    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for(var k in ex){\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function(o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var ZipPassThrough = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\nexports.ZipPassThrough = ZipPassThrough;\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var ZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function(dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\nexports.ZipDeflate = ZipDeflate;\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var AsyncZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function(err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\nexports.AsyncZipDeflate = AsyncZipDeflate;\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var Zip = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this = this;\n        if (!this.ondata) err(5);\n        // finishing or finished\n        if (this.d & 2) this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || o && com.length != o.length;\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535) this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [\n                header\n            ];\n            var pAll_1 = function() {\n                for(var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++){\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function() {\n                    if (file.terminate) file.terminate();\n                },\n                r: function() {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt) nxt.r();\n                        else _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function(err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                } else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1) uf_1.r();\n                        tr_1 = 1;\n                    } else if (tr_1) pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this.d & 1)) return;\n                _this.u.splice(-1, 1);\n                _this.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\nexports.Zip = Zip;\nfunction zip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    var r = {};\n    fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbd = function(a, b) {\n        mt(function() {\n            cb(a, b);\n        });\n    };\n    mt(function() {\n        cbd = cb;\n    });\n    var cbf = function() {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            } else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(err(11, 0, 1), null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            } catch (e) {\n                cbl(e, null);\n            }\n        } else term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i){\n        _loop_1(i);\n    }\n    return tAll;\n}\nexports.zip = zip;\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */ function zipSync(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535) err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\nexports.zipSync = zipSync;\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var UnzipPassThrough = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\nexports.UnzipPassThrough = UnzipPassThrough;\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var UnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function(dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\nexports.UnzipInflate = UnzipInflate;\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var AsyncUnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function(dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        } else {\n            this.i = new AsyncInflate(function(err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\nexports.AsyncUnzipInflate = AsyncUnzipInflate;\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var Unzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this = this;\n        if (!this.onfile) err(5);\n        if (!this.p) err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [\n                                -2\n                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        } else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) err(5);\n                                if (!sc_1) file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr) file_1.ondata(err(14, \"unknown compression type \" + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++){\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c) _this.d = d_1;\n                                    else d_1.push(et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\nexports.Unzip = Unzip;\nvar mt = typeof queueMicrotask == \"function\" ? queueMicrotask : typeof setTimeout == \"function\" ? setTimeout : function(fn) {\n    fn();\n};\nfunction unzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var cbd = function(a, b) {\n        mt(function() {\n            cb(a, b);\n        });\n    };\n    mt(function() {\n        cbd = cb;\n    });\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function(i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function(e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                } else {\n                    if (d) files[fn] = d;\n                    if (!--lft) cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1) cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, {\n                                out: new u8(su)\n                            }));\n                        } catch (e) {\n                            cbl(e, null);\n                        }\n                    } else term.push(inflate(infl, {\n                        size: su\n                    }, cbl));\n                } else cbl(err(14, \"unknown compression type \" + c_1, 1), null);\n            } else cbl(null, null);\n        };\n        for(var i = 0; i < c; ++i){\n            _loop_3(i);\n        }\n    } else cbd(null, {});\n    return tAll;\n}\nexports.unzip = unzip;\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */ function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c) return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for(var i = 0; i < c; ++i){\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2) files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), {\n                out: new u8(su)\n            });\n            else err(14, \"unknown compression type \" + c_2);\n        }\n    }\n    return files;\n}\nexports.unzipSync = unzipSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmZsYXRlL2xpYi9ub2RlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDJGQUEyRjtBQUMzRixzQ0FBc0M7QUFDdEMsMkVBQTJFO0FBQzNFLHFFQUFxRTtBQUNyRSw0REFBNEQ7QUFDNUQsc0NBQXNDO0FBQ3RDLHVIQUF1SDtBQUN2SCwyRkFBMkY7QUFDM0Ysb0RBQW9EO0FBQ3BELGdCQUFnQjtBQUNoQixJQUFJQTtBQUNKLElBQUlDLFlBQVk7QUFDaEIsSUFBSTtJQUNBRCxTQUFTRSxvRUFBZ0M7QUFDN0MsRUFDQSxPQUFPQyxHQUFHLENBQ1Y7QUFDQSxJQUFJQyxnQkFBZ0IsQ0FBQztBQUNyQkEsYUFBYSxDQUFDLFVBQVUsR0FBR0osU0FBUyxTQUFVSyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDakUsSUFBSUMsT0FBTztJQUNYLElBQUlDLElBQUksSUFBSVgsT0FBT0ssSUFBSUosV0FBVztRQUFFVyxNQUFNO0lBQUssR0FDMUNDLEVBQUUsQ0FBQyxTQUFTLFNBQVVWLENBQUM7UUFBSSxPQUFPTSxHQUFHTixHQUFHO0lBQU8sR0FDL0NVLEVBQUUsQ0FBQyxXQUFXLFNBQVVDLENBQUM7UUFBSSxPQUFPTCxHQUFHLE1BQU1LO0lBQUksR0FDakRELEVBQUUsQ0FBQyxRQUFRLFNBQVVSLENBQUM7UUFDdkIsSUFBSUEsS0FBSyxDQUFDSyxNQUNORCxHQUFHLElBQUlNLE1BQU0sc0JBQXNCVixJQUFJO0lBQy9DO0lBQ0FNLEVBQUVLLFdBQVcsQ0FBQ1QsS0FBS0M7SUFDbkJHLEVBQUVNLFNBQVMsR0FBRztRQUNWUCxPQUFPO1FBQ1AsT0FBT1YsT0FBT2tCLFNBQVMsQ0FBQ0QsU0FBUyxDQUFDRSxJQUFJLENBQUNSO0lBQzNDO0lBQ0EsT0FBT0E7QUFDWCxJQUFJLFNBQVVMLENBQUMsRUFBRWMsRUFBRSxFQUFFQyxHQUFHLEVBQUVDLElBQUksRUFBRWIsRUFBRTtJQUM5QmMsYUFB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O1lBQ04wRixjQUFjekY7WUFDZFksYUFBYTRGO1FBQ2pCLElBQUk7WUFDQSxJQUFJLENBQUNBLEtBQ0RyRCxLQUFLLENBQUM5TCxHQUFHLEdBQUdwTCxJQUFJa08sTUFBTXhRLEdBQUdBLElBQUlvVztpQkFDNUIsSUFBSXlHLE9BQU8sR0FDWnJELEtBQUssQ0FBQzlMLEdBQUcsR0FBR3NCLFlBQVl3QixLQUFLak8sUUFBUSxDQUFDdkMsR0FBR0EsSUFBSW9XLEtBQUs7Z0JBQUUxTixLQUFLLElBQUl0SixHQUFHaVg7WUFBSTtpQkFFcEUzUyxJQUFJLElBQUksOEJBQThCbVo7UUFDOUM7SUFDSjtJQUNBLE9BQU9yRDtBQUNYO0FBQ0FoWCxpQkFBaUIsR0FBR29hIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbml0aS1maW5hbmNlLy4vbm9kZV9tb2R1bGVzL2ZmbGF0ZS9saWIvbm9kZS5janM/ZDkxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIERFRkxBVEUgaXMgYSBjb21wbGV4IGZvcm1hdDsgdG8gcmVhZCB0aGlzIGNvZGUsIHlvdSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhlIFJGQyBmaXJzdDpcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTUxXG4vLyBZb3UgbWF5IGFsc28gd2lzaCB0byB0YWtlIGEgbG9vayBhdCB0aGUgZ3VpZGUgSSBtYWRlIGFib3V0IHRoaXMgcHJvZ3JhbTpcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMWFycm93ei8yNTNmMzFlYjVhYmMzZDkyNzVhYjk0MzAwM2ZmZWNhZFxuLy8gU29tZSBvZiB0aGUgZm9sbG93aW5nIGNvZGUgaXMgc2ltaWxhciB0byB0aGF0IG9mIFVaSVAuanM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9wZWEvVVpJUC5qc1xuLy8gSG93ZXZlciwgdGhlIHZhc3QgbWFqb3JpdHkgb2YgdGhlIGNvZGViYXNlIGhhcyBkaXZlcmdlZCBmcm9tIFVaSVAuanMgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UgYW5kIHJlZHVjZSBidW5kbGUgc2l6ZS5cbi8vIFNvbWV0aW1lcyAwIHdpbGwgYXBwZWFyIHdoZXJlIC0xIHdvdWxkIGJlIG1vcmUgYXBwcm9wcmlhdGUuIFRoaXMgaXMgYmVjYXVzZSB1c2luZyBhIHVpbnRcbi8vIGlzIGJldHRlciBmb3IgbWVtb3J5IGluIG1vc3QgZW5naW5lcyAoSSAqdGhpbmsqKS5cbi8vIE1lZGlvY3JlIHNoaW1cbnZhciBXb3JrZXI7XG52YXIgd29ya2VyQWRkID0gXCI7dmFyIF9fdz1yZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpO19fdy5wYXJlbnRQb3J0Lm9uKCdtZXNzYWdlJyxmdW5jdGlvbihtKXtvbm1lc3NhZ2Uoe2RhdGE6bX0pfSkscG9zdE1lc3NhZ2U9ZnVuY3Rpb24obSx0KXtfX3cucGFyZW50UG9ydC5wb3N0TWVzc2FnZShtLHQpfSxjbG9zZT1wcm9jZXNzLmV4aXQ7c2VsZj1nbG9iYWxcIjtcbnRyeSB7XG4gICAgV29ya2VyID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKS5Xb3JrZXI7XG59XG5jYXRjaCAoZSkge1xufVxudmFyIG5vZGVfd29ya2VyXzEgPSB7fTtcbm5vZGVfd29ya2VyXzFbXCJkZWZhdWx0XCJdID0gV29ya2VyID8gZnVuY3Rpb24gKGMsIF8sIG1zZywgdHJhbnNmZXIsIGNiKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgdyA9IG5ldyBXb3JrZXIoYyArIHdvcmtlckFkZCwgeyBldmFsOiB0cnVlIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gY2IoZSwgbnVsbCk7IH0pXG4gICAgICAgIC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtKSB7IHJldHVybiBjYihudWxsLCBtKTsgfSlcbiAgICAgICAgLm9uKCdleGl0JywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgJiYgIWRvbmUpXG4gICAgICAgICAgICBjYihuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGNvZGUgJyArIGMpLCBudWxsKTtcbiAgICB9KTtcbiAgICB3LnBvc3RNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xuICAgIHcudGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFdvcmtlci5wcm90b3R5cGUudGVybWluYXRlLmNhbGwodyk7XG4gICAgfTtcbiAgICByZXR1cm4gdztcbn0gOiBmdW5jdGlvbiAoXywgX18sIF9fXywgX19fXywgY2IpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2IobmV3IEVycm9yKCdhc3luYyBvcGVyYXRpb25zIHVuc3VwcG9ydGVkIC0gdXBkYXRlIHRvIE5vZGUgMTIrIChvciBOb2RlIDEwLTExIHdpdGggdGhlIC0tZXhwZXJpbWVudGFsLXdvcmtlciBDTEkgZmxhZyknKSwgbnVsbCk7IH0pO1xuICAgIHZhciBOT1AgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGVybWluYXRlOiBOT1AsXG4gICAgICAgIHBvc3RNZXNzYWdlOiBOT1BcbiAgICB9O1xufTtcblxuLy8gYWxpYXNlcyBmb3Igc2hvcnRlciBjb21wcmVzc2VkIGNvZGUgKG1vc3QgbWluaWZlcnMgZG9uJ3QgZG8gdGhpcylcbnZhciB1OCA9IFVpbnQ4QXJyYXksIHUxNiA9IFVpbnQxNkFycmF5LCBpMzIgPSBJbnQzMkFycmF5O1xuLy8gZml4ZWQgbGVuZ3RoIGV4dHJhIGJpdHNcbnZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8gMCwgMCwgLyogaW1wb3NzaWJsZSAqLyAwXSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG52YXIgZmRlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAvKiB1bnVzZWQgKi8gMCwgMF0pO1xuLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG52YXIgY2xpbSA9IG5ldyB1OChbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuLy8gZ2V0IGJhc2UsIHJldmVyc2UgaW5kZXggbWFwIGZyb20gZXh0cmEgYml0c1xudmFyIGZyZWIgPSBmdW5jdGlvbiAoZWIsIHN0YXJ0KSB7XG4gICAgdmFyIGIgPSBuZXcgdTE2KDMxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMxOyArK2kpIHtcbiAgICAgICAgYltpXSA9IHN0YXJ0ICs9IDEgPDwgZWJbaSAtIDFdO1xuICAgIH1cbiAgICAvLyBudW1iZXJzIGhlcmUgYXJlIGF0IG1heCAxOCBiaXRzXG4gICAgdmFyIHIgPSBuZXcgaTMyKGJbMzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGJbaV07IGogPCBiW2kgKyAxXTsgKytqKSB7XG4gICAgICAgICAgICByW2pdID0gKChqIC0gYltpXSkgPDwgNSkgfCBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGI6IGIsIHI6IHIgfTtcbn07XG52YXIgX2EgPSBmcmViKGZsZWIsIDIpLCBmbCA9IF9hLmIsIHJldmZsID0gX2Eucjtcbi8vIHdlIGNhbiBpZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgb3RoZXIgbnVtYmVycyBhcmUgd3Jvbmc7IHRoZXkgbmV2ZXIgaGFwcGVuIGFueXdheVxuZmxbMjhdID0gMjU4LCByZXZmbFsyNThdID0gMjg7XG52YXIgX2IgPSBmcmViKGZkZWIsIDApLCBmZCA9IF9iLmIsIHJldmZkID0gX2Iucjtcbi8vIG1hcCBvZiB2YWx1ZSB0byByZXZlcnNlIChhc3N1bWluZyAxNiBiaXRzKVxudmFyIHJldiA9IG5ldyB1MTYoMzI3NjgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjc2ODsgKytpKSB7XG4gICAgLy8gcmV2ZXJzZSB0YWJsZSBhbGdvcml0aG0gZnJvbSBTT1xuICAgIHZhciB4ID0gKChpICYgMHhBQUFBKSA+PiAxKSB8ICgoaSAmIDB4NTU1NSkgPDwgMSk7XG4gICAgeCA9ICgoeCAmIDB4Q0NDQykgPj4gMikgfCAoKHggJiAweDMzMzMpIDw8IDIpO1xuICAgIHggPSAoKHggJiAweEYwRjApID4+IDQpIHwgKCh4ICYgMHgwRjBGKSA8PCA0KTtcbiAgICByZXZbaV0gPSAoKCh4ICYgMHhGRjAwKSA+PiA4KSB8ICgoeCAmIDB4MDBGRikgPDwgOCkpID4+IDE7XG59XG4vLyBjcmVhdGUgaHVmZm1hbiB0cmVlIGZyb20gdTggXCJtYXBcIjogaW5kZXggLT4gY29kZSBsZW5ndGggZm9yIGNvZGUgaW5kZXhcbi8vIG1iIChtYXggYml0cykgbXVzdCBiZSBhdCBtb3N0IDE1XG4vLyBUT0RPOiBvcHRpbWl6ZS9zcGxpdCB1cD9cbnZhciBoTWFwID0gKGZ1bmN0aW9uIChjZCwgbWIsIHIpIHtcbiAgICB2YXIgcyA9IGNkLmxlbmd0aDtcbiAgICAvLyBpbmRleFxuICAgIHZhciBpID0gMDtcbiAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gIyBvZiBjb2RlcyB3aXRoIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsID0gbmV3IHUxNihtYik7XG4gICAgLy8gbGVuZ3RoIG9mIGNkIG11c3QgYmUgMjg4ICh0b3RhbCAjIG9mIGNvZGVzKVxuICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgIGlmIChjZFtpXSlcbiAgICAgICAgICAgICsrbFtjZFtpXSAtIDFdO1xuICAgIH1cbiAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbWluaW11bSBjb2RlIGZvciBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbGUgPSBuZXcgdTE2KG1iKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbWI7ICsraSkge1xuICAgICAgICBsZVtpXSA9IChsZVtpIC0gMV0gKyBsW2kgLSAxXSkgPDwgMTtcbiAgICB9XG4gICAgdmFyIGNvO1xuICAgIGlmIChyKSB7XG4gICAgICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBudW1iZXIgb2YgYWN0dWFsIGJpdHMsIHN5bWJvbCBmb3IgY29kZVxuICAgICAgICBjbyA9IG5ldyB1MTYoMSA8PCBtYik7XG4gICAgICAgIC8vIGJpdHMgdG8gcmVtb3ZlIGZvciByZXZlcnNlclxuICAgICAgICB2YXIgcnZiID0gMTUgLSBtYjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIDAgbGVuZ3Roc1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtIGVuY29kaW5nIGJvdGggc3ltYm9sIGFuZCBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICB2YXIgc3YgPSAoaSA8PCA0KSB8IGNkW2ldO1xuICAgICAgICAgICAgICAgIC8vIGZyZWUgYml0c1xuICAgICAgICAgICAgICAgIHZhciByXzEgPSBtYiAtIGNkW2ldO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBsZVtjZFtpXSAtIDFdKysgPDwgcl8xO1xuICAgICAgICAgICAgICAgIC8vIG0gaXMgZW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IHYgfCAoKDEgPDwgcl8xKSAtIDEpOyB2IDw9IG07ICsrdikge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVyeSAxNiBiaXQgdmFsdWUgc3RhcnRpbmcgd2l0aCB0aGUgY29kZSB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGNvW3Jldlt2XSA+PiBydmJdID0gc3Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbyA9IG5ldyB1MTYocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvW2ldID0gcmV2W2xlW2NkW2ldIC0gMV0rK10gPj4gKDE1IC0gY2RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbztcbn0pO1xuLy8gZml4ZWQgbGVuZ3RoIHRyZWVcbnZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gICAgZmx0W2ldID0gODtcbmZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICBmbHRbaV0gPSA5O1xuZm9yICh2YXIgaSA9IDI1NjsgaSA8IDI4MDsgKytpKVxuICAgIGZsdFtpXSA9IDc7XG5mb3IgKHZhciBpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gICAgZmx0W2ldID0gODtcbi8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgIGZkdFtpXSA9IDU7XG4vLyBmaXhlZCBsZW5ndGggbWFwXG52YXIgZmxtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMCksIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbi8vIGZpeGVkIGRpc3RhbmNlIG1hcFxudmFyIGZkbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDApLCBmZHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMSk7XG4vLyBmaW5kIG1heCBvZiBhcnJheVxudmFyIG1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIG0gPSBhWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA+IG0pXG4gICAgICAgICAgICBtID0gYVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbnZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xufTtcbi8vIGdldCBlbmQgb2YgYnl0ZVxudmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwICsgNykgLyA4KSB8IDA7IH07XG4vLyB0eXBlZCBhcnJheSBzbGljZSAtIGFsbG93cyBnYXJiYWdlIGNvbGxlY3RvciB0byBmcmVlIG9yaWdpbmFsIHJlZmVyZW5jZSxcbi8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICAvLyBjYW4ndCB1c2UgLmNvbnN0cnVjdG9yIGluIGNhc2UgdXNlci1zdXBwbGllZFxuICAgIHJldHVybiBuZXcgdTgodi5zdWJhcnJheShzLCBlKSk7XG59O1xuLyoqXG4gKiBDb2RlcyBmb3IgZXJyb3JzIGdlbmVyYXRlZCB3aXRoaW4gdGhpcyBsaWJyYXJ5XG4gKi9cbmV4cG9ydHMuRmxhdGVFcnJvckNvZGUgPSB7XG4gICAgVW5leHBlY3RlZEVPRjogMCxcbiAgICBJbnZhbGlkQmxvY2tUeXBlOiAxLFxuICAgIEludmFsaWRMZW5ndGhMaXRlcmFsOiAyLFxuICAgIEludmFsaWREaXN0YW5jZTogMyxcbiAgICBTdHJlYW1GaW5pc2hlZDogNCxcbiAgICBOb1N0cmVhbUhhbmRsZXI6IDUsXG4gICAgSW52YWxpZEhlYWRlcjogNixcbiAgICBOb0NhbGxiYWNrOiA3LFxuICAgIEludmFsaWRVVEY4OiA4LFxuICAgIEV4dHJhRmllbGRUb29Mb25nOiA5LFxuICAgIEludmFsaWREYXRlOiAxMCxcbiAgICBGaWxlbmFtZVRvb0xvbmc6IDExLFxuICAgIFN0cmVhbUZpbmlzaGluZzogMTIsXG4gICAgSW52YWxpZFppcERhdGE6IDEzLFxuICAgIFVua25vd25Db21wcmVzc2lvbk1ldGhvZDogMTRcbn07XG4vLyBlcnJvciBjb2Rlc1xudmFyIGVjID0gW1xuICAgICd1bmV4cGVjdGVkIEVPRicsXG4gICAgJ2ludmFsaWQgYmxvY2sgdHlwZScsXG4gICAgJ2ludmFsaWQgbGVuZ3RoL2xpdGVyYWwnLFxuICAgICdpbnZhbGlkIGRpc3RhbmNlJyxcbiAgICAnc3RyZWFtIGZpbmlzaGVkJyxcbiAgICAnbm8gc3RyZWFtIGhhbmRsZXInLFxuICAgICxcbiAgICAnbm8gY2FsbGJhY2snLFxuICAgICdpbnZhbGlkIFVURi04IGRhdGEnLFxuICAgICdleHRyYSBmaWVsZCB0b28gbG9uZycsXG4gICAgJ2RhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OScsXG4gICAgJ2ZpbGVuYW1lIHRvbyBsb25nJyxcbiAgICAnc3RyZWFtIGZpbmlzaGluZycsXG4gICAgJ2ludmFsaWQgemlwIGRhdGEnXG4gICAgLy8gZGV0ZXJtaW5lZCBieSB1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFxuXTtcbjtcbnZhciBlcnIgPSBmdW5jdGlvbiAoaW5kLCBtc2csIG50KSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobXNnIHx8IGVjW2luZF0pO1xuICAgIGUuY29kZSA9IGluZDtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGUsIGVycik7XG4gICAgaWYgKCFudClcbiAgICAgICAgdGhyb3cgZTtcbiAgICByZXR1cm4gZTtcbn07XG4vLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbnZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIHN0LCBidWYsIGRpY3QpIHtcbiAgICAvLyBzb3VyY2UgbGVuZ3RoICAgICAgIGRpY3QgbGVuZ3RoXG4gICAgdmFyIHNsID0gZGF0Lmxlbmd0aCwgZGwgPSBkaWN0ID8gZGljdC5sZW5ndGggOiAwO1xuICAgIGlmICghc2wgfHwgc3QuZiAmJiAhc3QubClcbiAgICAgICAgcmV0dXJuIGJ1ZiB8fCBuZXcgdTgoMCk7XG4gICAgdmFyIG5vQnVmID0gIWJ1ZjtcbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgcmVzaXplID0gbm9CdWYgfHwgc3QuaSAhPSAyO1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSBzdC5pO1xuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmIChub0J1ZilcbiAgICAgICAgYnVmID0gbmV3IHU4KHNsICogMyk7XG4gICAgLy8gZW5zdXJlIGJ1ZmZlciBjYW4gZml0IGF0IGxlYXN0IGwgZWxlbWVudHNcbiAgICB2YXIgY2J1ZiA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciBibCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugc2l6ZSB0byBmaXRcbiAgICAgICAgaWYgKGwgPiBibCkge1xuICAgICAgICAgICAgLy8gRG91YmxlIG9yIHNldCB0byBuZWNlc3NhcnksIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICB2YXIgbmJ1ZiA9IG5ldyB1OChNYXRoLm1heChibCAqIDIsIGwpKTtcbiAgICAgICAgICAgIG5idWYuc2V0KGJ1Zik7XG4gICAgICAgICAgICBidWYgPSBuYnVmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAgbGFzdCBjaHVuayAgICAgICAgIGJpdHBvcyAgICAgICAgICAgYnl0ZXNcbiAgICB2YXIgZmluYWwgPSBzdC5mIHx8IDAsIHBvcyA9IHN0LnAgfHwgMCwgYnQgPSBzdC5iIHx8IDAsIGxtID0gc3QubCwgZG0gPSBzdC5kLCBsYnQgPSBzdC5tLCBkYnQgPSBzdC5uO1xuICAgIC8vIHRvdGFsIGJpdHNcbiAgICB2YXIgdGJ0cyA9IHNsICogODtcbiAgICBkbyB7XG4gICAgICAgIGlmICghbG0pIHtcbiAgICAgICAgICAgIC8vIEJGSU5BTCAtIHRoaXMgaXMgb25seSAxIHdoZW4gbGFzdCBjaHVuayBpcyBuZXh0XG4gICAgICAgICAgICBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzaXplXG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogOCwgc3QuZiA9IGZpbmFsO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIGxtID0gZmxybSwgZG0gPSBmZHJtLCBsYnQgPSA5LCBkYnQgPSA1O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gIGxpdGVyYWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3Roc1xuICAgICAgICAgICAgICAgIHZhciBoTGl0ID0gYml0cyhkYXQsIHBvcywgMzEpICsgMjU3LCBoY0xlbiA9IGJpdHMoZGF0LCBwb3MgKyAxMCwgMTUpICsgNDtcbiAgICAgICAgICAgICAgICB2YXIgdGwgPSBoTGl0ICsgYml0cyhkYXQsIHBvcyArIDUsIDMxKSArIDE7XG4gICAgICAgICAgICAgICAgcG9zICs9IDE0O1xuICAgICAgICAgICAgICAgIC8vIGxlbmd0aCtkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGxkdCA9IG5ldyB1OCh0bCk7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdHJlZVxuICAgICAgICAgICAgICAgIHZhciBjbHQgPSBuZXcgdTgoMTkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW5kZXggbWFwIHRvIGdldCByZWFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgY2x0W2NsaW1baV1dID0gYml0cyhkYXQsIHBvcyArIGkgKiAzLCA3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGhjTGVuICogMztcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgYml0c1xuICAgICAgICAgICAgICAgIHZhciBjbGIgPSBtYXgoY2x0KSwgY2xibXNrID0gKDEgPDwgY2xiKSAtIDE7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIG1hcFxuICAgICAgICAgICAgICAgIHZhciBjbG0gPSBoTWFwKGNsdCwgY2xiLCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRsOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGNsbVtiaXRzKGRhdCwgcG9zLCBjbGJtc2spXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyByZWFkXG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSByICYgMTU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHIgPj4gNDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdG8gY29weVxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29weSAgIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCAzKSwgcG9zICs9IDIsIGMgPSBsZHRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxNylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDcpLCBwb3MgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDExICsgYml0cyhkYXQsIHBvcywgMTI3KSwgcG9zICs9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICBsZW5ndGggdHJlZSAgICAgICAgICAgICAgICAgZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsdCA9IGxkdC5zdWJhcnJheSgwLCBoTGl0KSwgZHQgPSBsZHQuc3ViYXJyYXkoaExpdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGxlbmd0aCBiaXRzXG4gICAgICAgICAgICAgICAgbGJ0ID0gbWF4KGx0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggZGlzdCBiaXRzXG4gICAgICAgICAgICAgICAgZGJ0ID0gbWF4KGR0KTtcbiAgICAgICAgICAgICAgICBsbSA9IGhNYXAobHQsIGxidCwgMSk7XG4gICAgICAgICAgICAgICAgZG0gPSBoTWFwKGR0LCBkYnQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVycigxKTtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBjYW4gaG9sZCB0aGlzICsgdGhlIGxhcmdlc3QgcG9zc2libGUgYWRkaXRpb25cbiAgICAgICAgLy8gTWF4aW11bSBjaHVuayBzaXplIChwcmFjdGljYWxseSwgdGhlb3JldGljYWxseSBpbmZpbml0ZSkgaXMgMl4xN1xuICAgICAgICBpZiAocmVzaXplKVxuICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgIHZhciBsbXMgPSAoMSA8PCBsYnQpIC0gMSwgZG1zID0gKDEgPDwgZGJ0KSAtIDE7XG4gICAgICAgIHZhciBscG9zID0gcG9zO1xuICAgICAgICBmb3IgKDs7IGxwb3MgPSBwb3MpIHtcbiAgICAgICAgICAgIC8vIGJpdHMgcmVhZCwgY29kZVxuICAgICAgICAgICAgdmFyIGMgPSBsbVtiaXRzMTYoZGF0LCBwb3MpICYgbG1zXSwgc3ltID0gYyA+PiA0O1xuICAgICAgICAgICAgcG9zICs9IGMgJiAxNTtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYylcbiAgICAgICAgICAgICAgICBlcnIoMik7XG4gICAgICAgICAgICBpZiAoc3ltIDwgMjU2KVxuICAgICAgICAgICAgICAgIGJ1ZltidCsrXSA9IHN5bTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bSA9PSAyNTYpIHtcbiAgICAgICAgICAgICAgICBscG9zID0gcG9zLCBsbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkID0gc3ltIC0gMjU0O1xuICAgICAgICAgICAgICAgIC8vIG5vIGV4dHJhIGJpdHMgbmVlZGVkIGlmIGxlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3ltID4gMjY0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gc3ltIC0gMjU3LCBiID0gZmxlYltpXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gYml0cyhkYXQsIHBvcywgKDEgPDwgYikgLSAxKSArIGZsW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGlzdFxuICAgICAgICAgICAgICAgIHZhciBkID0gZG1bYml0czE2KGRhdCwgcG9zKSAmIGRtc10sIGRzeW0gPSBkID4+IDQ7XG4gICAgICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICAgICAgICBlcnIoMyk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGQgJiAxNTtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBmZFtkc3ltXTtcbiAgICAgICAgICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBmZGViW2RzeW1dO1xuICAgICAgICAgICAgICAgICAgICBkdCArPSBiaXRzMTYoZGF0LCBwb3MpICYgKDEgPDwgYikgLSAxLCBwb3MgKz0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzaXplKVxuICAgICAgICAgICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYnQgKyBhZGQ7XG4gICAgICAgICAgICAgICAgaWYgKGJ0IDwgZHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoaWZ0ID0gZGwgLSBkdCwgZGVuZCA9IE1hdGgubWluKGR0LCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnQgKyBidCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIoMyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGRlbmQ7ICsrYnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gZGljdFtzaGlmdCArIGJ0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICg7IGJ0IDwgZW5kOyArK2J0KVxuICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0LmwgPSBsbSwgc3QucCA9IGxwb3MsIHN0LmIgPSBidCwgc3QuZiA9IGZpbmFsO1xuICAgICAgICBpZiAobG0pXG4gICAgICAgICAgICBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDtcbiAgICB9IHdoaWxlICghZmluYWwpO1xuICAgIC8vIGRvbid0IHJlYWxsb2NhdGUgZm9yIHN0cmVhbXMgb3IgdXNlciBidWZmZXJzXG4gICAgcmV0dXJuIGJ0ICE9IGJ1Zi5sZW5ndGggJiYgbm9CdWYgPyBzbGMoYnVmLCAwLCBidCkgOiBidWYuc3ViYXJyYXkoMCwgYnQpO1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4gODtcbn07XG4vLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyAoPjgpIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMxNiA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+PiA4O1xuICAgIGRbbyArIDJdIHw9IHYgPj4gMTY7XG59O1xuLy8gY3JlYXRlcyBjb2RlIGxlbmd0aHMgZnJvbSBhIGZyZXF1ZW5jeSB0YWJsZVxudmFyIGhUcmVlID0gZnVuY3Rpb24gKGQsIG1iKSB7XG4gICAgLy8gTmVlZCBleHRyYSBpbmZvIHRvIG1ha2UgYSB0cmVlXG4gICAgdmFyIHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGRbaV0pXG4gICAgICAgICAgICB0LnB1c2goeyBzOiBpLCBmOiBkW2ldIH0pO1xuICAgIH1cbiAgICB2YXIgcyA9IHQubGVuZ3RoO1xuICAgIHZhciB0MiA9IHQuc2xpY2UoKTtcbiAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiB7IHQ6IGV0LCBsOiAwIH07XG4gICAgaWYgKHMgPT0gMSkge1xuICAgICAgICB2YXIgdiA9IG5ldyB1OCh0WzBdLnMgKyAxKTtcbiAgICAgICAgdlt0WzBdLnNdID0gMTtcbiAgICAgICAgcmV0dXJuIHsgdDogdiwgbDogMSB9O1xuICAgIH1cbiAgICB0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZiAtIGIuZjsgfSk7XG4gICAgLy8gYWZ0ZXIgaTIgcmVhY2hlcyBsYXN0IGluZCwgd2lsbCBiZSBzdG9wcGVkXG4gICAgLy8gZnJlcSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBsYXJnZXN0IHBvc3NpYmxlIG51bWJlciBvZiBzeW1ib2xzXG4gICAgdC5wdXNoKHsgczogLTEsIGY6IDI1MDAxIH0pO1xuICAgIHZhciBsID0gdFswXSwgciA9IHRbMV0sIGkwID0gMCwgaTEgPSAxLCBpMiA9IDI7XG4gICAgdFswXSA9IHsgczogLTEsIGY6IGwuZiArIHIuZiwgbDogbCwgcjogciB9O1xuICAgIC8vIGVmZmljaWVudCBhbGdvcml0aG0gZnJvbSBVWklQLmpzXG4gICAgLy8gaTAgaXMgbG9va2JlaGluZCwgaTIgaXMgbG9va2FoZWFkIC0gYWZ0ZXIgcHJvY2Vzc2luZyB0d28gbG93LWZyZXFcbiAgICAvLyBzeW1ib2xzIHRoYXQgY29tYmluZWQgaGF2ZSBoaWdoIGZyZXEsIHdpbGwgc3RhcnQgcHJvY2Vzc2luZyBpMiAoaGlnaC1mcmVxLFxuICAgIC8vIG5vbi1jb21wb3NpdGUpIHN5bWJvbHMgaW5zdGVhZFxuICAgIC8vIHNlZSBodHRwczovL3JlZGRpdC5jb20vci9waG90b3BlYS9jb21tZW50cy9pa2VraHQvdXppcGpzX3F1ZXN0aW9ucy9cbiAgICB3aGlsZSAoaTEgIT0gcyAtIDEpIHtcbiAgICAgICAgbCA9IHRbdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICAgIHIgPSB0W2kwICE9IGkxICYmIHRbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgICB0W2kxKytdID0geyBzOiAtMSwgZjogbC5mICsgci5mLCBsOiBsLCByOiByIH07XG4gICAgfVxuICAgIHZhciBtYXhTeW0gPSB0MlswXS5zO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgKytpKSB7XG4gICAgICAgIGlmICh0MltpXS5zID4gbWF4U3ltKVxuICAgICAgICAgICAgbWF4U3ltID0gdDJbaV0ucztcbiAgICB9XG4gICAgLy8gY29kZSBsZW5ndGhzXG4gICAgdmFyIHRyID0gbmV3IHUxNihtYXhTeW0gKyAxKTtcbiAgICAvLyBtYXggYml0cyBpbiB0cmVlXG4gICAgdmFyIG1idCA9IGxuKHRbaTEgLSAxXSwgdHIsIDApO1xuICAgIGlmIChtYnQgPiBtYikge1xuICAgICAgICAvLyBtb3JlIGFsZ29yaXRobXMgZnJvbSBVWklQLmpzXG4gICAgICAgIC8vIFRPRE86IGZpbmQgb3V0IGhvdyB0aGlzIGNvZGUgd29ya3MgKGRlYnQpXG4gICAgICAgIC8vICBpbmQgICAgZGVidFxuICAgICAgICB2YXIgaSA9IDAsIGR0ID0gMDtcbiAgICAgICAgLy8gICAgbGVmdCAgICAgICAgICAgIGNvc3RcbiAgICAgICAgdmFyIGxmdCA9IG1idCAtIG1iLCBjc3QgPSAxIDw8IGxmdDtcbiAgICAgICAgdDIuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gdHJbYi5zXSAtIHRyW2Euc10gfHwgYS5mIC0gYi5mOyB9KTtcbiAgICAgICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpMl8xID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8xXSA+IG1iKSB7XG4gICAgICAgICAgICAgICAgZHQgKz0gY3N0IC0gKDEgPDwgKG1idCAtIHRyW2kyXzFdKSk7XG4gICAgICAgICAgICAgICAgdHJbaTJfMV0gPSBtYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkdCA+Pj0gbGZ0O1xuICAgICAgICB3aGlsZSAoZHQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgaTJfMiA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMl0gPCBtYilcbiAgICAgICAgICAgICAgICBkdCAtPSAxIDw8IChtYiAtIHRyW2kyXzJdKysgLSAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPj0gMCAmJiBkdDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgaTJfMyA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfM10gPT0gbWIpIHtcbiAgICAgICAgICAgICAgICAtLXRyW2kyXzNdO1xuICAgICAgICAgICAgICAgICsrZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWJ0ID0gbWI7XG4gICAgfVxuICAgIHJldHVybiB7IHQ6IG5ldyB1OCh0ciksIGw6IG1idCB9O1xufTtcbi8vIGdldCB0aGUgbWF4IGxlbmd0aCBhbmQgYXNzaWduIGxlbmd0aCBjb2Rlc1xudmFyIGxuID0gZnVuY3Rpb24gKG4sIGwsIGQpIHtcbiAgICByZXR1cm4gbi5zID09IC0xXG4gICAgICAgID8gTWF0aC5tYXgobG4obi5sLCBsLCBkICsgMSksIGxuKG4uciwgbCwgZCArIDEpKVxuICAgICAgICA6IChsW24uc10gPSBkKTtcbn07XG4vLyBsZW5ndGggY29kZXMgZ2VuZXJhdGlvblxudmFyIGxjID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgcyA9IGMubGVuZ3RoO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VtaWNvbG9uIHdhcyBpbnRlbnRpb25hbFxuICAgIHdoaWxlIChzICYmICFjWy0tc10pXG4gICAgICAgIDtcbiAgICB2YXIgY2wgPSBuZXcgdTE2KCsrcyk7XG4gICAgLy8gIGluZCAgICAgIG51bSAgICAgICAgIHN0cmVha1xuICAgIHZhciBjbGkgPSAwLCBjbG4gPSBjWzBdLCBjbHMgPSAxO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgY2xbY2xpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzOyArK2kpIHtcbiAgICAgICAgaWYgKGNbaV0gPT0gY2xuICYmIGkgIT0gcylcbiAgICAgICAgICAgICsrY2xzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY2xuICYmIGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgY2xzID4gMTM4OyBjbHMgLT0gMTM4KVxuICAgICAgICAgICAgICAgICAgICB3KDMyNzU0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMikge1xuICAgICAgICAgICAgICAgICAgICB3KGNscyA+IDEwID8gKChjbHMgLSAxMSkgPDwgNSkgfCAyODY5MCA6ICgoY2xzIC0gMykgPDwgNSkgfCAxMjMwNSk7XG4gICAgICAgICAgICAgICAgICAgIGNscyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xzID4gMykge1xuICAgICAgICAgICAgICAgIHcoY2xuKSwgLS1jbHM7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDY7IGNscyAtPSA2KVxuICAgICAgICAgICAgICAgICAgICB3KDgzMDQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMgPiAyKVxuICAgICAgICAgICAgICAgICAgICB3KCgoY2xzIC0gMykgPDwgNSkgfCA4MjA4KSwgY2xzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjbHMtLSlcbiAgICAgICAgICAgICAgICB3KGNsbik7XG4gICAgICAgICAgICBjbHMgPSAxO1xuICAgICAgICAgICAgY2xuID0gY1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjOiBjbC5zdWJhcnJheSgwLCBjbGkpLCBuOiBzIH07XG59O1xuLy8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2Ygb3V0cHV0IGZyb20gdHJlZSwgY29kZSBsZW5ndGhzXG52YXIgY2xlbiA9IGZ1bmN0aW9uIChjZiwgY2wpIHtcbiAgICB2YXIgbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbC5sZW5ndGg7ICsraSlcbiAgICAgICAgbCArPSBjZltpXSAqIGNsW2ldO1xuICAgIHJldHVybiBsO1xufTtcbi8vIHdyaXRlcyBhIGZpeGVkIGJsb2NrXG4vLyByZXR1cm5zIHRoZSBuZXcgYml0IHBvc1xudmFyIHdmYmxrID0gZnVuY3Rpb24gKG91dCwgcG9zLCBkYXQpIHtcbiAgICAvLyBubyBuZWVkIHRvIHdyaXRlIDAwIGFzIHR5cGU6IFR5cGVkQXJyYXkgZGVmYXVsdHMgdG8gMFxuICAgIHZhciBzID0gZGF0Lmxlbmd0aDtcbiAgICB2YXIgbyA9IHNoZnQocG9zICsgMik7XG4gICAgb3V0W29dID0gcyAmIDI1NTtcbiAgICBvdXRbbyArIDFdID0gcyA+PiA4O1xuICAgIG91dFtvICsgMl0gPSBvdXRbb10gXiAyNTU7XG4gICAgb3V0W28gKyAzXSA9IG91dFtvICsgMV0gXiAyNTU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyArK2kpXG4gICAgICAgIG91dFtvICsgaSArIDRdID0gZGF0W2ldO1xuICAgIHJldHVybiAobyArIDQgKyBzKSAqIDg7XG59O1xuLy8gd3JpdGVzIGEgYmxvY2tcbnZhciB3YmxrID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBmaW5hbCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBibCwgcCkge1xuICAgIHdiaXRzKG91dCwgcCsrLCBmaW5hbCk7XG4gICAgKytsZlsyNTZdO1xuICAgIHZhciBfYSA9IGhUcmVlKGxmLCAxNSksIGRsdCA9IF9hLnQsIG1sYiA9IF9hLmw7XG4gICAgdmFyIF9iID0gaFRyZWUoZGYsIDE1KSwgZGR0ID0gX2IudCwgbWRiID0gX2IubDtcbiAgICB2YXIgX2MgPSBsYyhkbHQpLCBsY2x0ID0gX2MuYywgbmxjID0gX2MubjtcbiAgICB2YXIgX2QgPSBsYyhkZHQpLCBsY2R0ID0gX2QuYywgbmRjID0gX2QubjtcbiAgICB2YXIgbGNmcmVxID0gbmV3IHUxNigxOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsY2x0Lmxlbmd0aDsgKytpKVxuICAgICAgICArK2xjZnJlcVtsY2x0W2ldICYgMzFdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGNkdC5sZW5ndGg7ICsraSlcbiAgICAgICAgKytsY2ZyZXFbbGNkdFtpXSAmIDMxXTtcbiAgICB2YXIgX2UgPSBoVHJlZShsY2ZyZXEsIDcpLCBsY3QgPSBfZS50LCBtbGNiID0gX2UubDtcbiAgICB2YXIgbmxjYyA9IDE5O1xuICAgIGZvciAoOyBubGNjID4gNCAmJiAhbGN0W2NsaW1bbmxjYyAtIDFdXTsgLS1ubGNjKVxuICAgICAgICA7XG4gICAgdmFyIGZsZW4gPSAoYmwgKyA1KSA8PCAzO1xuICAgIHZhciBmdGxlbiA9IGNsZW4obGYsIGZsdCkgKyBjbGVuKGRmLCBmZHQpICsgZWI7XG4gICAgdmFyIGR0bGVuID0gY2xlbihsZiwgZGx0KSArIGNsZW4oZGYsIGRkdCkgKyBlYiArIDE0ICsgMyAqIG5sY2MgKyBjbGVuKGxjZnJlcSwgbGN0KSArIDIgKiBsY2ZyZXFbMTZdICsgMyAqIGxjZnJlcVsxN10gKyA3ICogbGNmcmVxWzE4XTtcbiAgICBpZiAoYnMgPj0gMCAmJiBmbGVuIDw9IGZ0bGVuICYmIGZsZW4gPD0gZHRsZW4pXG4gICAgICAgIHJldHVybiB3ZmJsayhvdXQsIHAsIGRhdC5zdWJhcnJheShicywgYnMgKyBibCkpO1xuICAgIHZhciBsbSwgbGwsIGRtLCBkbDtcbiAgICB3Yml0cyhvdXQsIHAsIDEgKyAoZHRsZW4gPCBmdGxlbikpLCBwICs9IDI7XG4gICAgaWYgKGR0bGVuIDwgZnRsZW4pIHtcbiAgICAgICAgbG0gPSBoTWFwKGRsdCwgbWxiLCAwKSwgbGwgPSBkbHQsIGRtID0gaE1hcChkZHQsIG1kYiwgMCksIGRsID0gZGR0O1xuICAgICAgICB2YXIgbGxtID0gaE1hcChsY3QsIG1sY2IsIDApO1xuICAgICAgICB3Yml0cyhvdXQsIHAsIG5sYyAtIDI1Nyk7XG4gICAgICAgIHdiaXRzKG91dCwgcCArIDUsIG5kYyAtIDEpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyAxMCwgbmxjYyAtIDQpO1xuICAgICAgICBwICs9IDE0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5sY2M7ICsraSlcbiAgICAgICAgICAgIHdiaXRzKG91dCwgcCArIDMgKiBpLCBsY3RbY2xpbVtpXV0pO1xuICAgICAgICBwICs9IDMgKiBubGNjO1xuICAgICAgICB2YXIgbGN0cyA9IFtsY2x0LCBsY2R0XTtcbiAgICAgICAgZm9yICh2YXIgaXQgPSAwOyBpdCA8IDI7ICsraXQpIHtcbiAgICAgICAgICAgIHZhciBjbGN0ID0gbGN0c1tpdF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2xjdFtpXSAmIDMxO1xuICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgbGxtW2xlbl0pLCBwICs9IGxjdFtsZW5dO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxNSlcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoY2xjdFtpXSA+PiA1KSAmIDEyNyksIHAgKz0gY2xjdFtpXSA+PiAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG0gPSBmbG0sIGxsID0gZmx0LCBkbSA9IGZkbSwgZGwgPSBmZHQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGk7ICsraSkge1xuICAgICAgICB2YXIgc3ltID0gc3ltc1tpXTtcbiAgICAgICAgaWYgKHN5bSA+IDI1NSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IChzeW0gPj4gMTgpICYgMzE7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bbGVuICsgMjU3XSksIHAgKz0gbGxbbGVuICsgMjU3XTtcbiAgICAgICAgICAgIGlmIChsZW4gPiA3KVxuICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgKHN5bSA+PiAyMykgJiAzMSksIHAgKz0gZmxlYltsZW5dO1xuICAgICAgICAgICAgdmFyIGRzdCA9IHN5bSAmIDMxO1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGRtW2RzdF0pLCBwICs9IGRsW2RzdF07XG4gICAgICAgICAgICBpZiAoZHN0ID4gMylcbiAgICAgICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgKHN5bSA+PiA1KSAmIDgxOTEpLCBwICs9IGZkZWJbZHN0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtzeW1dKSwgcCArPSBsbFtzeW1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdiaXRzMTYob3V0LCBwLCBsbVsyNTZdKTtcbiAgICByZXR1cm4gcCArIGxsWzI1Nl07XG59O1xuLy8gZGVmbGF0ZSBvcHRpb25zIChuaWNlIDw8IDEzKSB8IGNoYWluXG52YXIgZGVvID0gLyojX19QVVJFX18qLyBuZXcgaTMyKFs2NTU0MCwgMTMxMDgwLCAxMzEwODgsIDEzMTEwNCwgMjYyMTc2LCAxMDQ4NzA0LCAxMDQ4ODMyLCAyMTE0NTYwLCAyMTE3NjMyXSk7XG4vLyBlbXB0eVxudmFyIGV0ID0gLyojX19QVVJFX18qLyBuZXcgdTgoMCk7XG4vLyBjb21wcmVzc2VzIGRhdGEgaW50byBhIHJhdyBERUZMQVRFIGJ1ZmZlclxudmFyIGRmbHQgPSBmdW5jdGlvbiAoZGF0LCBsdmwsIHBsdmwsIHByZSwgcG9zdCwgc3QpIHtcbiAgICB2YXIgcyA9IHN0LnogfHwgZGF0Lmxlbmd0aDtcbiAgICB2YXIgbyA9IG5ldyB1OChwcmUgKyBzICsgNSAqICgxICsgTWF0aC5jZWlsKHMgLyA3MDAwKSkgKyBwb3N0KTtcbiAgICAvLyB3cml0aW5nIHRvIHRoaXMgd3JpdGVzIHRvIHRoZSBvdXRwdXQgYnVmZmVyXG4gICAgdmFyIHcgPSBvLnN1YmFycmF5KHByZSwgby5sZW5ndGggLSBwb3N0KTtcbiAgICB2YXIgbHN0ID0gc3QubDtcbiAgICB2YXIgcG9zID0gKHN0LnIgfHwgMCkgJiA3O1xuICAgIGlmIChsdmwpIHtcbiAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgIHdbMF0gPSBzdC5yID4+IDM7XG4gICAgICAgIHZhciBvcHQgPSBkZW9bbHZsIC0gMV07XG4gICAgICAgIHZhciBuID0gb3B0ID4+IDEzLCBjID0gb3B0ICYgODE5MTtcbiAgICAgICAgdmFyIG1za18xID0gKDEgPDwgcGx2bCkgLSAxO1xuICAgICAgICAvLyAgICBwcmV2IDItYnl0ZSB2YWwgbWFwICAgIGN1cnIgMi1ieXRlIHZhbCBtYXBcbiAgICAgICAgdmFyIHByZXYgPSBzdC5wIHx8IG5ldyB1MTYoMzI3NjgpLCBoZWFkID0gc3QuaCB8fCBuZXcgdTE2KG1za18xICsgMSk7XG4gICAgICAgIHZhciBiczFfMSA9IE1hdGguY2VpbChwbHZsIC8gMyksIGJzMl8xID0gMiAqIGJzMV8xO1xuICAgICAgICB2YXIgaHNoID0gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIChkYXRbaV0gXiAoZGF0W2kgKyAxXSA8PCBiczFfMSkgXiAoZGF0W2kgKyAyXSA8PCBiczJfMSkpICYgbXNrXzE7IH07XG4gICAgICAgIC8vIDI0NTc2IGlzIGFuIGFyYml0cmFyeSBudW1iZXIgb2YgbWF4aW11bSBzeW1ib2xzIHBlciBibG9ja1xuICAgICAgICAvLyA0MjQgYnVmZmVyIGZvciBsYXN0IGJsb2NrXG4gICAgICAgIHZhciBzeW1zID0gbmV3IGkzMigyNTAwMCk7XG4gICAgICAgIC8vIGxlbmd0aC9saXRlcmFsIGZyZXEgICBkaXN0YW5jZSBmcmVxXG4gICAgICAgIHZhciBsZiA9IG5ldyB1MTYoMjg4KSwgZGYgPSBuZXcgdTE2KDMyKTtcbiAgICAgICAgLy8gIGwvbGNudCAgZXhiaXRzICBpbmRleCAgICAgICAgICBsL2xpbmQgIHdhaXRkeCAgICAgICAgICBibGtwb3NcbiAgICAgICAgdmFyIGxjXzEgPSAwLCBlYiA9IDAsIGkgPSBzdC5pIHx8IDAsIGxpID0gMCwgd2kgPSBzdC53IHx8IDAsIGJzID0gMDtcbiAgICAgICAgZm9yICg7IGkgKyAyIDwgczsgKytpKSB7XG4gICAgICAgICAgICAvLyBoYXNoIHZhbHVlXG4gICAgICAgICAgICB2YXIgaHYgPSBoc2goaSk7XG4gICAgICAgICAgICAvLyBpbmRleCBtb2QgMzI3NjggICAgcHJldmlvdXMgaW5kZXggbW9kXG4gICAgICAgICAgICB2YXIgaW1vZCA9IGkgJiAzMjc2NywgcGltb2QgPSBoZWFkW2h2XTtcbiAgICAgICAgICAgIHByZXZbaW1vZF0gPSBwaW1vZDtcbiAgICAgICAgICAgIGhlYWRbaHZdID0gaW1vZDtcbiAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzaG91bGQgbW9kaWZ5IGhlYWQgYW5kIHByZXYsIGJ1dCBvbmx5IGFkZCBzeW1ib2xzIGlmXG4gICAgICAgICAgICAvLyB0aGlzIGRhdGEgaXMgbm90IHlldCBwcm9jZXNzZWQgKFwid2FpdFwiIGZvciB3YWl0IGluZGV4KVxuICAgICAgICAgICAgaWYgKHdpIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAvLyBieXRlcyByZW1haW5pbmdcbiAgICAgICAgICAgICAgICB2YXIgcmVtID0gcyAtIGk7XG4gICAgICAgICAgICAgICAgaWYgKChsY18xID4gNzAwMCB8fCBsaSA+IDI0NTc2KSAmJiAocmVtID4gNDIzIHx8ICFsc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHdibGsoZGF0LCB3LCAwLCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGkgLSBicywgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgbGkgPSBsY18xID0gZWIgPSAwLCBicyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMjg2OyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBsZltqXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzA7ICsrailcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gIGxlbiAgICBkaXN0ICAgY2hhaW5cbiAgICAgICAgICAgICAgICB2YXIgbCA9IDIsIGQgPSAwLCBjaF8xID0gYywgZGlmID0gaW1vZCAtIHBpbW9kICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgaWYgKHJlbSA+IDIgJiYgaHYgPT0gaHNoKGkgLSBkaWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhuID0gTWF0aC5taW4obiwgcmVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhkID0gTWF0aC5taW4oMzI3NjcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXggcG9zc2libGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjYXBwZWQgYXQgZGlmIGJlY2F1c2UgZGVjb21wcmVzc29ycyBpbXBsZW1lbnQgXCJyb2xsaW5nXCIgaW5kZXggcG9wdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWwgPSBNYXRoLm1pbigyNTgsIHJlbSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkaWYgPD0gbWF4ZCAmJiAtLWNoXzEgJiYgaW1vZCAhPSBwaW1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdFtpICsgbF0gPT0gZGF0W2kgKyBsIC0gZGlmXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IG5sIDwgbWwgJiYgZGF0W2kgKyBubF0gPT0gZGF0W2kgKyBubCAtIGRpZl07ICsrbmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBubCwgZCA9IGRpZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IGVhcmx5IHdoZW4gd2UgcmVhY2ggXCJuaWNlXCIgKHdlIGFyZSBzYXRpc2ZpZWQgZW5vdWdoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBtYXhuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdywgZmluZCB0aGUgcmFyZXN0IDItYnl0ZSBzZXF1ZW5jZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggb2YgbGl0ZXJhbHMgYW5kIHNlYXJjaCBmb3IgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWNoIGZhc3RlciB0aGFuIGp1c3QgdXNpbmcgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtbWQgPSBNYXRoLm1pbihkaWYsIG5sIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW1kOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aSA9IGkgLSBkaWYgKyBqICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHRpID0gcHJldlt0aV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2QgPSB0aSAtIHB0aSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNkID4gbWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWQgPSBjZCwgcGltb2QgPSB0aTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBwcmV2aW91cyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1vZCA9IHBpbW9kLCBwaW1vZCA9IHByZXZbaW1vZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWYgKz0gaW1vZCAtIHBpbW9kICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZCB3aWxsIGJlIG5vbnplcm8gb25seSB3aGVuIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYm90aCBkaXN0IGFuZCBsZW4gZGF0YSBpbiBvbmUgaW50MzJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgaXMgcmVjb2duaXplZCBhcyBhIGxlbi9kaXN0IHdpdGggMjh0aCBiaXQgKDJeMjgpXG4gICAgICAgICAgICAgICAgICAgIHN5bXNbbGkrK10gPSAyNjg0MzU0NTYgfCAocmV2ZmxbbF0gPDwgMTgpIHwgcmV2ZmRbZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW4gPSByZXZmbFtsXSAmIDMxLCBkaW4gPSByZXZmZFtkXSAmIDMxO1xuICAgICAgICAgICAgICAgICAgICBlYiArPSBmbGViW2xpbl0gKyBmZGViW2Rpbl07XG4gICAgICAgICAgICAgICAgICAgICsrbGZbMjU3ICsgbGluXTtcbiAgICAgICAgICAgICAgICAgICAgKytkZltkaW5dO1xuICAgICAgICAgICAgICAgICAgICB3aSA9IGkgKyBsO1xuICAgICAgICAgICAgICAgICAgICArK2xjXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzeW1zW2xpKytdID0gZGF0W2ldO1xuICAgICAgICAgICAgICAgICAgICArK2xmW2RhdFtpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IE1hdGgubWF4KGksIHdpKTsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgc3ltc1tsaSsrXSA9IGRhdFtpXTtcbiAgICAgICAgICAgICsrbGZbZGF0W2ldXTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgbHN0LCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGkgLSBicywgcG9zKTtcbiAgICAgICAgaWYgKCFsc3QpIHtcbiAgICAgICAgICAgIHN0LnIgPSAocG9zICYgNykgfCB3Wyhwb3MgLyA4KSB8IDBdIDw8IDM7XG4gICAgICAgICAgICAvLyBzaGZ0KHBvcykgbm93IDEgbGVzcyBpZiBwb3MgJiA3ICE9IDBcbiAgICAgICAgICAgIHBvcyAtPSA3O1xuICAgICAgICAgICAgc3QuaCA9IGhlYWQsIHN0LnAgPSBwcmV2LCBzdC5pID0gaSwgc3QudyA9IHdpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gc3QudyB8fCAwOyBpIDwgcyArIGxzdDsgaSArPSA2NTUzNSkge1xuICAgICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgICB2YXIgZSA9IGkgKyA2NTUzNTtcbiAgICAgICAgICAgIGlmIChlID49IHMpIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmaW5hbCBibG9ja1xuICAgICAgICAgICAgICAgIHdbKHBvcyAvIDgpIHwgMF0gPSBsc3Q7XG4gICAgICAgICAgICAgICAgZSA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MgKyAxLCBkYXQuc3ViYXJyYXkoaSwgZSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0LmkgPSBzO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKG8sIDAsIHByZSArIHNoZnQocG9zKSArIHBvc3QpO1xufTtcbi8vIENSQzMyIHRhYmxlXG52YXIgY3JjdCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICB2YXIgYyA9IGksIGsgPSA5O1xuICAgICAgICB3aGlsZSAoLS1rKVxuICAgICAgICAgICAgYyA9ICgoYyAmIDEpICYmIC0zMDY2NzQ5MTIpIF4gKGMgPj4+IDEpO1xuICAgICAgICB0W2ldID0gYztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59KSgpO1xuLy8gQ1JDMzJcbnZhciBjcmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGMgPSAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIGNyID0gYztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjciA9IGNyY3RbKGNyICYgMjU1KSBeIGRbaV1dIF4gKGNyID4+PiA4KTtcbiAgICAgICAgICAgIGMgPSBjcjtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gfmM7IH1cbiAgICB9O1xufTtcbi8vIEFkbGVyMzJcbnZhciBhZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IDEsIGIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgbiA9IGEsIG0gPSBiO1xuICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aCB8IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPSBsOykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gTWF0aC5taW4oaSArIDI2NTUsIGwpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZTsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtICs9IG4gKz0gZFtpXTtcbiAgICAgICAgICAgICAgICBuID0gKG4gJiA2NTUzNSkgKyAxNSAqIChuID4+IDE2KSwgbSA9IChtICYgNjU1MzUpICsgMTUgKiAobSA+PiAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gbiwgYiA9IG07XG4gICAgICAgIH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEgJT0gNjU1MjEsIGIgJT0gNjU1MjE7XG4gICAgICAgICAgICByZXR1cm4gKGEgJiAyNTUpIDw8IDI0IHwgKGEgJiAweEZGMDApIDw8IDggfCAoYiAmIDI1NSkgPDwgOCB8IChiID4+IDgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG47XG4vLyBkZWZsYXRlIHdpdGggb3B0c1xudmFyIGRvcHQgPSBmdW5jdGlvbiAoZGF0LCBvcHQsIHByZSwgcG9zdCwgc3QpIHtcbiAgICBpZiAoIXN0KSB7XG4gICAgICAgIHN0ID0geyBsOiAxIH07XG4gICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgICAgICAgICAgdmFyIGRpY3QgPSBvcHQuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpO1xuICAgICAgICAgICAgdmFyIG5ld0RhdCA9IG5ldyB1OChkaWN0Lmxlbmd0aCArIGRhdC5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3RGF0LnNldChkaWN0KTtcbiAgICAgICAgICAgIG5ld0RhdC5zZXQoZGF0LCBkaWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBkYXQgPSBuZXdEYXQ7XG4gICAgICAgICAgICBzdC53ID0gZGljdC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRmbHQoZGF0LCBvcHQubGV2ZWwgPT0gbnVsbCA/IDYgOiBvcHQubGV2ZWwsIG9wdC5tZW0gPT0gbnVsbCA/IChzdC5sID8gTWF0aC5jZWlsKE1hdGgubWF4KDgsIE1hdGgubWluKDEzLCBNYXRoLmxvZyhkYXQubGVuZ3RoKSkpICogMS41KSA6IDIwKSA6ICgxMiArIG9wdC5tZW0pLCBwcmUsIHBvc3QsIHN0KTtcbn07XG4vLyBXYWxtYXJ0IG9iamVjdCBzcHJlYWRcbnZhciBtcmcgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBvID0ge307XG4gICAgZm9yICh2YXIgayBpbiBhKVxuICAgICAgICBvW2tdID0gYVtrXTtcbiAgICBmb3IgKHZhciBrIGluIGIpXG4gICAgICAgIG9ba10gPSBiW2tdO1xuICAgIHJldHVybiBvO1xufTtcbi8vIHdvcmtlciBjbG9uZVxuLy8gVGhpcyBpcyBwb3NzaWJseSB0aGUgY3Jhemllc3QgcGFydCBvZiB0aGUgZW50aXJlIGNvZGViYXNlLCBkZXNwaXRlIGhvdyBzaW1wbGUgaXQgbWF5IHNlZW0uXG4vLyBUaGUgb25seSBwYXJhbWV0ZXIgdG8gdGhpcyBmdW5jdGlvbiBpcyBhIGNsb3N1cmUgdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIHZhcmlhYmxlcyBvdXRzaWRlIG9mIHRoZSBmdW5jdGlvbiBzY29wZS5cbi8vIFdlJ3JlIGdvaW5nIHRvIHRyeSB0byBmaWd1cmUgb3V0IHRoZSB2YXJpYWJsZSBuYW1lcyB1c2VkIGluIHRoZSBjbG9zdXJlIGFzIHN0cmluZ3MgYmVjYXVzZSB0aGF0IGlzIGNydWNpYWwgZm9yIHdvcmtlcml6YXRpb24uXG4vLyBXZSB3aWxsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBvZiB0cnVlIHZhcmlhYmxlIG5hbWUgdG8gdmFsdWUgKGJhc2ljYWxseSwgdGhlIGN1cnJlbnQgc2NvcGUgYXMgYSBKUyBvYmplY3QpLlxuLy8gVGhlIHJlYXNvbiB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgb3JpZ2luYWwgdmFyaWFibGUgbmFtZXMgaXMgbWluaWZpZXJzIG1hbmdsaW5nIHRoZSB0b3BsZXZlbCBzY29wZS5cbi8vIFRoaXMgdG9vayBtZSB0aHJlZSB3ZWVrcyB0byBmaWd1cmUgb3V0IGhvdyB0byBkby5cbnZhciB3Y2xuID0gZnVuY3Rpb24gKGZuLCBmblN0ciwgdGQpIHtcbiAgICB2YXIgZHQgPSBmbigpO1xuICAgIHZhciBzdCA9IGZuLnRvU3RyaW5nKCk7XG4gICAgdmFyIGtzID0gc3Quc2xpY2Uoc3QuaW5kZXhPZignWycpICsgMSwgc3QubGFzdEluZGV4T2YoJ10nKSkucmVwbGFjZSgvXFxzKy9nLCAnJykuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2ID0gZHRbaV0sIGsgPSBrc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZuU3RyICs9ICc7JyArIGsgKyAnPSc7XG4gICAgICAgICAgICB2YXIgc3RfMSA9IHYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh2LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBnbG9iYWwgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmIChzdF8xLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BJbmQgPSBzdF8xLmluZGV4T2YoJyAnLCA4KSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzEuc2xpY2Uoc3BJbmQsIHN0XzEuaW5kZXhPZignKCcsIHNwSW5kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHYucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICcucHJvdG90eXBlLicgKyB0ICsgJz0nICsgdi5wcm90b3R5cGVbdF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZFtrXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBmblN0cjtcbn07XG52YXIgY2ggPSBbXTtcbi8vIGNsb25lIGJ1ZnNcbnZhciBjYmZzID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgdGwgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIHYpIHtcbiAgICAgICAgaWYgKHZba10uYnVmZmVyKSB7XG4gICAgICAgICAgICB0bC5wdXNoKCh2W2tdID0gbmV3IHZba10uY29uc3RydWN0b3IodltrXSkpLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRsO1xufTtcbi8vIHVzZSBhIHdvcmtlciB0byBleGVjdXRlIGNvZGVcbnZhciB3cmtyID0gZnVuY3Rpb24gKGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgaWYgKCFjaFtpZF0pIHtcbiAgICAgICAgdmFyIGZuU3RyID0gJycsIHRkXzEgPSB7fSwgbSA9IGZucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07ICsraSlcbiAgICAgICAgICAgIGZuU3RyID0gd2NsbihmbnNbaV0sIGZuU3RyLCB0ZF8xKTtcbiAgICAgICAgY2hbaWRdID0geyBjOiB3Y2xuKGZuc1ttXSwgZm5TdHIsIHRkXzEpLCBlOiB0ZF8xIH07XG4gICAgfVxuICAgIHZhciB0ZCA9IG1yZyh7fSwgY2hbaWRdLmUpO1xuICAgIHJldHVybiAoMCwgbm9kZV93b3JrZXJfMS5kZWZhdWx0KShjaFtpZF0uYyArICc7b25tZXNzYWdlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgayBpbiBlLmRhdGEpc2VsZltrXT1lLmRhdGFba107b25tZXNzYWdlPScgKyBpbml0LnRvU3RyaW5nKCkgKyAnfScsIGlkLCB0ZCwgY2Jmcyh0ZCksIGNiKTtcbn07XG4vLyBiYXNlIGFzeW5jIGluZmxhdGUgZm5cbnZhciBiSW5mbHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbdTgsIHUxNiwgaTMyLCBmbGViLCBmZGViLCBjbGltLCBmbCwgZmQsIGZscm0sIGZkcm0sIHJldiwgZWMsIGhNYXAsIG1heCwgYml0cywgYml0czE2LCBzaGZ0LCBzbGMsIGVyciwgaW5mbHQsIGluZmxhdGVTeW5jLCBwYmYsIGdvcHRdOyB9O1xudmFyIGJEZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIGkzMiwgZmxlYiwgZmRlYiwgY2xpbSwgcmV2ZmwsIHJldmZkLCBmbG0sIGZsdCwgZmRtLCBmZHQsIHJldiwgZGVvLCBldCwgaE1hcCwgd2JpdHMsIHdiaXRzMTYsIGhUcmVlLCBsbiwgbGMsIGNsZW4sIHdmYmxrLCB3YmxrLCBzaGZ0LCBzbGMsIGRmbHQsIGRvcHQsIGRlZmxhdGVTeW5jLCBwYmZdOyB9O1xuLy8gZ3ppcCBleHRyYVxudmFyIGd6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemgsIGd6aGwsIHdieXRlcywgY3JjLCBjcmN0XTsgfTtcbi8vIGd1bnppcCBleHRyYVxudmFyIGd1emUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3pzLCBnemxdOyB9O1xuLy8gemxpYiBleHRyYVxudmFyIHpsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGgsIHdieXRlcywgYWRsZXJdOyB9O1xuLy8gdW56bGliIGV4dHJhXG52YXIgenVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bHNdOyB9O1xuLy8gcG9zdCBidWZcbnZhciBwYmYgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBwb3N0TWVzc2FnZShtc2csIFttc2cuYnVmZmVyXSk7IH07XG4vLyBnZXQgb3B0c1xudmFyIGdvcHQgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiB7XG4gICAgb3V0OiBvLnNpemUgJiYgbmV3IHU4KG8uc2l6ZSksXG4gICAgZGljdGlvbmFyeTogby5kaWN0aW9uYXJ5XG59OyB9O1xuLy8gYXN5bmMgaGVscGVyXG52YXIgY2JpZnkgPSBmdW5jdGlvbiAoZGF0LCBvcHRzLCBmbnMsIGluaXQsIGlkLCBjYikge1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgICAgY2IoZXJyLCBkYXQpO1xuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2UoW2RhdCwgb3B0c10sIG9wdHMuY29uc3VtZSA/IFtkYXQuYnVmZmVyXSA6IFtdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIGF1dG8gc3RyZWFtXG52YXIgYXN0cm0gPSBmdW5jdGlvbiAoc3RybSkge1xuICAgIHN0cm0ub25kYXRhID0gZnVuY3Rpb24gKGRhdCwgZmluYWwpIHsgcmV0dXJuIHBvc3RNZXNzYWdlKFtkYXQsIGZpbmFsXSwgW2RhdC5idWZmZXJdKTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RybS5wdXNoKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pO1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2UoW2V2LmRhdGFbMF0ubGVuZ3RoXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RybS5mbHVzaCgpO1xuICAgIH07XG59O1xuLy8gYXN5bmMgc3RyZWFtIGF0dGFjaFxudmFyIGFzdHJtaWZ5ID0gZnVuY3Rpb24gKGZucywgc3RybSwgb3B0cywgaW5pdCwgaWQsIGZsdXNoLCBleHQpIHtcbiAgICB2YXIgdDtcbiAgICB2YXIgdyA9IHdya3IoZm5zLCBpbml0LCBpZCwgZnVuY3Rpb24gKGVyciwgZGF0KSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICB3LnRlcm1pbmF0ZSgpLCBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVycik7XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGRhdCkpXG4gICAgICAgICAgICBleHQoZGF0KTtcbiAgICAgICAgZWxzZSBpZiAoZGF0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBzdHJtLnF1ZXVlZFNpemUgLT0gZGF0WzBdO1xuICAgICAgICAgICAgaWYgKHN0cm0ub25kcmFpbilcbiAgICAgICAgICAgICAgICBzdHJtLm9uZHJhaW4oZGF0WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRbMV0pXG4gICAgICAgICAgICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyLCBkYXRbMF0sIGRhdFsxXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3LnBvc3RNZXNzYWdlKG9wdHMpO1xuICAgIHN0cm0ucXVldWVkU2l6ZSA9IDA7XG4gICAgc3RybS5wdXNoID0gZnVuY3Rpb24gKGQsIGYpIHtcbiAgICAgICAgaWYgKCFzdHJtLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKHQpXG4gICAgICAgICAgICBzdHJtLm9uZGF0YShlcnIoNCwgMCwgMSksIG51bGwsICEhZik7XG4gICAgICAgIHN0cm0ucXVldWVkU2l6ZSArPSBkLmxlbmd0aDtcbiAgICAgICAgdy5wb3N0TWVzc2FnZShbZCwgdCA9IGZdLCBbZC5idWZmZXJdKTtcbiAgICB9O1xuICAgIHN0cm0udGVybWluYXRlID0gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xuICAgIGlmIChmbHVzaCkge1xuICAgICAgICBzdHJtLmZsdXNoID0gZnVuY3Rpb24gKCkgeyB3LnBvc3RNZXNzYWdlKFtdKTsgfTtcbiAgICB9XG59O1xuLy8gcmVhZCAyIGJ5dGVzXG52YXIgYjIgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gZFtiXSB8IChkW2IgKyAxXSA8PCA4KTsgfTtcbi8vIHJlYWQgNCBieXRlc1xudmFyIGI0ID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIChkW2JdIHwgKGRbYiArIDFdIDw8IDgpIHwgKGRbYiArIDJdIDw8IDE2KSB8IChkW2IgKyAzXSA8PCAyNCkpID4+PiAwOyB9O1xudmFyIGI4ID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGI0KGQsIGIpICsgKGI0KGQsIGIgKyA0KSAqIDQyOTQ5NjcyOTYpOyB9O1xuLy8gd3JpdGUgYnl0ZXNcbnZhciB3Ynl0ZXMgPSBmdW5jdGlvbiAoZCwgYiwgdikge1xuICAgIGZvciAoOyB2OyArK2IpXG4gICAgICAgIGRbYl0gPSB2LCB2ID4+Pj0gODtcbn07XG4vLyBnemlwIGhlYWRlclxudmFyIGd6aCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgdmFyIGZuID0gby5maWxlbmFtZTtcbiAgICBjWzBdID0gMzEsIGNbMV0gPSAxMzksIGNbMl0gPSA4LCBjWzhdID0gby5sZXZlbCA8IDIgPyA0IDogby5sZXZlbCA9PSA5ID8gMiA6IDAsIGNbOV0gPSAzOyAvLyBhc3N1bWUgVW5peFxuICAgIGlmIChvLm10aW1lICE9IDApXG4gICAgICAgIHdieXRlcyhjLCA0LCBNYXRoLmZsb29yKG5ldyBEYXRlKG8ubXRpbWUgfHwgRGF0ZS5ub3coKSkgLyAxMDAwKSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICAgIGNbM10gPSA4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBmbi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGNbaSArIDEwXSA9IGZuLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxufTtcbi8vIGd6aXAgZm9vdGVyOiAtOCB0byAtNCA9IENSQywgLTQgdG8gLTAgaXMgbGVuZ3RoXG4vLyBnemlwIHN0YXJ0XG52YXIgZ3pzID0gZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZFswXSAhPSAzMSB8fCBkWzFdICE9IDEzOSB8fCBkWzJdICE9IDgpXG4gICAgICAgIGVycig2LCAnaW52YWxpZCBnemlwIGRhdGEnKTtcbiAgICB2YXIgZmxnID0gZFszXTtcbiAgICB2YXIgc3QgPSAxMDtcbiAgICBpZiAoZmxnICYgNClcbiAgICAgICAgc3QgKz0gKGRbMTBdIHwgZFsxMV0gPDwgOCkgKyAyO1xuICAgIGZvciAodmFyIHpzID0gKGZsZyA+PiAzICYgMSkgKyAoZmxnID4+IDQgJiAxKTsgenMgPiAwOyB6cyAtPSAhZFtzdCsrXSlcbiAgICAgICAgO1xuICAgIHJldHVybiBzdCArIChmbGcgJiAyKTtcbn07XG4vLyBnemlwIGxlbmd0aFxudmFyIGd6bCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICByZXR1cm4gKGRbbCAtIDRdIHwgZFtsIC0gM10gPDwgOCB8IGRbbCAtIDJdIDw8IDE2IHwgZFtsIC0gMV0gPDwgMjQpID4+PiAwO1xufTtcbi8vIGd6aXAgaGVhZGVyIGxlbmd0aFxudmFyIGd6aGwgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gMTAgKyAoby5maWxlbmFtZSA/IG8uZmlsZW5hbWUubGVuZ3RoICsgMSA6IDApOyB9O1xuLy8gemxpYiBoZWFkZXJcbnZhciB6bGggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBsdiA9IG8ubGV2ZWwsIGZsID0gbHYgPT0gMCA/IDAgOiBsdiA8IDYgPyAxIDogbHYgPT0gOSA/IDMgOiAyO1xuICAgIGNbMF0gPSAxMjAsIGNbMV0gPSAoZmwgPDwgNikgfCAoby5kaWN0aW9uYXJ5ICYmIDMyKTtcbiAgICBjWzFdIHw9IDMxIC0gKChjWzBdIDw8IDgpIHwgY1sxXSkgJSAzMTtcbiAgICBpZiAoby5kaWN0aW9uYXJ5KSB7XG4gICAgICAgIHZhciBoID0gYWRsZXIoKTtcbiAgICAgICAgaC5wKG8uZGljdGlvbmFyeSk7XG4gICAgICAgIHdieXRlcyhjLCAyLCBoLmQoKSk7XG4gICAgfVxufTtcbi8vIHpsaWIgc3RhcnRcbnZhciB6bHMgPSBmdW5jdGlvbiAoZCwgZGljdCkge1xuICAgIGlmICgoZFswXSAmIDE1KSAhPSA4IHx8IChkWzBdID4+IDQpID4gNyB8fCAoKGRbMF0gPDwgOCB8IGRbMV0pICUgMzEpKVxuICAgICAgICBlcnIoNiwgJ2ludmFsaWQgemxpYiBkYXRhJyk7XG4gICAgaWYgKChkWzFdID4+IDUgJiAxKSA9PSArIWRpY3QpXG4gICAgICAgIGVycig2LCAnaW52YWxpZCB6bGliIGRhdGE6ICcgKyAoZFsxXSAmIDMyID8gJ25lZWQnIDogJ3VuZXhwZWN0ZWQnKSArICcgZGljdGlvbmFyeScpO1xuICAgIHJldHVybiAoZFsxXSA+PiAzICYgNCkgKyAyO1xufTtcbmZ1bmN0aW9uIFN0cm1PcHQob3B0cywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICByZXR1cm4gb3B0cztcbn1cbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb25cbiAqL1xudmFyIERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLm8gPSBvcHRzIHx8IHt9O1xuICAgICAgICB0aGlzLnMgPSB7IGw6IDAsIGk6IDMyNzY4LCB3OiAzMjc2OCwgejogMzI3NjggfTtcbiAgICAgICAgLy8gQnVmZmVyIGxlbmd0aCBtdXN0IGFsd2F5cyBiZSAwIG1vZCAzMjc2OCBmb3IgaW5kZXggY2FsY3VsYXRpb25zIHRvIGJlIGNvcnJlY3Qgd2hlbiBtb2RpZnlpbmcgaGVhZCBhbmQgcHJldlxuICAgICAgICAvLyA5ODMwNCA9IDMyNzY4IChsb29rYmFjaykgKyA2NTUzNiAoY29tbW9uIGNodW5rIHNpemUpXG4gICAgICAgIHRoaXMuYiA9IG5ldyB1OCg5ODMwNCk7XG4gICAgICAgIGlmICh0aGlzLm8uZGljdGlvbmFyeSkge1xuICAgICAgICAgICAgdmFyIGRpY3QgPSB0aGlzLm8uZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpO1xuICAgICAgICAgICAgdGhpcy5iLnNldChkaWN0LCAzMjc2OCAtIGRpY3QubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucy5pID0gMzI3NjggLSBkaWN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEoZG9wdChjLCB0aGlzLm8sIDAsIDAsIHRoaXMucyksIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKHRoaXMucy5sKVxuICAgICAgICAgICAgZXJyKDQpO1xuICAgICAgICB2YXIgZW5kTGVuID0gY2h1bmsubGVuZ3RoICsgdGhpcy5zLno7XG4gICAgICAgIGlmIChlbmRMZW4gPiB0aGlzLmIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZW5kTGVuID4gMiAqIHRoaXMuYi5sZW5ndGggLSAzMjc2OCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdCdWYgPSBuZXcgdTgoZW5kTGVuICYgLTMyNzY4KTtcbiAgICAgICAgICAgICAgICBuZXdCdWYuc2V0KHRoaXMuYi5zdWJhcnJheSgwLCB0aGlzLnMueikpO1xuICAgICAgICAgICAgICAgIHRoaXMuYiA9IG5ld0J1ZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHRoaXMuYi5sZW5ndGggLSB0aGlzLnMuejtcbiAgICAgICAgICAgIHRoaXMuYi5zZXQoY2h1bmsuc3ViYXJyYXkoMCwgc3BsaXQpLCB0aGlzLnMueik7XG4gICAgICAgICAgICB0aGlzLnMueiA9IHRoaXMuYi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnAodGhpcy5iLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmIuc2V0KHRoaXMuYi5zdWJhcnJheSgtMzI3NjgpKTtcbiAgICAgICAgICAgIHRoaXMuYi5zZXQoY2h1bmsuc3ViYXJyYXkoc3BsaXQpLCAzMjc2OCk7XG4gICAgICAgICAgICB0aGlzLnMueiA9IGNodW5rLmxlbmd0aCAtIHNwbGl0ICsgMzI3Njg7XG4gICAgICAgICAgICB0aGlzLnMuaSA9IDMyNzY2LCB0aGlzLnMudyA9IDMyNzY4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iLnNldChjaHVuaywgdGhpcy5zLnopO1xuICAgICAgICAgICAgdGhpcy5zLnogKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucy5sID0gZmluYWwgJiAxO1xuICAgICAgICBpZiAodGhpcy5zLnogPiB0aGlzLnMudyArIDgxOTEgfHwgZmluYWwpIHtcbiAgICAgICAgICAgIHRoaXMucCh0aGlzLmIsIGZpbmFsIHx8IGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucy53ID0gdGhpcy5zLmksIHRoaXMucy5pIC09IDI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYnVmZmVyZWQgdW5jb21wcmVzc2VkIGRhdGEuIFVzZWZ1bCB0byBpbW1lZGlhdGVseSByZXRyaWV2ZSB0aGVcbiAgICAgKiBkZWZsYXRlZCBvdXRwdXQgZm9yIHNtYWxsIGlucHV0cy5cbiAgICAgKi9cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKHRoaXMucy5sKVxuICAgICAgICAgICAgZXJyKDQpO1xuICAgICAgICB0aGlzLnAodGhpcy5iLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucy53ID0gdGhpcy5zLmksIHRoaXMucy5pIC09IDI7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0RlZmxhdGUob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGVdOyB9XG4gICAgICAgIF0sIHRoaXMsIFN0cm1PcHQuY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgRGVmbGF0ZShldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA2LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnRzLkFzeW5jRGVmbGF0ZSA9IEFzeW5jRGVmbGF0ZTtcbmZ1bmN0aW9uIGRlZmxhdGUoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihkZWZsYXRlU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDAsIGNiKTtcbn1cbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIERFRkxBVEUgd2l0aG91dCBhbnkgd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVmbGF0ZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5mdW5jdGlvbiBkZWZsYXRlU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGRvcHQoZGF0YSwgb3B0cyB8fCB7fSwgMCwgMCk7XG59XG5leHBvcnRzLmRlZmxhdGVTeW5jID0gZGVmbGF0ZVN5bmM7XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5mbGF0ZShvcHRzLCBjYikge1xuICAgICAgICAvLyBubyBTdHJtT3B0IGhlcmUgdG8gYXZvaWQgYWRkaW5nIHRvIHdvcmtlcml6ZXJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgdmFyIGRpY3QgPSBvcHRzICYmIG9wdHMuZGljdGlvbmFyeSAmJiBvcHRzLmRpY3Rpb25hcnkuc3ViYXJyYXkoLTMyNzY4KTtcbiAgICAgICAgdGhpcy5zID0geyBpOiAwLCBiOiBkaWN0ID8gZGljdC5sZW5ndGggOiAwIH07XG4gICAgICAgIHRoaXMubyA9IG5ldyB1OCgzMjc2OCk7XG4gICAgICAgIHRoaXMucCA9IG5ldyB1OCgwKTtcbiAgICAgICAgaWYgKGRpY3QpXG4gICAgICAgICAgICB0aGlzLm8uc2V0KGRpY3QpO1xuICAgIH1cbiAgICBJbmZsYXRlLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgaWYgKCF0aGlzLnAubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5wID0gYztcbiAgICAgICAgZWxzZSBpZiAoYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjLmxlbmd0aCk7XG4gICAgICAgICAgICBuLnNldCh0aGlzLnApLCBuLnNldChjLCB0aGlzLnAubGVuZ3RoKSwgdGhpcy5wID0gbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChmaW5hbCkge1xuICAgICAgICB0aGlzLnMuaSA9ICsodGhpcy5kID0gZmluYWwgfHwgZmFsc2UpO1xuICAgICAgICB2YXIgYnRzID0gdGhpcy5zLmI7XG4gICAgICAgIHZhciBkdCA9IGluZmx0KHRoaXMucCwgdGhpcy5zLCB0aGlzLm8pO1xuICAgICAgICB0aGlzLm9uZGF0YShzbGMoZHQsIGJ0cywgdGhpcy5zLmIpLCB0aGlzLmQpO1xuICAgICAgICB0aGlzLm8gPSBzbGMoZHQsIHRoaXMucy5iIC0gMzI3NjgpLCB0aGlzLnMuYiA9IHRoaXMuby5sZW5ndGg7XG4gICAgICAgIHRoaXMucCA9IHNsYyh0aGlzLnAsICh0aGlzLnMucCAvIDgpIHwgMCksIHRoaXMucy5wICY9IDc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBpbmZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGZpbmFsIGNodW5rXG4gICAgICovXG4gICAgSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5lKGNodW5rKSwgdGhpcy5jKGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0luZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNJbmZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZV07IH1cbiAgICAgICAgXSwgdGhpcywgU3RybU9wdC5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBJbmZsYXRlKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDcsIDApO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNJbmZsYXRlO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNJbmZsYXRlID0gQXN5bmNJbmZsYXRlO1xuZnVuY3Rpb24gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdFxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGluZmxhdGVTeW5jKGV2LmRhdGFbMF0sIGdvcHQoZXYuZGF0YVsxXSkpKTsgfSwgMSwgY2IpO1xufVxuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbi8qKlxuICogRXhwYW5kcyBERUZMQVRFIGRhdGEgd2l0aCBubyB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgZGVjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZVN5bmMoZGF0YSwgb3B0cykge1xuICAgIHJldHVybiBpbmZsdChkYXRhLCB7IGk6IDIgfSwgb3B0cyAmJiBvcHRzLm91dCwgb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkpO1xufVxuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuLy8gYmVmb3JlIHlvdSB5ZWxsIGF0IG1lIGZvciBub3QganVzdCB1c2luZyBleHRlbmRzLCBteSByZWFzb24gaXMgdGhhdCBUUyBpbmhlcml0YW5jZSBpcyBoYXJkIHRvIHdvcmtlcml6ZS5cbi8qKlxuICogU3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEd6aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3ppcChvcHRzLCBjYikge1xuICAgICAgICB0aGlzLmMgPSBjcmMoKTtcbiAgICAgICAgdGhpcy5sID0gMDtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgR1pJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmMucChjaHVuayk7XG4gICAgICAgIHRoaXMubCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgR3ppcC5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIGd6aGwodGhpcy5vKSwgZiAmJiA4LCB0aGlzLnMpO1xuICAgICAgICBpZiAodGhpcy52KVxuICAgICAgICAgICAgZ3poKHJhdywgdGhpcy5vKSwgdGhpcy52ID0gMDtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gOCwgdGhpcy5jLmQoKSksIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmwpO1xuICAgICAgICB0aGlzLm9uZGF0YShyYXcsIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBidWZmZXJlZCB1bmNvbXByZXNzZWQgZGF0YS4gVXNlZnVsIHRvIGltbWVkaWF0ZWx5IHJldHJpZXZlIHRoZVxuICAgICAqIEdaSVBwZWQgb3V0cHV0IGZvciBzbWFsbCBpbnB1dHMuXG4gICAgICovXG4gICAgR3ppcC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gR3ppcDtcbn0oKSk7XG5leHBvcnRzLkd6aXAgPSBHemlwO1xuZXhwb3J0cy5Db21wcmVzcyA9IEd6aXA7XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jR3ppcChvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGd6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgR3ppcF07IH1cbiAgICAgICAgXSwgdGhpcywgU3RybU9wdC5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBHemlwKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHemlwO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNHemlwID0gQXN5bmNHemlwO1xuZXhwb3J0cy5Bc3luY0NvbXByZXNzID0gQXN5bmNHemlwO1xuZnVuY3Rpb24gZ3ppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgICAgICBnemUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemlwU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihnemlwU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDIsIGNiKTtcbn1cbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG5leHBvcnRzLmNvbXByZXNzID0gZ3ppcDtcbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggR1pJUFxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZ3ppcHBlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGd6aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYyA9IGNyYygpLCBsID0gZGF0YS5sZW5ndGg7XG4gICAgYy5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCBnemhsKG9wdHMpLCA4KSwgcyA9IGQubGVuZ3RoO1xuICAgIHJldHVybiBnemgoZCwgb3B0cyksIHdieXRlcyhkLCBzIC0gOCwgYy5kKCkpLCB3Ynl0ZXMoZCwgcyAtIDQsIGwpLCBkO1xufVxuZXhwb3J0cy5nemlwU3luYyA9IGd6aXBTeW5jO1xuZXhwb3J0cy5jb21wcmVzc1N5bmMgPSBnemlwU3luYztcbi8qKlxuICogU3RyZWFtaW5nIHNpbmdsZSBvciBtdWx0aS1tZW1iZXIgR1pJUCBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3VuemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIHRoaXMuciA9IDA7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdVTlpJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHdW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIHRoaXMuciArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wLnN1YmFycmF5KHRoaXMudiAtIDEpO1xuICAgICAgICAgICAgdmFyIHMgPSBwLmxlbmd0aCA+IDMgPyBnenMocCkgOiA0O1xuICAgICAgICAgICAgaWYgKHMgPiBwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghZmluYWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudiA+IDEgJiYgdGhpcy5vbm1lbWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMub25tZW1iZXIodGhpcy5yIC0gcC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wID0gcC5zdWJhcnJheShzKSwgdGhpcy52ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgICAgICAvLyBwcm9jZXNzIGNvbmNhdGVuYXRlZCBHWklQXG4gICAgICAgIGlmICh0aGlzLnMuZiAmJiAhdGhpcy5zLmwgJiYgIWZpbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSBzaGZ0KHRoaXMucy5wKSArIDk7XG4gICAgICAgICAgICB0aGlzLnMgPSB7IGk6IDAgfTtcbiAgICAgICAgICAgIHRoaXMubyA9IG5ldyB1OCgwKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChuZXcgdTgoMCksIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEd1bnppcDtcbn0oKSk7XG5leHBvcnRzLkd1bnppcCA9IEd1bnppcDtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBzaW5nbGUgb3IgbXVsdGktbWVtYmVyIEdaSVAgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNHdW56aXAob3B0cywgY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZ3V6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZSwgR3VuemlwXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd1bnppcChldi5kYXRhKTtcbiAgICAgICAgICAgIHN0cm0ub25tZW1iZXIgPSBmdW5jdGlvbiAob2Zmc2V0KSB7IHJldHVybiBwb3N0TWVzc2FnZShvZmZzZXQpOyB9O1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDksIDAsIGZ1bmN0aW9uIChvZmZzZXQpIHsgcmV0dXJuIF90aGlzLm9ubWVtYmVyICYmIF90aGlzLm9ubWVtYmVyKG9mZnNldCk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHdW56aXA7XG59KCkpO1xuZXhwb3J0cy5Bc3luY0d1bnppcCA9IEFzeW5jR3VuemlwO1xuZnVuY3Rpb24gZ3VuemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICBndXplLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3VuemlwU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihndW56aXBTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgMywgY2IpO1xufVxuZXhwb3J0cy5ndW56aXAgPSBndW56aXA7XG4vKipcbiAqIEV4cGFuZHMgR1pJUCBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgZGVjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gZ3VuemlwU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgdmFyIHN0ID0gZ3pzKGRhdGEpO1xuICAgIGlmIChzdCArIDggPiBkYXRhLmxlbmd0aClcbiAgICAgICAgZXJyKDYsICdpbnZhbGlkIGd6aXAgZGF0YScpO1xuICAgIHJldHVybiBpbmZsdChkYXRhLnN1YmFycmF5KHN0LCAtOCksIHsgaTogMiB9LCBvcHRzICYmIG9wdHMub3V0IHx8IG5ldyB1OChnemwoZGF0YSkpLCBvcHRzICYmIG9wdHMuZGljdGlvbmFyeSk7XG59XG5leHBvcnRzLmd1bnppcFN5bmMgPSBndW56aXBTeW5jO1xuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGFkbGVyKCk7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIERlZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHpsaWJiZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIFpsaWIucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB2YXIgcmF3ID0gZG9wdChjLCB0aGlzLm8sIHRoaXMudiAmJiAodGhpcy5vLmRpY3Rpb25hcnkgPyA2IDogMiksIGYgJiYgNCwgdGhpcy5zKTtcbiAgICAgICAgaWYgKHRoaXMudilcbiAgICAgICAgICAgIHpsaChyYXcsIHRoaXMubyksIHRoaXMudiA9IDA7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgICAgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMuYy5kKCkpO1xuICAgICAgICB0aGlzLm9uZGF0YShyYXcsIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBidWZmZXJlZCB1bmNvbXByZXNzZWQgZGF0YS4gVXNlZnVsIHRvIGltbWVkaWF0ZWx5IHJldHJpZXZlIHRoZVxuICAgICAqIHpsaWJiZWQgb3V0cHV0IGZvciBzbWFsbCBpbnB1dHMuXG4gICAgICovXG4gICAgWmxpYi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gWmxpYjtcbn0oKSk7XG5leHBvcnRzLlpsaWIgPSBabGliO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIFpsaWIgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY1psaWIob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICB6bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGUsIFpsaWJdOyB9XG4gICAgICAgIF0sIHRoaXMsIFN0cm1PcHQuY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgWmxpYihldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1psaWI7XG59KCkpO1xuZXhwb3J0cy5Bc3luY1psaWIgPSBBc3luY1psaWI7XG5mdW5jdGlvbiB6bGliKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgICAgIHpsZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psaWJTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKHpsaWJTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgNCwgY2IpO1xufVxuZXhwb3J0cy56bGliID0gemxpYjtcbi8qKlxuICogQ29tcHJlc3MgZGF0YSB3aXRoIFpsaWJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIHpsaWItY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHpsaWJTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYSA9IGFkbGVyKCk7XG4gICAgYS5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCBvcHRzLmRpY3Rpb25hcnkgPyA2IDogMiwgNCk7XG4gICAgcmV0dXJuIHpsaChkLCBvcHRzKSwgd2J5dGVzKGQsIGQubGVuZ3RoIC0gNCwgYS5kKCkpLCBkO1xufVxuZXhwb3J0cy56bGliU3luYyA9IHpsaWJTeW5jO1xuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBVbnpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW56bGliKG9wdHMsIGNiKSB7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgICAgIHRoaXMudiA9IG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5ID8gMiA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHVuemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnpsaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgNiAmJiAhZmluYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KHpscyh0aGlzLnAsIHRoaXMudiAtIDEpKSwgdGhpcy52ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgNClcbiAgICAgICAgICAgICAgICBlcnIoNiwgJ2ludmFsaWQgemxpYiBkYXRhJyk7XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMCwgLTQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lY2Vzc2FyeSB0byBwcmV2ZW50IFRTIGZyb20gdXNpbmcgdGhlIGNsb3N1cmUgdmFsdWVcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHdvcmtlcml6YXRpb24gdG8gZnVuY3Rpb24gY29ycmVjdGx5XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmMuY2FsbCh0aGlzLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gVW56bGliO1xufSgpKTtcbmV4cG9ydHMuVW56bGliID0gVW56bGliO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNVbnpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNVbnpsaWIob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgenVsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZSwgVW56bGliXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IFVuemxpYihldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1VuemxpYjtcbn0oKSk7XG5leHBvcnRzLkFzeW5jVW56bGliID0gQXN5bmNVbnpsaWI7XG5mdW5jdGlvbiB1bnpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHQsXG4gICAgICAgIHp1bGUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1bnpsaWJTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKHVuemxpYlN5bmMoZXYuZGF0YVswXSwgZ29wdChldi5kYXRhWzFdKSkpOyB9LCA1LCBjYik7XG59XG5leHBvcnRzLnVuemxpYiA9IHVuemxpYjtcbi8qKlxuICogRXhwYW5kcyBabGliIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBkZWNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5mdW5jdGlvbiB1bnpsaWJTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gaW5mbHQoZGF0YS5zdWJhcnJheSh6bHMoZGF0YSwgb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkpLCAtNCksIHsgaTogMiB9LCBvcHRzICYmIG9wdHMub3V0LCBvcHRzICYmIG9wdHMuZGljdGlvbmFyeSk7XG59XG5leHBvcnRzLnVuemxpYlN5bmMgPSB1bnpsaWJTeW5jO1xuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgRGVjb21wcmVzcyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWNvbXByZXNzKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMubyA9IFN0cm1PcHQuY2FsbCh0aGlzLCBvcHRzLCBjYikgfHwge307XG4gICAgICAgIHRoaXMuRyA9IEd1bnppcDtcbiAgICAgICAgdGhpcy5JID0gSW5mbGF0ZTtcbiAgICAgICAgdGhpcy5aID0gVW56bGliO1xuICAgIH1cbiAgICAvLyBpbml0IHN1YnN0cmVhbVxuICAgIC8vIG92ZXJyaWRlbiBieSBBc3luY0RlY29tcHJlc3NcbiAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5pID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnMub25kYXRhID0gZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShkYXQsIGZpbmFsKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29tcHJlc3NlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAoIXRoaXMucykge1xuICAgICAgICAgICAgaWYgKHRoaXMucCAmJiB0aGlzLnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucCA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gKHRoaXMucFswXSA9PSAzMSAmJiB0aGlzLnBbMV0gPT0gMTM5ICYmIHRoaXMucFsyXSA9PSA4KVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkcodGhpcy5vKVxuICAgICAgICAgICAgICAgICAgICA6ICgodGhpcy5wWzBdICYgMTUpICE9IDggfHwgKHRoaXMucFswXSA+PiA0KSA+IDcgfHwgKCh0aGlzLnBbMF0gPDwgOCB8IHRoaXMucFsxXSkgJSAzMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkkodGhpcy5vKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdGhpcy5aKHRoaXMubyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zLnB1c2godGhpcy5wLCBmaW5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnMucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0cy5EZWNvbXByZXNzID0gRGVjb21wcmVzcztcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0RlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNEZWNvbXByZXNzKG9wdHMsIGNiKSB7XG4gICAgICAgIERlY29tcHJlc3MuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgICAgIHRoaXMucXVldWVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuRyA9IEFzeW5jR3VuemlwO1xuICAgICAgICB0aGlzLkkgPSBBc3luY0luZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IEFzeW5jVW56bGliO1xuICAgIH1cbiAgICBBc3luY0RlY29tcHJlc3MucHJvdG90eXBlLmkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucy5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zLm9uZHJhaW4gPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICAgICAgX3RoaXMucXVldWVkU2l6ZSAtPSBzaXplO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9uZHJhaW4pXG4gICAgICAgICAgICAgICAgX3RoaXMub25kcmFpbihzaXplKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29tcHJlc3NlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBBc3luY0RlY29tcHJlc3MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMucXVldWVkU2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIERlY29tcHJlc3MucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jRGVjb21wcmVzcztcbn0oKSk7XG5leHBvcnRzLkFzeW5jRGVjb21wcmVzcyA9IEFzeW5jRGVjb21wcmVzcztcbmZ1bmN0aW9uIGRlY29tcHJlc3MoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcChkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgICAgIDogdW56bGliKGRhdGEsIG9wdHMsIGNiKTtcbn1cbmV4cG9ydHMuZGVjb21wcmVzcyA9IGRlY29tcHJlc3M7XG4vKipcbiAqIEV4cGFuZHMgY29tcHJlc3NlZCBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkYXRhLCBhdXRvbWF0aWNhbGx5IGRldGVjdGluZyB0aGUgZm9ybWF0XG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgZGVjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3B0cykge1xuICAgIHJldHVybiAoZGF0YVswXSA9PSAzMSAmJiBkYXRhWzFdID09IDEzOSAmJiBkYXRhWzJdID09IDgpXG4gICAgICAgID8gZ3VuemlwU3luYyhkYXRhLCBvcHRzKVxuICAgICAgICA6ICgoZGF0YVswXSAmIDE1KSAhPSA4IHx8IChkYXRhWzBdID4+IDQpID4gNyB8fCAoKGRhdGFbMF0gPDwgOCB8IGRhdGFbMV0pICUgMzEpKVxuICAgICAgICAgICAgPyBpbmZsYXRlU3luYyhkYXRhLCBvcHRzKVxuICAgICAgICAgICAgOiB1bnpsaWJTeW5jKGRhdGEsIG9wdHMpO1xufVxuZXhwb3J0cy5kZWNvbXByZXNzU3luYyA9IGRlY29tcHJlc3NTeW5jO1xuLy8gZmxhdHRlbiBhIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbnZhciBmbHRuID0gZnVuY3Rpb24gKGQsIHAsIHQsIG8pIHtcbiAgICBmb3IgKHZhciBrIGluIGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRba10sIG4gPSBwICsgaywgb3AgPSBvO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgICAgICAgICAgb3AgPSBtcmcobywgdmFsWzFdKSwgdmFsID0gdmFsWzBdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgdTgpXG4gICAgICAgICAgICB0W25dID0gW3ZhbCwgb3BdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRbbiArPSAnLyddID0gW25ldyB1OCgwKSwgb3BdO1xuICAgICAgICAgICAgZmx0bih2YWwsIG4sIHQsIG8pO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIHRleHQgZW5jb2RlclxudmFyIHRlID0gdHlwZW9mIFRleHRFbmNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXJcbnZhciB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyAmJiAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RGVjb2RlcigpO1xuLy8gdGV4dCBkZWNvZGVyIHN0cmVhbVxudmFyIHRkcyA9IDA7XG50cnkge1xuICAgIHRkLmRlY29kZShldCwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgdGRzID0gMTtcbn1cbmNhdGNoIChlKSB7IH1cbi8vIGRlY29kZSBVVEY4XG52YXIgZHV0ZjggPSBmdW5jdGlvbiAoZCkge1xuICAgIGZvciAodmFyIHIgPSAnJywgaSA9IDA7Oykge1xuICAgICAgICB2YXIgYyA9IGRbaSsrXTtcbiAgICAgICAgdmFyIGViID0gKGMgPiAxMjcpICsgKGMgPiAyMjMpICsgKGMgPiAyMzkpO1xuICAgICAgICBpZiAoaSArIGViID4gZC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyBzOiByLCByOiBzbGMoZCwgaSAtIDEpIH07XG4gICAgICAgIGlmICghZWIpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGViID09IDMpIHtcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZFtpKytdICYgNjMpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWIgJiAxKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGRlY29kaW5nXG4gKi9cbnZhciBEZWNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBpZiAodGRzKVxuICAgICAgICAgICAgdGhpcy50ID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvZGVkIGZyb20gVVRGLTggYmluYXJ5XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGZpbmFsID0gISFmaW5hbDtcbiAgICAgICAgaWYgKHRoaXMudCkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEodGhpcy50LmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSksIGZpbmFsKTtcbiAgICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnQuZGVjb2RlKCkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBlcnIoOCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgdmFyIGRhdCA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgZGF0LnNldCh0aGlzLnApO1xuICAgICAgICBkYXQuc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgcyA9IF9hLnMsIHIgPSBfYS5yO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmIChyLmxlbmd0aClcbiAgICAgICAgICAgICAgICBlcnIoOCk7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IHI7XG4gICAgICAgIHRoaXMub25kYXRhKHMsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydHMuRGVjb2RlVVRGOCA9IERlY29kZVVURjg7XG4vKipcbiAqIFN0cmVhbWluZyBVVEYtOCBlbmNvZGluZ1xuICovXG52YXIgRW5jb2RlVVRGOCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVVRGLTggZGVjb2Rpbmcgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZW5jb2RlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVuY29kZVVURjgoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZW5jb2RlZCB0byBVVEYtOFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgc3RyaW5nIGRhdGEgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBFbmNvZGVVVEY4LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgZXJyKDQpO1xuICAgICAgICB0aGlzLm9uZGF0YShzdHJUb1U4KGNodW5rKSwgdGhpcy5kID0gZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIEVuY29kZVVURjg7XG59KCkpO1xuZXhwb3J0cy5FbmNvZGVVVEY4ID0gRW5jb2RlVVRGODtcbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkgZm9yIHVzZSB3aXRoIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gbWV0aG9kc1xuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZGVjb2RpbmcgYSBiaW5hcnkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyBlbmNvZGVkIGluIFVURi04L0xhdGluLTEgYmluYXJ5XG4gKi9cbmZ1bmN0aW9uIHN0clRvVTgoc3RyLCBsYXRpbjEpIHtcbiAgICBpZiAobGF0aW4xKSB7XG4gICAgICAgIHZhciBhcl8xID0gbmV3IHU4KHN0ci5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGFyXzFbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmV0dXJuIGFyXzE7XG4gICAgfVxuICAgIGlmICh0ZSlcbiAgICAgICAgcmV0dXJuIHRlLmVuY29kZShzdHIpO1xuICAgIHZhciBsID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgYXIgPSBuZXcgdTgoc3RyLmxlbmd0aCArIChzdHIubGVuZ3RoID4+IDEpKTtcbiAgICB2YXIgYWkgPSAwO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgYXJbYWkrK10gPSB2OyB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGlmIChhaSArIDUgPiBhci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KGFpICsgOCArICgobCAtIGkpIDw8IDEpKTtcbiAgICAgICAgICAgIG4uc2V0KGFyKTtcbiAgICAgICAgICAgIGFyID0gbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCB8fCBsYXRpbjEpXG4gICAgICAgICAgICB3KGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcbiAgICAgICAgICAgIHcoMTkyIHwgKGMgPj4gNikpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgZWxzZSBpZiAoYyA+IDU1Mjk1ICYmIGMgPCA1NzM0NClcbiAgICAgICAgICAgIGMgPSA2NTUzNiArIChjICYgMTAyMyA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDEwMjMpLFxuICAgICAgICAgICAgICAgIHcoMjQwIHwgKGMgPj4gMTgpKSwgdygxMjggfCAoKGMgPj4gMTIpICYgNjMpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdygyMjQgfCAoYyA+PiAxMikpLCB3KDEyOCB8ICgoYyA+PiA2KSAmIDYzKSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKGFyLCAwLCBhaSk7XG59XG5leHBvcnRzLnN0clRvVTggPSBzdHJUb1U4O1xuLyoqXG4gKiBDb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSBkYXQgVGhlIGRhdGEgdG8gZGVjb2RlIHRvIHN0cmluZ1xuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZW5jb2RpbmcgdG8gYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBVVEYtOC9MYXRpbi0xIHN0cmluZ1xuICovXG5mdW5jdGlvbiBzdHJGcm9tVTgoZGF0LCBsYXRpbjEpIHtcbiAgICBpZiAobGF0aW4xKSB7XG4gICAgICAgIHZhciByID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0Lmxlbmd0aDsgaSArPSAxNjM4NClcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXQuc3ViYXJyYXkoaSwgaSArIDE2Mzg0KSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZCkge1xuICAgICAgICByZXR1cm4gdGQuZGVjb2RlKGRhdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgX2EgPSBkdXRmOChkYXQpLCBzID0gX2EucywgciA9IF9hLnI7XG4gICAgICAgIGlmIChyLmxlbmd0aClcbiAgICAgICAgICAgIGVycig4KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufVxuZXhwb3J0cy5zdHJGcm9tVTggPSBzdHJGcm9tVTg7XG47XG4vLyBkZWZsYXRlIGJpdCBmbGFnXG52YXIgZGJmID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgPT0gMSA/IDMgOiBsIDwgNiA/IDIgOiBsID09IDkgPyAxIDogMDsgfTtcbi8vIHNraXAgbG9jYWwgemlwIGhlYWRlclxudmFyIHNsemggPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gYiArIDMwICsgYjIoZCwgYiArIDI2KSArIGIyKGQsIGIgKyAyOCk7IH07XG4vLyByZWFkIHppcCBoZWFkZXJcbnZhciB6aCA9IGZ1bmN0aW9uIChkLCBiLCB6KSB7XG4gICAgdmFyIGZubCA9IGIyKGQsIGIgKyAyOCksIGZuID0gc3RyRnJvbVU4KGQuc3ViYXJyYXkoYiArIDQ2LCBiICsgNDYgKyBmbmwpLCAhKGIyKGQsIGIgKyA4KSAmIDIwNDgpKSwgZXMgPSBiICsgNDYgKyBmbmwsIGJzID0gYjQoZCwgYiArIDIwKTtcbiAgICB2YXIgX2EgPSB6ICYmIGJzID09IDQyOTQ5NjcyOTUgPyB6NjRlKGQsIGVzKSA6IFticywgYjQoZCwgYiArIDI0KSwgYjQoZCwgYiArIDQyKV0sIHNjID0gX2FbMF0sIHN1ID0gX2FbMV0sIG9mZiA9IF9hWzJdO1xuICAgIHJldHVybiBbYjIoZCwgYiArIDEwKSwgc2MsIHN1LCBmbiwgZXMgKyBiMihkLCBiICsgMzApICsgYjIoZCwgYiArIDMyKSwgb2ZmXTtcbn07XG4vLyByZWFkIHppcDY0IGV4dHJhIGZpZWxkXG52YXIgejY0ZSA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICg7IGIyKGQsIGIpICE9IDE7IGIgKz0gNCArIGIyKGQsIGIgKyAyKSlcbiAgICAgICAgO1xuICAgIHJldHVybiBbYjgoZCwgYiArIDEyKSwgYjgoZCwgYiArIDQpLCBiOChkLCBiICsgMjApXTtcbn07XG4vLyBleHRyYSBmaWVsZCBsZW5ndGhcbnZhciBleGZsID0gZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIGxlID0gMDtcbiAgICBpZiAoZXgpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBleCkge1xuICAgICAgICAgICAgdmFyIGwgPSBleFtrXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobCA+IDY1NTM1KVxuICAgICAgICAgICAgICAgIGVycig5KTtcbiAgICAgICAgICAgIGxlICs9IGwgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZTtcbn07XG4vLyB3cml0ZSB6aXAgaGVhZGVyXG52YXIgd3poID0gZnVuY3Rpb24gKGQsIGIsIGYsIGZuLCB1LCBjLCBjZSwgY28pIHtcbiAgICB2YXIgZmwgPSBmbi5sZW5ndGgsIGV4ID0gZi5leHRyYSwgY29sID0gY28gJiYgY28ubGVuZ3RoO1xuICAgIHZhciBleGwgPSBleGZsKGV4KTtcbiAgICB3Ynl0ZXMoZCwgYiwgY2UgIT0gbnVsbCA/IDB4MjAxNEI1MCA6IDB4NDAzNEI1MCksIGIgKz0gNDtcbiAgICBpZiAoY2UgIT0gbnVsbClcbiAgICAgICAgZFtiKytdID0gMjAsIGRbYisrXSA9IGYub3M7XG4gICAgZFtiXSA9IDIwLCBiICs9IDI7IC8vIHNwZWMgY29tcGxpYW5jZT8gd2hhdCdzIHRoYXQ/XG4gICAgZFtiKytdID0gKGYuZmxhZyA8PCAxKSB8IChjIDwgMCAmJiA4KSwgZFtiKytdID0gdSAmJiA4O1xuICAgIGRbYisrXSA9IGYuY29tcHJlc3Npb24gJiAyNTUsIGRbYisrXSA9IGYuY29tcHJlc3Npb24gPj4gODtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZShmLm10aW1lID09IG51bGwgPyBEYXRlLm5vdygpIDogZi5tdGltZSksIHkgPSBkdC5nZXRGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBpZiAoeSA8IDAgfHwgeSA+IDExOSlcbiAgICAgICAgZXJyKDEwKTtcbiAgICB3Ynl0ZXMoZCwgYiwgKHkgPDwgMjUpIHwgKChkdC5nZXRNb250aCgpICsgMSkgPDwgMjEpIHwgKGR0LmdldERhdGUoKSA8PCAxNikgfCAoZHQuZ2V0SG91cnMoKSA8PCAxMSkgfCAoZHQuZ2V0TWludXRlcygpIDw8IDUpIHwgKGR0LmdldFNlY29uZHMoKSA+PiAxKSksIGIgKz0gNDtcbiAgICBpZiAoYyAhPSAtMSkge1xuICAgICAgICB3Ynl0ZXMoZCwgYiwgZi5jcmMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDQsIGMgPCAwID8gLWMgLSAyIDogYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgOCwgZi5zaXplKTtcbiAgICB9XG4gICAgd2J5dGVzKGQsIGIgKyAxMiwgZmwpO1xuICAgIHdieXRlcyhkLCBiICsgMTQsIGV4bCksIGIgKz0gMTY7XG4gICAgaWYgKGNlICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGNvbCk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNiwgZi5hdHRycyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgMTAsIGNlKSwgYiArPSAxNDtcbiAgICB9XG4gICAgZC5zZXQoZm4sIGIpO1xuICAgIGIgKz0gZmw7XG4gICAgaWYgKGV4bCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhmID0gZXhba10sIGwgPSBleGYubGVuZ3RoO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIsICtrKTtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiICsgMiwgbCk7XG4gICAgICAgICAgICBkLnNldChleGYsIGIgKyA0KSwgYiArPSA0ICsgbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sKVxuICAgICAgICBkLnNldChjbywgYiksIGIgKz0gY29sO1xuICAgIHJldHVybiBiO1xufTtcbi8vIHdyaXRlIHppcCBmb290ZXIgKGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSlcbnZhciB3emYgPSBmdW5jdGlvbiAobywgYiwgYywgZCwgZSkge1xuICAgIHdieXRlcyhvLCBiLCAweDYwNTRCNTApOyAvLyBza2lwIGRpc2tcbiAgICB3Ynl0ZXMobywgYiArIDgsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTAsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTIsIGQpO1xuICAgIHdieXRlcyhvLCBiICsgMTYsIGUpO1xufTtcbi8qKlxuICogQSBwYXNzLXRocm91Z2ggc3RyZWFtIHRvIGtlZXAgZGF0YSB1bmNvbXByZXNzZWQgaW4gYSBaSVAgYXJjaGl2ZS5cbiAqL1xudmFyIFppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYXNzLXRocm91Z2ggc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcFBhc3NUaHJvdWdoKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBjaHVuayBhbmQgcHVzaGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXNcbiAgICAgKiBtZXRob2QgaW4gYSBzdWJjbGFzcyBmb3IgY3VzdG9tIGJlaGF2aW9yLCBidXQgYnkgZGVmYXVsdCB0aGlzIHBhc3Nlc1xuICAgICAqIHRoZSBkYXRhIHRocm91Z2guIFlvdSBtdXN0IGNhbGwgdGhpcy5vbmRhdGEoZXJyLCBjaHVuaywgZmluYWwpIGF0IHNvbWVcbiAgICAgKiBwb2ludCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBhZGRlZC4gSWYgeW91IGFyZSBzdWJjbGFzc2luZyB0aGlzIHdpdGggYSBjdXN0b21cbiAgICAgKiBjb21wcmVzc2lvbiBhbGdvcml0aG0sIG5vdGUgdGhhdCB5b3UgbXVzdCBwdXNoIGRhdGEgZnJvbSB0aGUgc291cmNlXG4gICAgICogZmlsZSBvbmx5LCBwcmUtY29tcHJlc3Npb24uXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICB0aGlzLmMucChjaHVuayk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChmaW5hbClcbiAgICAgICAgICAgIHRoaXMuY3JjID0gdGhpcy5jLmQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwUGFzc1Rocm91Z2g7XG59KCkpO1xuZXhwb3J0cy5aaXBQYXNzVGhyb3VnaCA9IFppcFBhc3NUaHJvdWdoO1xuLy8gSSBkb24ndCBleHRlbmQgYmVjYXVzZSBUeXBlU2NyaXB0IGV4dGVuc2lvbiBhZGRzIDFrQiBvZiBydW50aW1lIGJsb2F0XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXMuIFByZWZlciB1c2luZyBBc3luY1ppcERlZmxhdGVcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqL1xudmFyIFppcERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLmNhbGwodGhpcywgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmQgPSBuZXcgRGVmbGF0ZShvcHRzLCBmdW5jdGlvbiAoZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXMub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICB9XG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIG51bGwsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5aaXBEZWZsYXRlID0gWmlwRGVmbGF0ZTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIEFzeW5jWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLmNhbGwodGhpcywgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmQgPSBuZXcgQXN5bmNEZWZsYXRlKG9wdHMsIGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSB0aGlzLmQudGVybWluYXRlO1xuICAgIH1cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY1ppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5Bc3luY1ppcERlZmxhdGUgPSBBc3luY1ppcERlZmxhdGU7XG4vLyBUT0RPOiBCZXR0ZXIgdHJlZSBzaGFraW5nXG4vKipcbiAqIEEgemlwcGFibGUgYXJjaGl2ZSB0byB3aGljaCBmaWxlcyBjYW4gaW5jcmVtZW50YWxseSBiZSBhZGRlZFxuICovXG52YXIgWmlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgWklQIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgZm9yIHRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAgICAgKiAgICAgICAgICAgaXMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIHRoaXMudSA9IFtdO1xuICAgICAgICB0aGlzLmQgPSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZmlsZSB0byB0aGUgWklQIGFyY2hpdmVcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSBzdHJlYW0gdG8gYWRkXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICAvLyBmaW5pc2hpbmcgb3IgZmluaXNoZWRcbiAgICAgICAgaWYgKHRoaXMuZCAmIDIpXG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlcnIoNCArICh0aGlzLmQgJiAxKSAqIDgsIDAsIDEpLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZpbGUuZmlsZW5hbWUpLCBmbF8xID0gZi5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29tID0gZmlsZS5jb21tZW50LCBvID0gY29tICYmIHN0clRvVTgoY29tKTtcbiAgICAgICAgICAgIHZhciB1ID0gZmxfMSAhPSBmaWxlLmZpbGVuYW1lLmxlbmd0aCB8fCAobyAmJiAoY29tLmxlbmd0aCAhPSBvLmxlbmd0aCkpO1xuICAgICAgICAgICAgdmFyIGhsXzEgPSBmbF8xICsgZXhmbChmaWxlLmV4dHJhKSArIDMwO1xuICAgICAgICAgICAgaWYgKGZsXzEgPiA2NTUzNSlcbiAgICAgICAgICAgICAgICB0aGlzLm9uZGF0YShlcnIoMTEsIDAsIDEpLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gbmV3IHU4KGhsXzEpO1xuICAgICAgICAgICAgd3poKGhlYWRlciwgMCwgZmlsZSwgZiwgdSwgLTEpO1xuICAgICAgICAgICAgdmFyIGNoa3NfMSA9IFtoZWFkZXJdO1xuICAgICAgICAgICAgdmFyIHBBbGxfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfMiA9IGNoa3NfMTsgX2kgPCBjaGtzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGsgPSBjaGtzXzJbX2ldO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmRhdGEobnVsbCwgY2hrLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoa3NfMSA9IFtdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0cl8xID0gdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5kID0gMDtcbiAgICAgICAgICAgIHZhciBpbmRfMSA9IHRoaXMudS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdWZfMSA9IG1yZyhmaWxlLCB7XG4gICAgICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgICAgICB1OiB1LFxuICAgICAgICAgICAgICAgIG86IG8sXG4gICAgICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBwQWxsXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBueHQgPSBfdGhpcy51W2luZF8xICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG54dC5yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJfMSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY2xfMSA9IDA7XG4gICAgICAgICAgICBmaWxlLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsXzEgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2hrc18xLnB1c2goZGF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGQgPSBuZXcgdTgoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAwLCAweDgwNzRCNTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA0LCBmaWxlLmNyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDgsIGNsXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAxMiwgZmlsZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoa3NfMS5wdXNoKGRkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmXzEuYyA9IGNsXzEsIHVmXzEuYiA9IGhsXzEgKyBjbF8xICsgMTYsIHVmXzEuY3JjID0gZmlsZS5jcmMsIHVmXzEuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cl8xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmXzEucigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJfMSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBBbGxfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnUucHVzaCh1Zl8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5kcyB0aGUgcHJvY2VzcyBvZiBhZGRpbmcgZmlsZXMgYW5kIHByZXBhcmVzIHRvIGVtaXQgdGhlIGZpbmFsIGNodW5rcy5cbiAgICAgKiBUaGlzICptdXN0KiBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIGFsbCBkZXNpcmVkIGZpbGVzIGZvciB0aGUgcmVzdWx0aW5nXG4gICAgICogWklQIGZpbGUgdG8gd29yayBwcm9wZXJseS5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZCAmIDIpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGVycig0ICsgKHRoaXMuZCAmIDEpICogOCwgMCwgMSksIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aGlzLmUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51LnB1c2goe1xuICAgICAgICAgICAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX3RoaXMuZCAmIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51LnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZCA9IDM7XG4gICAgfTtcbiAgICBaaXAucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidCA9IDAsIGwgPSAwLCB0bCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9hW19pXTtcbiAgICAgICAgICAgIHRsICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodGwgKyAyMik7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLnU7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9jW19iXTtcbiAgICAgICAgICAgIHd6aChvdXQsIGJ0LCBmLCBmLmYsIGYudSwgLWYuYyAtIDIsIGwsIGYubyk7XG4gICAgICAgICAgICBidCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKSwgbCArPSBmLmI7XG4gICAgICAgIH1cbiAgICAgICAgd3pmKG91dCwgYnQsIHRoaXMudS5sZW5ndGgsIHRsLCBsKTtcbiAgICAgICAgdGhpcy5vbmRhdGEobnVsbCwgb3V0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIHRvIHRlcm1pbmF0ZSBhbnkgaW50ZXJuYWwgd29ya2VycyB1c2VkIGJ5IHRoZSBzdHJlYW0uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byBhZGQoKSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9hW19pXTtcbiAgICAgICAgICAgIGYudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZCA9IDI7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwO1xufSgpKTtcbmV4cG9ydHMuWmlwID0gWmlwO1xuZnVuY3Rpb24gemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgdmFyIHIgPSB7fTtcbiAgICBmbHRuKGRhdGEsICcnLCByLCBvcHRzKTtcbiAgICB2YXIgayA9IE9iamVjdC5rZXlzKHIpO1xuICAgIHZhciBsZnQgPSBrLmxlbmd0aCwgbyA9IDAsIHRvdCA9IDA7XG4gICAgdmFyIHNsZnQgPSBsZnQsIGZpbGVzID0gbmV3IEFycmF5KGxmdCk7XG4gICAgdmFyIHRlcm0gPSBbXTtcbiAgICB2YXIgdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGVybVtpXSgpO1xuICAgIH07XG4gICAgdmFyIGNiZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIG10KGZ1bmN0aW9uICgpIHsgY2IoYSwgYik7IH0pO1xuICAgIH07XG4gICAgbXQoZnVuY3Rpb24gKCkgeyBjYmQgPSBjYjsgfSk7XG4gICAgdmFyIGNiZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyB1OCh0b3QgKyAyMiksIG9lID0gbywgY2RsID0gdG90IC0gbztcbiAgICAgICAgdG90ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGZ0OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmlsZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZi5jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3emgob3V0LCB0b3QsIGYsIGYuZiwgZi51LCBsKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFkZCA9IDMwICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvYyA9IHRvdCArIGJhZGQ7XG4gICAgICAgICAgICAgICAgb3V0LnNldChmLmMsIGxvYyk7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgbywgZiwgZi5mLCBmLnUsIGwsIHRvdCwgZi5tKSwgbyArPSAxNiArIGJhZGQgKyAoZi5tID8gZi5tLmxlbmd0aCA6IDApLCB0b3QgPSBsb2MgKyBsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2JkKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgICAgIGNiZChudWxsLCBvdXQpO1xuICAgIH07XG4gICAgaWYgKCFsZnQpXG4gICAgICAgIGNiZigpO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGZuID0ga1tpXTtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgYyA9IGNyYygpLCBzaXplID0gZmlsZS5sZW5ndGg7XG4gICAgICAgIGMucChmaWxlKTtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcC5sZXZlbCA9PSAwID8gMCA6IDg7XG4gICAgICAgIHZhciBjYmwgPSBmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgY2JkKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmaWxlc1tpXSA9IG1yZyhwLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICAgICAgICAgIGM6IGQsXG4gICAgICAgICAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICAgICAgICAgIHU6IHMgIT0gZm4ubGVuZ3RoIHx8IChtICYmIChjb20ubGVuZ3RoICE9IG1zKSksXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgICAgICAgICB0b3QgKz0gNzYgKyAyICogKHMgKyBleGwpICsgKG1zIHx8IDApICsgbDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tbGZ0KVxuICAgICAgICAgICAgICAgICAgICBjYmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIGNibChlcnIoMTEsIDAsIDEpLCBudWxsKTtcbiAgICAgICAgaWYgKCFjb21wcmVzc2lvbilcbiAgICAgICAgICAgIGNibChudWxsLCBmaWxlKTtcbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA8IDE2MDAwMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYmwobnVsbCwgZGVmbGF0ZVN5bmMoZmlsZSwgcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYmwoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGVybS5wdXNoKGRlZmxhdGUoZmlsZSwgcCwgY2JsKSk7XG4gICAgfTtcbiAgICAvLyBDYW5ub3QgdXNlIGxmdCBiZWNhdXNlIGl0IGNhbiBkZWNyZWFzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHJldHVybiB0QWxsO1xufVxuZXhwb3J0cy56aXAgPSB6aXA7XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgY3JlYXRlcyBhIFpJUCBmaWxlLiBQcmVmZXIgdXNpbmcgYHppcGAgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICogd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGlyZWN0b3J5IHN0cnVjdHVyZSBmb3IgdGhlIFpJUCBhcmNoaXZlXG4gKiBAcGFyYW0gb3B0cyBUaGUgbWFpbiBvcHRpb25zLCBtZXJnZWQgd2l0aCBwZXItZmlsZSBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gKi9cbmZ1bmN0aW9uIHppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciByID0ge307XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIG8gPSAwO1xuICAgIHZhciB0b3QgPSAwO1xuICAgIGZvciAodmFyIGZuIGluIHIpIHtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIGVycigxMSk7XG4gICAgICAgIHZhciBkID0gY29tcHJlc3Npb24gPyBkZWZsYXRlU3luYyhmaWxlLCBwKSA6IGZpbGUsIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgdmFyIGMgPSBjcmMoKTtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICBmaWxlcy5wdXNoKG1yZyhwLCB7XG4gICAgICAgICAgICBzaXplOiBmaWxlLmxlbmd0aCxcbiAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICB9KSk7XG4gICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICB3emgob3V0LCBmLm8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICBvdXQuc2V0KGYuYywgZi5vICsgYmFkZCk7XG4gICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoLCBmLm8sIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKTtcbiAgICB9XG4gICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy56aXBTeW5jID0gemlwU3luYztcbi8qKlxuICogU3RyZWFtaW5nIHBhc3MtdGhyb3VnaCBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIFVuemlwUGFzc1Rocm91Z2ggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW56aXBQYXNzVGhyb3VnaCgpIHtcbiAgICB9XG4gICAgVW56aXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBkYXRhLCBmaW5hbCk7XG4gICAgfTtcbiAgICBVbnppcFBhc3NUaHJvdWdoLmNvbXByZXNzaW9uID0gMDtcbiAgICByZXR1cm4gVW56aXBQYXNzVGhyb3VnaDtcbn0oKSk7XG5leHBvcnRzLlVuemlwUGFzc1Rocm91Z2ggPSBVbnppcFBhc3NUaHJvdWdoO1xuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXMuIFByZWZlciBBc3luY1ppcEluZmxhdGUgZm9yXG4gKiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKi9cbnZhciBVbnppcEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgZGVjb21wcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIGluIFpJUCBhcmNoaXZlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwSW5mbGF0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pID0gbmV3IEluZmxhdGUoZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFVuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pLnB1c2goZGF0YSwgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBudWxsLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIFVuemlwSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnRzLlVuemlwSW5mbGF0ZSA9IFVuemlwSW5mbGF0ZTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNVbnppcEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgZGVjb21wcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIGluIFpJUCBhcmNoaXZlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56aXBJbmZsYXRlKF8sIHN6KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzeiA8IDMyMDAwMCkge1xuICAgICAgICAgICAgdGhpcy5pID0gbmV3IEluZmxhdGUoZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBBc3luY0luZmxhdGUoZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSA9IHRoaXMuaS50ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXN5bmNVbnppcEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaS50ZXJtaW5hdGUpXG4gICAgICAgICAgICBkYXRhID0gc2xjKGRhdGEsIDApO1xuICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgfTtcbiAgICBBc3luY1VuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIEFzeW5jVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNVbnppcEluZmxhdGUgPSBBc3luY1VuemlwSW5mbGF0ZTtcbi8qKlxuICogQSBaSVAgYXJjaGl2ZSBkZWNvbXByZXNzaW9uIHN0cmVhbSB0aGF0IGVtaXRzIGZpbGVzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWRcbiAqL1xudmFyIFVuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBaSVAgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgYSBmaWxlIGluIHRoZSBaSVAgYXJjaGl2ZSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25maWxlID0gY2I7XG4gICAgICAgIHRoaXMuayA9IFtdO1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgICAwOiBVbnppcFBhc3NUaHJvdWdoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnppcHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLm9uZmlsZSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICBlcnIoNCk7XG4gICAgICAgIGlmICh0aGlzLmMgPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4odGhpcy5jLCBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHRvQWRkID0gY2h1bmsuc3ViYXJyYXkoMCwgbGVuKTtcbiAgICAgICAgICAgIHRoaXMuYyAtPSBsZW47XG4gICAgICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgICAgIHRoaXMuZC5wdXNoKHRvQWRkLCAhdGhpcy5jKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmtbMF0ucHVzaCh0b0FkZCk7XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnN1YmFycmF5KGxlbik7XG4gICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gMCwgaSA9IDAsIGlzID0gdm9pZCAwLCBidWYgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIXRoaXMucC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gY2h1bms7XG4gICAgICAgICAgICBlbHNlIGlmICghY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJ1ZiA9IHRoaXMucDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZiA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBidWYuc2V0KHRoaXMucCksIGJ1Zi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGwgPSBidWYubGVuZ3RoLCBvYyA9IHRoaXMuYywgYWRkID0gb2MgJiYgdGhpcy5kO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBzaWcgPSBiNChidWYsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChzaWcgPT0gMHg0MDM0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSAxLCBpcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmYgPSBiMihidWYsIGkgKyA2KSwgY21wXzEgPSBiMihidWYsIGkgKyA4KSwgdSA9IGJmICYgMjA0OCwgZGQgPSBiZiAmIDgsIGZubCA9IGIyKGJ1ZiwgaSArIDI2KSwgZXMgPSBiMihidWYsIGkgKyAyOCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsID4gaSArIDMwICsgZm5sICsgZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGtzXzMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5rLnVuc2hpZnQoY2hrc18zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjXzEgPSBiNChidWYsIGkgKyAxOCksIHN1XzEgPSBiNChidWYsIGkgKyAyMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5fMSA9IHN0ckZyb21VOChidWYuc3ViYXJyYXkoaSArIDMwLCBpICs9IDMwICsgZm5sKSwgIXUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjXzEgPT0gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZGQgPyBbLTJdIDogejY0ZShidWYsIGkpLCBzY18xID0gX2FbMF0sIHN1XzEgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjXzEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IHNjXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmbl8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjbXBfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVfMS5vbmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5vbmRhdGEobnVsbCwgZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHIgPSBfdGhpcy5vW2NtcF8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5vbmRhdGEoZXJyKDE0LCAndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjbXBfMSwgMSksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMSA9IHNjXzEgPCAwID8gbmV3IGN0cihmbl8xKSA6IG5ldyBjdHIoZm5fMSwgc2NfMSwgc3VfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEub25kYXRhID0gZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkgeyBmaWxlXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfNCA9IGNoa3NfMzsgX2kgPCBjaGtzXzQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdCA9IGNoa3NfNFtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnB1c2goZGF0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMua1swXSA9PSBjaGtzXzMgJiYgX3RoaXMuYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kID0gZF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkXzEgJiYgZF8xLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjXzEgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlXzEuc2l6ZSA9IHNjXzEsIGZpbGVfMS5vcmlnaW5hbFNpemUgPSBzdV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLm9uZmlsZShmaWxlXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWcgPT0gMHg4MDc0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgKz0gMTIgKyAob2MgPT0gLTIgJiYgOCksIGYgPSAzLCB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZyA9PSAweDIwMTRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzID0gaSAtPSA0LCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbCAtIDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMigpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wID0gZXQ7XG4gICAgICAgICAgICBpZiAob2MgPCAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdCA9IGYgPyBidWYuc3ViYXJyYXkoMCwgaXMgLSAxMiAtIChvYyA9PSAtMiAmJiA4KSAtIChiNChidWYsIGlzIC0gMTYpID09IDB4ODA3NEI1MCAmJiA0KSkgOiBidWYuc3ViYXJyYXkoMCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZClcbiAgICAgICAgICAgICAgICAgICAgYWRkLnB1c2goZGF0LCAhIWYpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rWysoZiA9PSAyKV0ucHVzaChkYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGYgJiAyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2goYnVmLnN1YmFycmF5KGkpLCBmaW5hbCk7XG4gICAgICAgICAgICB0aGlzLnAgPSBidWYuc3ViYXJyYXkoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jKVxuICAgICAgICAgICAgICAgIGVycigxMyk7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBkZWNvZGVyIHdpdGggdGhlIHN0cmVhbSwgYWxsb3dpbmcgZm9yIGZpbGVzIGNvbXByZXNzZWQgd2l0aFxuICAgICAqIHRoZSBjb21wcmVzc2lvbiB0eXBlIHByb3ZpZGVkIHRvIGJlIGV4cGFuZGVkIGNvcnJlY3RseVxuICAgICAqIEBwYXJhbSBkZWNvZGVyIFRoZSBkZWNvZGVyIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5vW2RlY29kZXIuY29tcHJlc3Npb25dID0gZGVjb2RlcjtcbiAgICB9O1xuICAgIHJldHVybiBVbnppcDtcbn0oKSk7XG5leHBvcnRzLlVuemlwID0gVW56aXA7XG52YXIgbXQgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrIDogdHlwZW9mIHNldFRpbWVvdXQgPT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiBmdW5jdGlvbiAoZm4pIHsgZm4oKTsgfTtcbmZ1bmN0aW9uIHVuemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgdmFyIHRlcm0gPSBbXTtcbiAgICB2YXIgdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGVybVtpXSgpO1xuICAgIH07XG4gICAgdmFyIGZpbGVzID0ge307XG4gICAgdmFyIGNiZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIG10KGZ1bmN0aW9uICgpIHsgY2IoYSwgYik7IH0pO1xuICAgIH07XG4gICAgbXQoZnVuY3Rpb24gKCkgeyBjYmQgPSBjYjsgfSk7XG4gICAgdmFyIGUgPSBkYXRhLmxlbmd0aCAtIDIyO1xuICAgIGZvciAoOyBiNChkYXRhLCBlKSAhPSAweDYwNTRCNTA7IC0tZSkge1xuICAgICAgICBpZiAoIWUgfHwgZGF0YS5sZW5ndGggLSBlID4gNjU1NTgpIHtcbiAgICAgICAgICAgIGNiZChlcnIoMTMsIDAsIDEpLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0QWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICB2YXIgbGZ0ID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmIChsZnQpIHtcbiAgICAgICAgdmFyIGMgPSBsZnQ7XG4gICAgICAgIHZhciBvID0gYjQoZGF0YSwgZSArIDE2KTtcbiAgICAgICAgdmFyIHogPSBvID09IDQyOTQ5NjcyOTUgfHwgYyA9PSA2NTUzNTtcbiAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICAgIHZhciB6ZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgICAgICB6ID0gYjQoZGF0YSwgemUpID09IDB4NjA2NEI1MDtcbiAgICAgICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgYyA9IGxmdCA9IGI0KGRhdGEsIHplICsgMzIpO1xuICAgICAgICAgICAgICAgIG8gPSBiNChkYXRhLCB6ZSArIDQ4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZmx0ciA9IG9wdHMgJiYgb3B0cy5maWx0ZXI7XG4gICAgICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHpoKGRhdGEsIG8sIHopLCBjXzEgPSBfYVswXSwgc2MgPSBfYVsxXSwgc3UgPSBfYVsyXSwgZm4gPSBfYVszXSwgbm8gPSBfYVs0XSwgb2ZmID0gX2FbNV0sIGIgPSBzbHpoKGRhdGEsIG9mZik7XG4gICAgICAgICAgICBvID0gbm87XG4gICAgICAgICAgICB2YXIgY2JsID0gZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGNiZChlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNbZm5dID0gZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiZChudWxsLCBmaWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghZmx0ciB8fCBmbHRyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBmbixcbiAgICAgICAgICAgICAgICBzaXplOiBzYyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFNpemU6IHN1LFxuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjXzFcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjXzEpXG4gICAgICAgICAgICAgICAgICAgIGNibChudWxsLCBzbGMoZGF0YSwgYiwgYiArIHNjKSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY18xID09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZmwgPSBkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN5bmNocm9ub3VzbHkgZGVjb21wcmVzcyB1bmRlciA1MTJLQiwgb3IgYmFyZWx5LWNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3UgPCA1MjQyODggfHwgc2MgPiAwLjggKiBzdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgaW5mbGF0ZVN5bmMoaW5mbCwgeyBvdXQ6IG5ldyB1OChzdSkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYmwoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybS5wdXNoKGluZmxhdGUoaW5mbCwgeyBzaXplOiBzdSB9LCBjYmwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjYmwoZXJyKDE0LCAndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjXzEsIDEpLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYmwobnVsbCwgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgKytpKSB7XG4gICAgICAgICAgICBfbG9vcF8zKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgY2JkKG51bGwsIHt9KTtcbiAgICByZXR1cm4gdEFsbDtcbn1cbmV4cG9ydHMudW56aXAgPSB1bnppcDtcbi8qKlxuICogU3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZS4gUHJlZmVyIHVzaW5nIGB1bnppcGAgZm9yIGJldHRlclxuICogcGVyZm9ybWFuY2Ugd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgcmF3IGNvbXByZXNzZWQgWklQIGZpbGVcbiAqIEBwYXJhbSBvcHRzIFRoZSBaSVAgZXh0cmFjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIGZpbGVzXG4gKi9cbmZ1bmN0aW9uIHVuemlwU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgdmFyIGZpbGVzID0ge307XG4gICAgdmFyIGUgPSBkYXRhLmxlbmd0aCAtIDIyO1xuICAgIGZvciAoOyBiNChkYXRhLCBlKSAhPSAweDYwNTRCNTA7IC0tZSkge1xuICAgICAgICBpZiAoIWUgfHwgZGF0YS5sZW5ndGggLSBlID4gNjU1NTgpXG4gICAgICAgICAgICBlcnIoMTMpO1xuICAgIH1cbiAgICA7XG4gICAgdmFyIGMgPSBiMihkYXRhLCBlICsgOCk7XG4gICAgaWYgKCFjKVxuICAgICAgICByZXR1cm4ge307XG4gICAgdmFyIG8gPSBiNChkYXRhLCBlICsgMTYpO1xuICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1IHx8IGMgPT0gNjU1MzU7XG4gICAgaWYgKHopIHtcbiAgICAgICAgdmFyIHplID0gYjQoZGF0YSwgZSAtIDEyKTtcbiAgICAgICAgeiA9IGI0KGRhdGEsIHplKSA9PSAweDYwNjRCNTA7XG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICBjID0gYjQoZGF0YSwgemUgKyAzMik7XG4gICAgICAgICAgICBvID0gYjQoZGF0YSwgemUgKyA0OCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZsdHIgPSBvcHRzICYmIG9wdHMuZmlsdGVyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgKytpKSB7XG4gICAgICAgIHZhciBfYSA9IHpoKGRhdGEsIG8sIHopLCBjXzIgPSBfYVswXSwgc2MgPSBfYVsxXSwgc3UgPSBfYVsyXSwgZm4gPSBfYVszXSwgbm8gPSBfYVs0XSwgb2ZmID0gX2FbNV0sIGIgPSBzbHpoKGRhdGEsIG9mZik7XG4gICAgICAgIG8gPSBubztcbiAgICAgICAgaWYgKCFmbHRyIHx8IGZsdHIoe1xuICAgICAgICAgICAgbmFtZTogZm4sXG4gICAgICAgICAgICBzaXplOiBzYyxcbiAgICAgICAgICAgIG9yaWdpbmFsU2l6ZTogc3UsXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogY18yXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICBpZiAoIWNfMilcbiAgICAgICAgICAgICAgICBmaWxlc1tmbl0gPSBzbGMoZGF0YSwgYiwgYiArIHNjKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNfMiA9PSA4KVxuICAgICAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGluZmxhdGVTeW5jKGRhdGEuc3ViYXJyYXkoYiwgYiArIHNjKSwgeyBvdXQ6IG5ldyB1OChzdSkgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZXJyKDE0LCAndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjXzIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWxlcztcbn1cbmV4cG9ydHMudW56aXBTeW5jID0gdW56aXBTeW5jO1xuIl0sIm5hbWVzIjpbIldvcmtlciIsIndvcmtlckFkZCIsInJlcXVpcmUiLCJlIiwibm9kZV93b3JrZXJfMSIsImMiLCJfIiwibXNnIiwidHJhbnNmZXIiLCJjYiIsImRvbmUiLCJ3IiwiZXZhbCIsIm9uIiwibSIsIkVycm9yIiwicG9zdE1lc3NhZ2UiLCJ0ZXJtaW5hdGUiLCJwcm90b3R5cGUiLCJjYWxsIiwiX18iLCJfX18iLCJfX19fIiwic2V0SW1tZWRpYXRlIiwiTk9QIiwidTgiLCJVaW50OEFycmF5IiwidTE2IiwiVWludDE2QXJyYXkiLCJpMzIiLCJJbnQzMkFycmF5IiwiZmxlYiIsImZkZWIiLCJjbGltIiwiZnJlYiIsImViIiwic3RhcnQiLCJiIiwiaSIsInIiLCJqIiwiX2EiLCJmbCIsInJldmZsIiwiX2IiLCJmZCIsInJldmZkIiwicmV2IiwieCIsImhNYXAiLCJjZCIsIm1iIiwicyIsImxlbmd0aCIsImwiLCJsZSIsImNvIiwicnZiIiwic3YiLCJyXzEiLCJ2IiwiZmx0IiwiZmR0IiwiZmxtIiwiZmxybSIsImZkbSIsImZkcm0iLCJtYXgiLCJhIiwiYml0cyIsImQiLCJwIiwibyIsImJpdHMxNiIsInNoZnQiLCJzbGMiLCJzdWJhcnJheSIsImV4cG9ydHMiLCJGbGF0ZUVycm9yQ29kZSIsIlVuZXhwZWN0ZWRFT0YiLCJJbnZhbGlkQmxvY2tUeXBlIiwiSW52YWxpZExlbmd0aExpdGVyYWwiLCJJbnZhbGlkRGlzdGFuY2UiLCJTdHJlYW1GaW5pc2hlZCIsIk5vU3RyZWFtSGFuZGxlciIsIkludmFsaWRIZWFkZXIiLCJOb0NhbGxiYWNrIiwiSW52YWxpZFVURjgiLCJFeHRyYUZpZWxkVG9vTG9uZyIsIkludmFsaWREYXRlIiwiRmlsZW5hbWVUb29Mb25nIiwiU3RyZWFtRmluaXNoaW5nIiwiSW52YWxpZFppcERhdGEiLCJVbmtub3duQ29tcHJlc3Npb25NZXRob2QiLCJlYyIsImVyciIsImluZCIsIm50IiwiY29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiaW5mbHQiLCJkYXQiLCJzdCIsImJ1ZiIsImRpY3QiLCJzbCIsImRsIiwiZiIsIm5vQnVmIiwicmVzaXplIiwibm9TdCIsImNidWYiLCJibCIsIm5idWYiLCJNYXRoIiwic2V0IiwiZmluYWwiLCJwb3MiLCJidCIsImxtIiwiZG0iLCJsYnQiLCJkYnQiLCJuIiwidGJ0cyIsInR5cGUiLCJ0IiwiaExpdCIsImhjTGVuIiwidGwiLCJsZHQiLCJjbHQiLCJjbGIiLCJjbGJtc2siLCJjbG0iLCJsdCIsImR0IiwibG1zIiwiZG1zIiwibHBvcyIsInN5bSIsImFkZCIsImRzeW0iLCJlbmQiLCJzaGlmdCIsImRlbmQiLCJtaW4iLCJ3Yml0cyIsIndiaXRzMTYiLCJoVHJlZSIsInB1c2giLCJ0MiIsInNsaWNlIiwiZXQiLCJzb3J0IiwiaTAiLCJpMSIsImkyIiwibWF4U3ltIiwidHIiLCJtYnQiLCJsbiIsImxmdCIsImNzdCIsImkyXzEiLCJpMl8yIiwiaTJfMyIsImxjIiwiY2wiLCJjbGkiLCJjbG4iLCJjbHMiLCJjbGVuIiwiY2YiLCJ3ZmJsayIsIm91dCIsIndibGsiLCJzeW1zIiwibGYiLCJkZiIsImxpIiwiYnMiLCJkbHQiLCJtbGIiLCJkZHQiLCJtZGIiLCJfYyIsImxjbHQiLCJubGMiLCJfZCIsImxjZHQiLCJuZGMiLCJsY2ZyZXEiLCJfZSIsImxjdCIsIm1sY2IiLCJubGNjIiwiZmxlbiIsImZ0bGVuIiwiZHRsZW4iLCJsbCIsImxsbSIsImxjdHMiLCJpdCIsImNsY3QiLCJsZW4iLCJkc3QiLCJkZW8iLCJkZmx0IiwibHZsIiwicGx2bCIsInByZSIsInBvc3QiLCJ6IiwiY2VpbCIsImxzdCIsIm9wdCIsIm1za18xIiwicHJldiIsImhlYWQiLCJoIiwiYnMxXzEiLCJiczJfMSIsImhzaCIsImxjXzEiLCJ3aSIsImh2IiwiaW1vZCIsInBpbW9kIiwicmVtIiwiY2hfMSIsImRpZiIsIm1heG4iLCJtYXhkIiwibWwiLCJubCIsIm1tZCIsIm1kIiwidGkiLCJwdGkiLCJsaW4iLCJkaW4iLCJjcmN0IiwiayIsImNyYyIsImNyIiwiYWRsZXIiLCJkb3B0IiwiZGljdGlvbmFyeSIsIm5ld0RhdCIsImxldmVsIiwibWVtIiwibG9nIiwibXJnIiwid2NsbiIsImZuIiwiZm5TdHIiLCJ0ZCIsInRvU3RyaW5nIiwia3MiLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJyZXBsYWNlIiwic3BsaXQiLCJzdF8xIiwic3BJbmQiLCJjaCIsImNiZnMiLCJidWZmZXIiLCJjb25zdHJ1Y3RvciIsIndya3IiLCJmbnMiLCJpbml0IiwiaWQiLCJ0ZF8xIiwiZGVmYXVsdCIsImJJbmZsdCIsImluZmxhdGVTeW5jIiwicGJmIiwiZ29wdCIsImJEZmx0IiwiZGVmbGF0ZVN5bmMiLCJnemUiLCJnemgiLCJnemhsIiwid2J5dGVzIiwiZ3V6ZSIsImd6cyIsImd6bCIsInpsZSIsInpsaCIsInp1bGUiLCJ6bHMiLCJzaXplIiwiY2JpZnkiLCJvcHRzIiwiY29uc3VtZSIsImFzdHJtIiwic3RybSIsIm9uZGF0YSIsImV2IiwiZGF0YSIsImZsdXNoIiwiYXN0cm1pZnkiLCJleHQiLCJBcnJheSIsImlzQXJyYXkiLCJxdWV1ZWRTaXplIiwib25kcmFpbiIsImIyIiwiYjQiLCJiOCIsImZpbGVuYW1lIiwibXRpbWUiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJjaGFyQ29kZUF0IiwiZmxnIiwienMiLCJsdiIsIlN0cm1PcHQiLCJEZWZsYXRlIiwiY2h1bmsiLCJlbmRMZW4iLCJuZXdCdWYiLCJBc3luY0RlZmxhdGUiLCJvbm1lc3NhZ2UiLCJkZWZsYXRlIiwiSW5mbGF0ZSIsImJ0cyIsIkFzeW5jSW5mbGF0ZSIsImluZmxhdGUiLCJHemlwIiwicmF3IiwiQ29tcHJlc3MiLCJBc3luY0d6aXAiLCJBc3luY0NvbXByZXNzIiwiZ3ppcCIsImd6aXBTeW5jIiwiY29tcHJlc3MiLCJjb21wcmVzc1N5bmMiLCJHdW56aXAiLCJvbm1lbWJlciIsIkFzeW5jR3VuemlwIiwiX3RoaXMiLCJvZmZzZXQiLCJndW56aXAiLCJndW56aXBTeW5jIiwiWmxpYiIsIkFzeW5jWmxpYiIsInpsaWIiLCJ6bGliU3luYyIsIlVuemxpYiIsIkFzeW5jVW56bGliIiwidW56bGliIiwidW56bGliU3luYyIsIkRlY29tcHJlc3MiLCJHIiwiSSIsIloiLCJBc3luY0RlY29tcHJlc3MiLCJkZWNvbXByZXNzIiwiZGVjb21wcmVzc1N5bmMiLCJmbHRuIiwidmFsIiwib3AiLCJ0ZSIsIlRleHRFbmNvZGVyIiwiVGV4dERlY29kZXIiLCJ0ZHMiLCJkZWNvZGUiLCJzdHJlYW0iLCJkdXRmOCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkRlY29kZVVURjgiLCJFbmNvZGVVVEY4Iiwic3RyVG9VOCIsInN0ciIsImxhdGluMSIsImFyXzEiLCJlbmNvZGUiLCJhciIsImFpIiwic3RyRnJvbVU4IiwiYXBwbHkiLCJkYmYiLCJzbHpoIiwiemgiLCJmbmwiLCJlcyIsIno2NGUiLCJzYyIsInN1Iiwib2ZmIiwiZXhmbCIsImV4Iiwid3poIiwidSIsImNlIiwiZXh0cmEiLCJjb2wiLCJleGwiLCJvcyIsImZsYWciLCJjb21wcmVzc2lvbiIsInkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJhdHRycyIsImV4ZiIsInd6ZiIsIlppcFBhc3NUaHJvdWdoIiwicHJvY2VzcyIsIlppcERlZmxhdGUiLCJBc3luY1ppcERlZmxhdGUiLCJaaXAiLCJmaWxlIiwiZmxfMSIsImNvbSIsImNvbW1lbnQiLCJobF8xIiwiaGVhZGVyIiwiY2hrc18xIiwicEFsbF8xIiwiX2kiLCJjaGtzXzIiLCJjaGsiLCJ0cl8xIiwiaW5kXzEiLCJ1Zl8xIiwibnh0IiwiY2xfMSIsImRkIiwic3BsaWNlIiwiemlwIiwiT2JqZWN0Iiwia2V5cyIsInRvdCIsInNsZnQiLCJmaWxlcyIsInRlcm0iLCJ0QWxsIiwiY2JkIiwibXQiLCJjYmYiLCJvZSIsImNkbCIsImJhZGQiLCJsb2MiLCJfbG9vcF8xIiwibXMiLCJjYmwiLCJ6aXBTeW5jIiwiVW56aXBQYXNzVGhyb3VnaCIsIlVuemlwSW5mbGF0ZSIsIkFzeW5jVW56aXBJbmZsYXRlIiwic3oiLCJVbnppcCIsIm9uZmlsZSIsInRvQWRkIiwiaXMiLCJvYyIsIl9sb29wXzIiLCJzaWciLCJ0aGlzXzEiLCJiZiIsImNtcF8xIiwiY2hrc18zIiwidW5zaGlmdCIsInNjXzEiLCJzdV8xIiwiZm5fMSIsImRfMSIsImZpbGVfMSIsIm5hbWUiLCJjdHIiLCJjaGtzXzQiLCJvcmlnaW5hbFNpemUiLCJzdGF0ZV8xIiwicmVnaXN0ZXIiLCJkZWNvZGVyIiwicXVldWVNaWNyb3Rhc2siLCJzZXRUaW1lb3V0IiwidW56aXAiLCJ6ZSIsImZsdHIiLCJmaWx0ZXIiLCJfbG9vcF8zIiwiY18xIiwibm8iLCJpbmZsIiwidW56aXBTeW5jIiwiY18yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fflate/lib/node.cjs\n");

/***/ })

};
;