"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dompurify";
exports.ids = ["vendor-chunks/dompurify"];
exports.modules = {

/***/ "(ssr)/./node_modules/dompurify/dist/purify.cjs.js":
/*!***************************************************!*\
  !*** ./node_modules/dompurify/dist/purify.cjs.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */ \nconst { entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== \"undefined\" && Reflect;\nif (!freeze) {\n    freeze = function freeze(x) {\n        return x;\n    };\n}\nif (!seal) {\n    seal = function seal(x) {\n        return x;\n    };\n}\nif (!apply) {\n    apply = function apply(func, thisArg) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        return func.apply(thisArg, args);\n    };\n}\nif (!construct) {\n    construct = function construct(Func) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        return new Func(...args);\n    };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySplice = unapply(Array.prototype.splice);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */ function unapply(func) {\n    return function(thisArg) {\n        if (thisArg instanceof RegExp) {\n            thisArg.lastIndex = 0;\n        }\n        for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){\n            args[_key3 - 1] = arguments[_key3];\n        }\n        return apply(func, thisArg, args);\n    };\n}\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */ function unconstruct(Func) {\n    return function() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return construct(Func, args);\n    };\n}\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */ function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n    if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while(l--){\n        let element = array[l];\n        if (typeof element === \"string\") {\n            const lcElement = transformCaseFunc(element);\n            if (lcElement !== element) {\n                // Config presets (e.g. tags.js, attrs.js) are immutable.\n                if (!isFrozen(array)) {\n                    array[l] = lcElement;\n                }\n                element = lcElement;\n            }\n        }\n        set[element] = true;\n    }\n    return set;\n}\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */ function cleanArray(array) {\n    for(let index = 0; index < array.length; index++){\n        const isPropertyExist = objectHasOwnProperty(array, index);\n        if (!isPropertyExist) {\n            array[index] = null;\n        }\n    }\n    return array;\n}\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */ function clone(object) {\n    const newObject = create(null);\n    for (const [property, value] of entries(object)){\n        const isPropertyExist = objectHasOwnProperty(object, property);\n        if (isPropertyExist) {\n            if (Array.isArray(value)) {\n                newObject[property] = cleanArray(value);\n            } else if (value && typeof value === \"object\" && value.constructor === Object) {\n                newObject[property] = clone(value);\n            } else {\n                newObject[property] = value;\n            }\n        }\n    }\n    return newObject;\n}\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */ function lookupGetter(object, prop) {\n    while(object !== null){\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n            if (desc.get) {\n                return unapply(desc.get);\n            }\n            if (typeof desc.value === \"function\") {\n                return unapply(desc.value);\n            }\n        }\n        object = getPrototypeOf(object);\n    }\n    function fallbackValue() {\n        return null;\n    }\n    return fallbackValue;\n}\nconst html$1 = freeze([\n    \"a\",\n    \"abbr\",\n    \"acronym\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blink\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"center\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"content\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"decorator\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"element\",\n    \"em\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"font\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meter\",\n    \"nav\",\n    \"nobr\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"search\",\n    \"section\",\n    \"select\",\n    \"shadow\",\n    \"slot\",\n    \"small\",\n    \"source\",\n    \"spacer\",\n    \"span\",\n    \"strike\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"tt\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\"\n]);\nconst svg$1 = freeze([\n    \"svg\",\n    \"a\",\n    \"altglyph\",\n    \"altglyphdef\",\n    \"altglyphitem\",\n    \"animatecolor\",\n    \"animatemotion\",\n    \"animatetransform\",\n    \"circle\",\n    \"clippath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"enterkeyhint\",\n    \"exportparts\",\n    \"filter\",\n    \"font\",\n    \"g\",\n    \"glyph\",\n    \"glyphref\",\n    \"hkern\",\n    \"image\",\n    \"inputmode\",\n    \"line\",\n    \"lineargradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"mpath\",\n    \"part\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialgradient\",\n    \"rect\",\n    \"stop\",\n    \"style\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textpath\",\n    \"title\",\n    \"tref\",\n    \"tspan\",\n    \"view\",\n    \"vkern\"\n]);\nconst svgFilters = freeze([\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\"\n]);\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze([\n    \"animate\",\n    \"color-profile\",\n    \"cursor\",\n    \"discard\",\n    \"font-face\",\n    \"font-face-format\",\n    \"font-face-name\",\n    \"font-face-src\",\n    \"font-face-uri\",\n    \"foreignobject\",\n    \"hatch\",\n    \"hatchpath\",\n    \"mesh\",\n    \"meshgradient\",\n    \"meshpatch\",\n    \"meshrow\",\n    \"missing-glyph\",\n    \"script\",\n    \"set\",\n    \"solidcolor\",\n    \"unknown\",\n    \"use\"\n]);\nconst mathMl$1 = freeze([\n    \"math\",\n    \"menclose\",\n    \"merror\",\n    \"mfenced\",\n    \"mfrac\",\n    \"mglyph\",\n    \"mi\",\n    \"mlabeledtr\",\n    \"mmultiscripts\",\n    \"mn\",\n    \"mo\",\n    \"mover\",\n    \"mpadded\",\n    \"mphantom\",\n    \"mroot\",\n    \"mrow\",\n    \"ms\",\n    \"mspace\",\n    \"msqrt\",\n    \"mstyle\",\n    \"msub\",\n    \"msup\",\n    \"msubsup\",\n    \"mtable\",\n    \"mtd\",\n    \"mtext\",\n    \"mtr\",\n    \"munder\",\n    \"munderover\",\n    \"mprescripts\"\n]);\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze([\n    \"maction\",\n    \"maligngroup\",\n    \"malignmark\",\n    \"mlongdiv\",\n    \"mscarries\",\n    \"mscarry\",\n    \"msgroup\",\n    \"mstack\",\n    \"msline\",\n    \"msrow\",\n    \"semantics\",\n    \"annotation\",\n    \"annotation-xml\",\n    \"mprescripts\",\n    \"none\"\n]);\nconst text = freeze([\n    \"#text\"\n]);\nconst html = freeze([\n    \"accept\",\n    \"action\",\n    \"align\",\n    \"alt\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autopictureinpicture\",\n    \"autoplay\",\n    \"background\",\n    \"bgcolor\",\n    \"border\",\n    \"capture\",\n    \"cellpadding\",\n    \"cellspacing\",\n    \"checked\",\n    \"cite\",\n    \"class\",\n    \"clear\",\n    \"color\",\n    \"cols\",\n    \"colspan\",\n    \"controls\",\n    \"controlslist\",\n    \"coords\",\n    \"crossorigin\",\n    \"datetime\",\n    \"decoding\",\n    \"default\",\n    \"dir\",\n    \"disabled\",\n    \"disablepictureinpicture\",\n    \"disableremoteplayback\",\n    \"download\",\n    \"draggable\",\n    \"enctype\",\n    \"enterkeyhint\",\n    \"exportparts\",\n    \"face\",\n    \"for\",\n    \"headers\",\n    \"height\",\n    \"hidden\",\n    \"high\",\n    \"href\",\n    \"hreflang\",\n    \"id\",\n    \"inert\",\n    \"inputmode\",\n    \"integrity\",\n    \"ismap\",\n    \"kind\",\n    \"label\",\n    \"lang\",\n    \"list\",\n    \"loading\",\n    \"loop\",\n    \"low\",\n    \"max\",\n    \"maxlength\",\n    \"media\",\n    \"method\",\n    \"min\",\n    \"minlength\",\n    \"multiple\",\n    \"muted\",\n    \"name\",\n    \"nonce\",\n    \"noshade\",\n    \"novalidate\",\n    \"nowrap\",\n    \"open\",\n    \"optimum\",\n    \"part\",\n    \"pattern\",\n    \"placeholder\",\n    \"playsinline\",\n    \"popover\",\n    \"popovertarget\",\n    \"popovertargetaction\",\n    \"poster\",\n    \"preload\",\n    \"pubdate\",\n    \"radiogroup\",\n    \"readonly\",\n    \"rel\",\n    \"required\",\n    \"rev\",\n    \"reversed\",\n    \"role\",\n    \"rows\",\n    \"rowspan\",\n    \"spellcheck\",\n    \"scope\",\n    \"selected\",\n    \"shape\",\n    \"size\",\n    \"sizes\",\n    \"slot\",\n    \"span\",\n    \"srclang\",\n    \"start\",\n    \"src\",\n    \"srcset\",\n    \"step\",\n    \"style\",\n    \"summary\",\n    \"tabindex\",\n    \"title\",\n    \"translate\",\n    \"type\",\n    \"usemap\",\n    \"valign\",\n    \"value\",\n    \"width\",\n    \"wrap\",\n    \"xmlns\",\n    \"slot\"\n]);\nconst svg = freeze([\n    \"accent-height\",\n    \"accumulate\",\n    \"additive\",\n    \"alignment-baseline\",\n    \"amplitude\",\n    \"ascent\",\n    \"attributename\",\n    \"attributetype\",\n    \"azimuth\",\n    \"basefrequency\",\n    \"baseline-shift\",\n    \"begin\",\n    \"bias\",\n    \"by\",\n    \"class\",\n    \"clip\",\n    \"clippathunits\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"color\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"color-profile\",\n    \"color-rendering\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"dx\",\n    \"dy\",\n    \"diffuseconstant\",\n    \"direction\",\n    \"display\",\n    \"divisor\",\n    \"dur\",\n    \"edgemode\",\n    \"elevation\",\n    \"end\",\n    \"exponent\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"filter\",\n    \"filterunits\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"font-family\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-variant\",\n    \"font-weight\",\n    \"fx\",\n    \"fy\",\n    \"g1\",\n    \"g2\",\n    \"glyph-name\",\n    \"glyphref\",\n    \"gradientunits\",\n    \"gradienttransform\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"image-rendering\",\n    \"in\",\n    \"in2\",\n    \"intercept\",\n    \"k\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kerning\",\n    \"keypoints\",\n    \"keysplines\",\n    \"keytimes\",\n    \"lang\",\n    \"lengthadjust\",\n    \"letter-spacing\",\n    \"kernelmatrix\",\n    \"kernelunitlength\",\n    \"lighting-color\",\n    \"local\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-start\",\n    \"markerheight\",\n    \"markerunits\",\n    \"markerwidth\",\n    \"maskcontentunits\",\n    \"maskunits\",\n    \"max\",\n    \"mask\",\n    \"mask-type\",\n    \"media\",\n    \"method\",\n    \"mode\",\n    \"min\",\n    \"name\",\n    \"numoctaves\",\n    \"offset\",\n    \"operator\",\n    \"opacity\",\n    \"order\",\n    \"orient\",\n    \"orientation\",\n    \"origin\",\n    \"overflow\",\n    \"paint-order\",\n    \"path\",\n    \"pathlength\",\n    \"patterncontentunits\",\n    \"patterntransform\",\n    \"patternunits\",\n    \"points\",\n    \"preservealpha\",\n    \"preserveaspectratio\",\n    \"primitiveunits\",\n    \"r\",\n    \"rx\",\n    \"ry\",\n    \"radius\",\n    \"refx\",\n    \"refy\",\n    \"repeatcount\",\n    \"repeatdur\",\n    \"restart\",\n    \"result\",\n    \"rotate\",\n    \"scale\",\n    \"seed\",\n    \"shape-rendering\",\n    \"slope\",\n    \"specularconstant\",\n    \"specularexponent\",\n    \"spreadmethod\",\n    \"startoffset\",\n    \"stddeviation\",\n    \"stitchtiles\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke\",\n    \"stroke-width\",\n    \"style\",\n    \"surfacescale\",\n    \"systemlanguage\",\n    \"tabindex\",\n    \"tablevalues\",\n    \"targetx\",\n    \"targety\",\n    \"transform\",\n    \"transform-origin\",\n    \"text-anchor\",\n    \"text-decoration\",\n    \"text-rendering\",\n    \"textlength\",\n    \"type\",\n    \"u1\",\n    \"u2\",\n    \"unicode\",\n    \"values\",\n    \"viewbox\",\n    \"visibility\",\n    \"version\",\n    \"vert-adv-y\",\n    \"vert-origin-x\",\n    \"vert-origin-y\",\n    \"width\",\n    \"word-spacing\",\n    \"wrap\",\n    \"writing-mode\",\n    \"xchannelselector\",\n    \"ychannelselector\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xmlns\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"z\",\n    \"zoomandpan\"\n]);\nconst mathMl = freeze([\n    \"accent\",\n    \"accentunder\",\n    \"align\",\n    \"bevelled\",\n    \"close\",\n    \"columnsalign\",\n    \"columnlines\",\n    \"columnspan\",\n    \"denomalign\",\n    \"depth\",\n    \"dir\",\n    \"display\",\n    \"displaystyle\",\n    \"encoding\",\n    \"fence\",\n    \"frame\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"largeop\",\n    \"length\",\n    \"linethickness\",\n    \"lspace\",\n    \"lquote\",\n    \"mathbackground\",\n    \"mathcolor\",\n    \"mathsize\",\n    \"mathvariant\",\n    \"maxsize\",\n    \"minsize\",\n    \"movablelimits\",\n    \"notation\",\n    \"numalign\",\n    \"open\",\n    \"rowalign\",\n    \"rowlines\",\n    \"rowspacing\",\n    \"rowspan\",\n    \"rspace\",\n    \"rquote\",\n    \"scriptlevel\",\n    \"scriptminsize\",\n    \"scriptsizemultiplier\",\n    \"selection\",\n    \"separator\",\n    \"separators\",\n    \"stretchy\",\n    \"subscriptshift\",\n    \"supscriptshift\",\n    \"symmetric\",\n    \"voffset\",\n    \"width\",\n    \"xmlns\"\n]);\nconst xml = freeze([\n    \"xlink:href\",\n    \"xml:id\",\n    \"xlink:title\",\n    \"xml:space\",\n    \"xmlns:xlink\"\n]);\n// eslint-disable-next-line unicorn/better-regex\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nconst CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\nvar EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ARIA_ATTR: ARIA_ATTR,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n    DATA_ATTR: DATA_ATTR,\n    DOCTYPE_NAME: DOCTYPE_NAME,\n    ERB_EXPR: ERB_EXPR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR\n});\n/* eslint-disable @typescript-eslint/indent */ // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n    element: 1,\n    attribute: 2,\n    text: 3,\n    cdataSection: 4,\n    entityReference: 5,\n    // Deprecated\n    entityNode: 6,\n    // Deprecated\n    progressingInstruction: 7,\n    comment: 8,\n    document: 9,\n    documentType: 10,\n    documentFragment: 11,\n    notation: 12 // Deprecated\n};\nconst getGlobal = function getGlobal() {\n    return  true ? null : 0;\n};\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") {\n        return null;\n    }\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = \"data-tt-policy-suffix\";\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n    try {\n        return trustedTypes.createPolicy(policyName, {\n            createHTML (html) {\n                return html;\n            },\n            createScriptURL (scriptUrl) {\n                return scriptUrl;\n            }\n        });\n    } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n        return null;\n    }\n};\nconst _createHooksMap = function _createHooksMap() {\n    return {\n        afterSanitizeAttributes: [],\n        afterSanitizeElements: [],\n        afterSanitizeShadowDOM: [],\n        beforeSanitizeAttributes: [],\n        beforeSanitizeElements: [],\n        beforeSanitizeShadowDOM: [],\n        uponSanitizeAttribute: [],\n        uponSanitizeElement: [],\n        uponSanitizeShadowNode: []\n    };\n};\nfunction createDOMPurify() {\n    let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = (root)=>createDOMPurify(root);\n    DOMPurify.version = \"3.3.0\";\n    DOMPurify.removed = [];\n    if (!window1 || !window1.document || window1.document.nodeType !== NODE_TYPE.document || !window1.Element) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n    }\n    let { document } = window1;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const { DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes } = window1;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n    const remove = lookupGetter(ElementPrototype, \"remove\");\n    const getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n    const getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n    const getParentNode = lookupGetter(ElementPrototype, \"parentNode\");\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === \"function\") {\n        const template = document.createElement(\"template\");\n        if (template.content && template.content.ownerDocument) {\n            document = template.content.ownerDocument;\n        }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = \"\";\n    const { implementation, createNodeIterator, createDocumentFragment, getElementsByTagName } = document;\n    const { importNode } = originalDocument;\n    let hooks = _createHooksMap();\n    /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */ DOMPurify.isSupported = typeof entries === \"function\" && typeof getParentNode === \"function\" && implementation && implementation.createHTMLDocument !== undefined;\n    const { MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, CUSTOM_ELEMENT } = EXPRESSIONS;\n    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n    /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */ /* allowed element names */ let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n    ]);\n    /* Allowed attribute names */ let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n    ]);\n    /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        allowCustomizedBuiltInElements: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: false\n        }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n    /* Config object to store ADD_TAGS/ADD_ATTR functions (when used as functions) */ const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        }\n    }));\n    /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */ let SAFE_FOR_TEMPLATES = false;\n    /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */ let SAFE_FOR_XML = true;\n    /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */ let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */ let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */ let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = \"user-content-\";\n    /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        \"annotation-xml\",\n        \"audio\",\n        \"colgroup\",\n        \"desc\",\n        \"foreignobject\",\n        \"head\",\n        \"iframe\",\n        \"math\",\n        \"mi\",\n        \"mn\",\n        \"mo\",\n        \"ms\",\n        \"mtext\",\n        \"noembed\",\n        \"noframes\",\n        \"noscript\",\n        \"plaintext\",\n        \"script\",\n        \"style\",\n        \"svg\",\n        \"template\",\n        \"thead\",\n        \"title\",\n        \"video\",\n        \"xmp\"\n    ]);\n    /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        \"audio\",\n        \"video\",\n        \"img\",\n        \"source\",\n        \"image\",\n        \"track\"\n    ]);\n    /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        \"alt\",\n        \"class\",\n        \"for\",\n        \"id\",\n        \"label\",\n        \"name\",\n        \"pattern\",\n        \"placeholder\",\n        \"role\",\n        \"summary\",\n        \"title\",\n        \"value\",\n        \"style\",\n        \"xmlns\"\n    ]);\n    const MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n    const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n    const HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n    /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n    ], stringToString);\n    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        \"mi\",\n        \"mo\",\n        \"mn\",\n        \"ms\",\n        \"mtext\"\n    ]);\n    let HTML_INTEGRATION_POINTS = addToSet({}, [\n        \"annotation-xml\"\n    ]);\n    // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        \"title\",\n        \"style\",\n        \"font\",\n        \"a\",\n        \"script\"\n    ]);\n    /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = [\n        \"application/xhtml+xml\",\n        \"text/html\"\n    ];\n    const DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n    let transformCaseFunc = null;\n    /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n    /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement(\"form\");\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */ // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (CONFIG && CONFIG === cfg) {\n            return;\n        }\n        /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== \"object\") {\n            cfg = {};\n        }\n        /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n        /* Set configuration parameters */ ALLOWED_TAGS = objectHasOwnProperty(cfg, \"ALLOWED_TAGS\") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = objectHasOwnProperty(cfg, \"ALLOWED_ATTR\") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, \"ALLOWED_NAMESPACES\") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, \"ADD_URI_SAFE_ATTR\") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = objectHasOwnProperty(cfg, \"ADD_DATA_URI_TAGS\") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = objectHasOwnProperty(cfg, \"FORBID_CONTENTS\") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = objectHasOwnProperty(cfg, \"FORBID_TAGS\") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});\n        FORBID_ATTR = objectHasOwnProperty(cfg, \"FORBID_ATTR\") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});\n        USE_PROFILES = objectHasOwnProperty(cfg, \"USE_PROFILES\") ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") {\n            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n            ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n            RETURN_DOM = true;\n        }\n        /* Parse profile info */ if (USE_PROFILES) {\n            ALLOWED_TAGS = addToSet({}, text);\n            ALLOWED_ATTR = [];\n            if (USE_PROFILES.html === true) {\n                addToSet(ALLOWED_TAGS, html$1);\n                addToSet(ALLOWED_ATTR, html);\n            }\n            if (USE_PROFILES.svg === true) {\n                addToSet(ALLOWED_TAGS, svg$1);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.svgFilters === true) {\n                addToSet(ALLOWED_TAGS, svgFilters);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.mathMl === true) {\n                addToSet(ALLOWED_TAGS, mathMl$1);\n                addToSet(ALLOWED_ATTR, mathMl);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n        }\n        /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n            if (typeof cfg.ADD_TAGS === \"function\") {\n                EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;\n            } else {\n                if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n                    ALLOWED_TAGS = clone(ALLOWED_TAGS);\n                }\n                addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n            }\n        }\n        if (cfg.ADD_ATTR) {\n            if (typeof cfg.ADD_ATTR === \"function\") {\n                EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;\n            } else {\n                if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n                    ALLOWED_ATTR = clone(ALLOWED_ATTR);\n                }\n                addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n            }\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) {\n            ALLOWED_TAGS[\"#text\"] = true;\n        }\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) {\n            addToSet(ALLOWED_TAGS, [\n                \"html\",\n                \"head\",\n                \"body\"\n            ]);\n        }\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n            addToSet(ALLOWED_TAGS, [\n                \"tbody\"\n            ]);\n            delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n            }\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n            }\n            // Overwrite existing TrustedTypes policy.\n            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n            // Sign local variables required by `sanitize`.\n            emptyHTML = trustedTypesPolicy.createHTML(\"\");\n        } else {\n            // Uninitialized policy, attempt to initialize the internal dompurify policy.\n            if (trustedTypesPolicy === undefined) {\n                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n            }\n            // If creating the internal policy succeeded sign internal variables.\n            if (trustedTypesPolicy !== null && typeof emptyHTML === \"string\") {\n                emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            }\n        }\n        // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n            freeze(cfg);\n        }\n        CONFIG = cfg;\n    };\n    /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */ const ALL_SVG_TAGS = addToSet({}, [\n        ...svg$1,\n        ...svgFilters,\n        ...svgDisallowed\n    ]);\n    const ALL_MATHML_TAGS = addToSet({}, [\n        ...mathMl$1,\n        ...mathMlDisallowed\n    ]);\n    /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */ const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n            parent = {\n                namespaceURI: NAMESPACE,\n                tagName: \"template\"\n            };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n            // The only way to switch from HTML namespace to SVG\n            // is via <svg>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"svg\";\n            }\n            // The only way to switch from MathML to SVG is via`\n            // svg if parent is either <annotation-xml> or MathML\n            // text integration points.\n            if (parent.namespaceURI === MATHML_NAMESPACE) {\n                return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n            }\n            // We only allow elements that are defined in SVG\n            // spec. All others are disallowed in SVG namespace.\n            return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n            // The only way to switch from HTML namespace to MathML\n            // is via <math>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"math\";\n            }\n            // The only way to switch from SVG to MathML is via\n            // <math> and HTML integration points\n            if (parent.namespaceURI === SVG_NAMESPACE) {\n                return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n            }\n            // We only allow elements that are defined in MathML\n            // spec. All others are disallowed in MathML namespace.\n            return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n            // The only way to switch from SVG to HTML is via\n            // HTML integration points, and from MathML to HTML\n            // is via MathML text integration points\n            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            // We disallow tags that are specific for MathML\n            // or SVG and should never appear in HTML namespace\n            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return true;\n        }\n        // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n    };\n    /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */ const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n            element: node\n        });\n        try {\n            // eslint-disable-next-line unicorn/prefer-dom-node-remove\n            getParentNode(node).removeChild(node);\n        } catch (_) {\n            remove(node);\n        }\n    };\n    /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */ const _removeAttribute = function _removeAttribute(name, element) {\n        try {\n            arrayPush(DOMPurify.removed, {\n                attribute: element.getAttributeNode(name),\n                from: element\n            });\n        } catch (_) {\n            arrayPush(DOMPurify.removed, {\n                attribute: null,\n                from: element\n            });\n        }\n        element.removeAttribute(name);\n        // We void attribute values for unremovable \"is\" attributes\n        if (name === \"is\") {\n            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n                try {\n                    _forceRemove(element);\n                } catch (_) {}\n            } else {\n                try {\n                    element.setAttribute(name, \"\");\n                } catch (_) {}\n            }\n        }\n    };\n    /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */ const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */ let doc = null;\n        let leadingWhitespace = null;\n        if (FORCE_BODY) {\n            dirty = \"<remove></remove>\" + dirty;\n        } else {\n            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n            leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) {\n            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */ if (NAMESPACE === HTML_NAMESPACE) {\n            try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n        }\n        /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n            doc = implementation.createDocument(NAMESPACE, \"template\", null);\n            try {\n                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n            } catch (_) {\n            // Syntax error if dirtyPayload is invalid xml\n            }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) {\n            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */ const _createNodeIterator = function _createNodeIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n    };\n    /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */ const _isClobbered = function _isClobbered(element) {\n        return element instanceof HTMLFormElement && (typeof element.nodeName !== \"string\" || typeof element.textContent !== \"string\" || typeof element.removeChild !== \"function\" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== \"function\" || typeof element.setAttribute !== \"function\" || typeof element.namespaceURI !== \"string\" || typeof element.insertBefore !== \"function\" || typeof element.hasChildNodes !== \"function\");\n    };\n    /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */ const _isNode = function _isNode(value) {\n        return typeof Node === \"function\" && value instanceof Node;\n    };\n    function _executeHooks(hooks, currentNode, data) {\n        arrayForEach(hooks, (hook)=>{\n            hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n    }\n    /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content = null;\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n        /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n        /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeElement, currentNode, {\n            tagName,\n            allowedTags: ALLOWED_TAGS\n        });\n        /* Detect mXSS attempts abusing namespace confusion */ if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\\w!]/g, currentNode.textContent)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any occurrence of processing instructions */ if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any kind of possibly harmful comments */ if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove element if anything forbids its presence */ if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {\n            /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n                    return false;\n                }\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n                    return false;\n                }\n            }\n            /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                if (childNodes && parentNode) {\n                    const childCount = childNodes.length;\n                    for(let i = childCount - 1; i >= 0; --i){\n                        const childClone = cloneNode(childNodes[i], true);\n                        childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                        parentNode.insertBefore(childClone, getNextSibling(currentNode));\n                    }\n                }\n            }\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n            /* Get the element's text content */ content = currentNode.textContent;\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                content = stringReplace(content, expr, \" \");\n            });\n            if (currentNode.textContent !== content) {\n                arrayPush(DOMPurify.removed, {\n                    element: currentNode.cloneNode()\n                });\n                currentNode.textContent = content;\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n        return false;\n    };\n    /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */ // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document || value in formElement)) {\n            return false;\n        }\n        /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n        else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n            if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND\n            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n            else {\n                return false;\n            }\n        /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag]) ;\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if (value) {\n            return false;\n        } else ;\n        return true;\n    };\n    /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n        return tagName !== \"annotation-xml\" && stringMatch(tagName, CUSTOM_ELEMENT);\n    };\n    /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n        const { attributes } = currentNode;\n        /* Check if we have attributes; if not we might have a text node */ if (!attributes || _isClobbered(currentNode)) {\n            return;\n        }\n        const hookEvent = {\n            attrName: \"\",\n            attrValue: \"\",\n            keepAttr: true,\n            allowedAttributes: ALLOWED_ATTR,\n            forceKeepAttr: undefined\n        };\n        let l = attributes.length;\n        /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n            const attr = attributes[l];\n            const { name, namespaceURI, value: attrValue } = attr;\n            const lcName = transformCaseFunc(name);\n            const initValue = attrValue;\n            let value = name === \"value\" ? initValue : stringTrim(initValue);\n            /* Execute a hook if present */ hookEvent.attrName = lcName;\n            hookEvent.attrValue = value;\n            hookEvent.keepAttr = true;\n            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n            _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n            value = hookEvent.attrValue;\n            /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */ if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName === \"name\")) {\n                // Remove the attribute with this value\n                _removeAttribute(name, currentNode);\n                // Prefix the value and later re-create the attribute with the sanitized value\n                value = SANITIZE_NAMED_PROPS_PREFIX + value;\n            }\n            /* Work around a security issue with comments inside attributes */ if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title|textarea)/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Make sure we cannot easily use animated hrefs, even if animations are allowed */ if (lcName === \"attributename\" && stringMatch(value, \"href\")) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) {\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) {\n                arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    value = stringReplace(value, expr, \" \");\n                });\n            }\n            /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n            if (!_isValidAttribute(lcTag, lcName, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === \"object\" && typeof trustedTypes.getAttributeType === \"function\") {\n                if (namespaceURI) ;\n                else {\n                    switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case \"TrustedHTML\":\n                            {\n                                value = trustedTypesPolicy.createHTML(value);\n                                break;\n                            }\n                        case \"TrustedScriptURL\":\n                            {\n                                value = trustedTypesPolicy.createScriptURL(value);\n                                break;\n                            }\n                    }\n                }\n            }\n            /* Handle invalid data-* attribute set by try-catching it */ if (value !== initValue) {\n                try {\n                    if (namespaceURI) {\n                        currentNode.setAttributeNS(namespaceURI, name, value);\n                    } else {\n                        /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                    }\n                    if (_isClobbered(currentNode)) {\n                        _forceRemove(currentNode);\n                    } else {\n                        arrayPop(DOMPurify.removed);\n                    }\n                } catch (_) {\n                    _removeAttribute(name, currentNode);\n                }\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n    };\n    /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode = null;\n        const shadowIterator = _createNodeIterator(fragment);\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n        while(shadowNode = shadowIterator.nextNode()){\n            /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n            /* Sanitize tags and elements */ _sanitizeElements(shadowNode);\n            /* Check attributes next */ _sanitizeAttributes(shadowNode);\n            /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(shadowNode.content);\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n    };\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function(dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body = null;\n        let importedNode = null;\n        let currentNode = null;\n        let returnNode = null;\n        /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n            dirty = \"<!-->\";\n        }\n        /* Stringify, in case dirty is an object */ if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n            if (typeof dirty.toString === \"function\") {\n                dirty = dirty.toString();\n                if (typeof dirty !== \"string\") {\n                    throw typeErrorCreate(\"dirty is not a string, aborting\");\n                }\n            } else {\n                throw typeErrorCreate(\"toString is not a function\");\n            }\n        }\n        /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) {\n            return dirty;\n        }\n        /* Assign config vars */ if (!SET_CONFIG) {\n            _parseConfig(cfg);\n        }\n        /* Clean up removed elements */ DOMPurify.removed = [];\n        /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === \"string\") {\n            IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n            /* Do some early pre-sanitization to avoid unsafe root nodes */ if (dirty.nodeName) {\n                const tagName = transformCaseFunc(dirty.nodeName);\n                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                    throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n                }\n            }\n        } else if (dirty instanceof Node) {\n            /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */ body = _initDocument(\"<!---->\");\n            importedNode = body.ownerDocument.importNode(dirty, true);\n            if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === \"BODY\") {\n                /* Node is already a body, use as is */ body = importedNode;\n            } else if (importedNode.nodeName === \"HTML\") {\n                body = importedNode;\n            } else {\n                // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            }\n        } else {\n            /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n            dirty.indexOf(\"<\") === -1) {\n                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            }\n            /* Initialize the document to work on */ body = _initDocument(dirty);\n            /* Check we have a DOM node from the data */ if (!body) {\n                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n            }\n        }\n        /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) {\n            _forceRemove(body.firstChild);\n        }\n        /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n        /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n            /* Sanitize tags and elements */ _sanitizeElements(currentNode);\n            /* Check attributes next */ _sanitizeAttributes(currentNode);\n            /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(currentNode.content);\n            }\n        }\n        /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) {\n            return dirty;\n        }\n        /* Return sanitized string or DOM */ if (RETURN_DOM) {\n            if (RETURN_DOM_FRAGMENT) {\n                returnNode = createDocumentFragment.call(body.ownerDocument);\n                while(body.firstChild){\n                    // eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                }\n            } else {\n                returnNode = body;\n            }\n            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n                /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */ returnNode = importNode.call(originalDocument, returnNode, true);\n            }\n            return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n            serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" + serializedHTML;\n        }\n        /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) {\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                serializedHTML = stringReplace(serializedHTML, expr, \" \");\n            });\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    DOMPurify.setConfig = function() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n    };\n    DOMPurify.clearConfig = function() {\n        CONFIG = null;\n        SET_CONFIG = false;\n    };\n    DOMPurify.isValidAttribute = function(tag, attr, value) {\n        /* Initialize shared config vars if necessary. */ if (!CONFIG) {\n            _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n    };\n    DOMPurify.addHook = function(entryPoint, hookFunction) {\n        if (typeof hookFunction !== \"function\") {\n            return;\n        }\n        arrayPush(hooks[entryPoint], hookFunction);\n    };\n    DOMPurify.removeHook = function(entryPoint, hookFunction) {\n        if (hookFunction !== undefined) {\n            const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n            return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n        }\n        return arrayPop(hooks[entryPoint]);\n    };\n    DOMPurify.removeHooks = function(entryPoint) {\n        hooks[entryPoint] = [];\n    };\n    DOMPurify.removeAllHooks = function() {\n        hooks = _createHooksMap();\n    };\n    return DOMPurify;\n}\nvar purify = createDOMPurify();\nmodule.exports = purify; //# sourceMappingURL=purify.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5TEFBeUwsR0FFekw7QUFFQSxNQUFNLEVBQ0pBLE9BQU8sRUFDUEMsY0FBYyxFQUNkQyxRQUFRLEVBQ1JDLGNBQWMsRUFDZEMsd0JBQXdCLEVBQ3pCLEdBQUdDO0FBQ0osSUFBSSxFQUNGQyxNQUFNLEVBQ05DLElBQUksRUFDSkMsTUFBTSxFQUNQLEdBQUdILFFBQVEsZ0RBQWdEO0FBQzVELElBQUksRUFDRkksS0FBSyxFQUNMQyxTQUFTLEVBQ1YsR0FBRyxPQUFPQyxZQUFZLGVBQWVBO0FBQ3RDLElBQUksQ0FBQ0wsUUFBUTtJQUNYQSxTQUFTLFNBQVNBLE9BQU9NLENBQUM7UUFDeEIsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsSUFBSSxDQUFDTCxNQUFNO0lBQ1RBLE9BQU8sU0FBU0EsS0FBS0ssQ0FBQztRQUNwQixPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxJQUFJLENBQUNILE9BQU87SUFDVkEsUUFBUSxTQUFTQSxNQUFNSSxJQUFJLEVBQUVDLE9BQU87UUFDbEMsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1lBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDbEM7UUFDQSxPQUFPUCxLQUFLSixLQUFLLENBQUNLLFNBQVNJO0lBQzdCO0FBQ0Y7QUFDQSxJQUFJLENBQUNSLFdBQVc7SUFDZEEsWUFBWSxTQUFTQSxVQUFVVyxJQUFJO1FBQ2pDLElBQUssSUFBSUMsUUFBUU4sVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1HLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlDLFFBQVEsR0FBR0EsUUFBUUQsT0FBT0MsUUFBUztZQUNqSEwsSUFBSSxDQUFD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TSxVQUFVME0sY0FBYyxHQUFHO1FBQ3pCeEssUUFBUTdDO0lBQ1Y7SUFDQSxPQUFPVztBQUNUO0FBQ0EsSUFBSTJNLFNBQVM1TTtBQUViNk0sT0FBT0MsT0FBTyxHQUFHRixRQUNqQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uaXRpLWZpbmFuY2UvLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmNqcy5qcz9lOWEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAbGljZW5zZSBET01QdXJpZnkgMy4zLjAgfCAoYykgQ3VyZTUzIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIGxpY2Vuc2UgMi4wIGFuZCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIDIuMCB8IGdpdGh1Yi5jb20vY3VyZTUzL0RPTVB1cmlmeS9ibG9iLzMuMy4wL0xJQ0VOU0UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG4gIGVudHJpZXMsXG4gIHNldFByb3RvdHlwZU9mLFxuICBpc0Zyb3plbixcbiAgZ2V0UHJvdG90eXBlT2YsXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSA9IE9iamVjdDtcbmxldCB7XG4gIGZyZWV6ZSxcbiAgc2VhbCxcbiAgY3JlYXRlXG59ID0gT2JqZWN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcbmxldCB7XG4gIGFwcGx5LFxuICBjb25zdHJ1Y3Rcbn0gPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdDtcbmlmICghZnJlZXplKSB7XG4gIGZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5pZiAoIXNlYWwpIHtcbiAgc2VhbCA9IGZ1bmN0aW9uIHNlYWwoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuaWYgKCFhcHBseSkge1xuICBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59XG5pZiAoIWNvbnN0cnVjdCkge1xuICBjb25zdHJ1Y3QgPSBmdW5jdGlvbiBjb25zdHJ1Y3QoRnVuYykge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZ1bmMoLi4uYXJncyk7XG4gIH07XG59XG5jb25zdCBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbmNvbnN0IGFycmF5TGFzdEluZGV4T2YgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZik7XG5jb25zdCBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG5jb25zdCBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbmNvbnN0IGFycmF5U3BsaWNlID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbmNvbnN0IHN0cmluZ1RvTG93ZXJDYXNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKTtcbmNvbnN0IHN0cmluZ1RvU3RyaW5nID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nKTtcbmNvbnN0IHN0cmluZ01hdGNoID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLm1hdGNoKTtcbmNvbnN0IHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5jb25zdCBzdHJpbmdJbmRleE9mID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpO1xuY29uc3Qgc3RyaW5nVHJpbSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50cmltKTtcbmNvbnN0IG9iamVjdEhhc093blByb3BlcnR5ID0gdW5hcHBseShPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbmNvbnN0IHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7XG5jb25zdCB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgdGhpc0FyZyBhbmQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWQgYW5kIGNhbGxlZC5cbiAqIEByZXR1cm5zIEEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgdGhpc0FyZyBhbmQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiB1bmFwcGx5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgaWYgKHRoaXNBcmcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHRoaXNBcmcubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBiZSB3cmFwcGVkIGFuZCBjYWxsZWQuXG4gKiBAcmV0dXJucyBBIG5ldyBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gdW5jb25zdHJ1Y3QoRnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RydWN0KEZ1bmMsIGFyZ3MpO1xuICB9O1xufVxuLyoqXG4gKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZVxuICpcbiAqIEBwYXJhbSBzZXQgLSBUaGUgc2V0IHRvIHdoaWNoIGVsZW1lbnRzIHdpbGwgYmUgYWRkZWQuXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgY29udGFpbmluZyBlbGVtZW50cyB0byBiZSBhZGRlZCB0byB0aGUgc2V0LlxuICogQHBhcmFtIHRyYW5zZm9ybUNhc2VGdW5jIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBjYXNlIG9mIGVhY2ggZWxlbWVudCBiZWZvcmUgYWRkaW5nIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyBUaGUgbW9kaWZpZWQgc2V0IHdpdGggYWRkZWQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXkpIHtcbiAgbGV0IHRyYW5zZm9ybUNhc2VGdW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdHJpbmdUb0xvd2VyQ2FzZTtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gTWFrZSAnaW4nIGFuZCB0cnV0aHkgY2hlY2tzIGxpa2UgQm9vbGVhbihzZXQuY29uc3RydWN0b3IpXG4gICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICBzZXRQcm90b3R5cGVPZihzZXQsIG51bGwpO1xuICB9XG4gIGxldCBsID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobC0tKSB7XG4gICAgbGV0IGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsY0VsZW1lbnQgPSB0cmFuc2Zvcm1DYXNlRnVuYyhlbGVtZW50KTtcbiAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgIGlmICghaXNGcm96ZW4oYXJyYXkpKSB7XG4gICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc2V0O1xufVxuLyoqXG4gKiBDbGVhbiB1cCBhbiBhcnJheSB0byBoYXJkZW4gYWdhaW5zdCBDU1BQXG4gKlxuICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IHRvIGJlIGNsZWFuZWQuXG4gKiBAcmV0dXJucyBUaGUgY2xlYW5lZCB2ZXJzaW9uIG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBjbGVhbkFycmF5KGFycmF5KSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBpc1Byb3BlcnR5RXhpc3QgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShhcnJheSwgaW5kZXgpO1xuICAgIGlmICghaXNQcm9wZXJ0eUV4aXN0KSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFNoYWxsb3cgY2xvbmUgYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgQSBuZXcgb2JqZWN0IHRoYXQgY29waWVzIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gIGNvbnN0IG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBbcHJvcGVydHksIHZhbHVlXSBvZiBlbnRyaWVzKG9iamVjdCkpIHtcbiAgICBjb25zdCBpc1Byb3BlcnR5RXhpc3QgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KTtcbiAgICBpZiAoaXNQcm9wZXJ0eUV4aXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IGNsZWFuQXJyYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IGNsb25lKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIHByb3AgaXMgZnVuY3Rpb24gb3IgZ2V0dGVyIGFuZCBiZWhhdmVzIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGxvb2sgdXAgdGhlIGdldHRlciBmdW5jdGlvbiBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICogQHBhcmFtIHByb3AgLSBUaGUgcHJvcGVydHkgbmFtZSBmb3Igd2hpY2ggdG8gZmluZCB0aGUgZ2V0dGVyIGZ1bmN0aW9uLlxuICogQHJldHVybnMgVGhlIGdldHRlciBmdW5jdGlvbiBmb3VuZCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9yIGEgZmFsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cEdldHRlcihvYmplY3QsIHByb3ApIHtcbiAgd2hpbGUgKG9iamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcbiAgICBpZiAoZGVzYykge1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MuZ2V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiBmYWxsYmFja1ZhbHVlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBmYWxsYmFja1ZhbHVlO1xufVxuXG5jb25zdCBodG1sJDEgPSBmcmVlemUoWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlY29yYXRvcicsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGVyJywgJ25hdicsICdub2JyJywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NlYXJjaCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzaGFkb3cnLCAnc2xvdCcsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInXSk7XG5jb25zdCBzdmckMSA9IGZyZWV6ZShbJ3N2ZycsICdhJywgJ2FsdGdseXBoJywgJ2FsdGdseXBoZGVmJywgJ2FsdGdseXBoaXRlbScsICdhbmltYXRlY29sb3InLCAnYW5pbWF0ZW1vdGlvbicsICdhbmltYXRldHJhbnNmb3JtJywgJ2NpcmNsZScsICdjbGlwcGF0aCcsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdlbnRlcmtleWhpbnQnLCAnZXhwb3J0cGFydHMnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZycsICdnbHlwaCcsICdnbHlwaHJlZicsICdoa2VybicsICdpbWFnZScsICdpbnB1dG1vZGUnLCAnbGluZScsICdsaW5lYXJncmFkaWVudCcsICdtYXJrZXInLCAnbWFzaycsICdtZXRhZGF0YScsICdtcGF0aCcsICdwYXJ0JywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbGdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dHBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd2aWV3JywgJ3ZrZXJuJ10pO1xuY29uc3Qgc3ZnRmlsdGVycyA9IGZyZWV6ZShbJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLCAnZmVEcm9wU2hhZG93JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZUltYWdlJywgJ2ZlTWVyZ2UnLCAnZmVNZXJnZU5vZGUnLCAnZmVNb3JwaG9sb2d5JywgJ2ZlT2Zmc2V0JywgJ2ZlUG9pbnRMaWdodCcsICdmZVNwZWN1bGFyTGlnaHRpbmcnLCAnZmVTcG90TGlnaHQnLCAnZmVUaWxlJywgJ2ZlVHVyYnVsZW5jZSddKTtcbi8vIExpc3Qgb2YgU1ZHIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FsbG93ZWQgYnkgZGVmYXVsdC5cbi8vIFdlIHN0aWxsIG5lZWQgdG8ga25vdyB0aGVtIHNvIHRoYXQgd2UgY2FuIGRvIG5hbWVzcGFjZVxuLy8gY2hlY2tzIHByb3Blcmx5IGluIGNhc2Ugb25lIHdhbnRzIHRvIGFkZCB0aGVtIHRvXG4vLyBhbGxvdy1saXN0LlxuY29uc3Qgc3ZnRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ2FuaW1hdGUnLCAnY29sb3ItcHJvZmlsZScsICdjdXJzb3InLCAnZGlzY2FyZCcsICdmb250LWZhY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2Utc3JjJywgJ2ZvbnQtZmFjZS11cmknLCAnZm9yZWlnbm9iamVjdCcsICdoYXRjaCcsICdoYXRjaHBhdGgnLCAnbWVzaCcsICdtZXNoZ3JhZGllbnQnLCAnbWVzaHBhdGNoJywgJ21lc2hyb3cnLCAnbWlzc2luZy1nbHlwaCcsICdzY3JpcHQnLCAnc2V0JywgJ3NvbGlkY29sb3InLCAndW5rbm93bicsICd1c2UnXSk7XG5jb25zdCBtYXRoTWwkMSA9IGZyZWV6ZShbJ21hdGgnLCAnbWVuY2xvc2UnLCAnbWVycm9yJywgJ21mZW5jZWQnLCAnbWZyYWMnLCAnbWdseXBoJywgJ21pJywgJ21sYWJlbGVkdHInLCAnbW11bHRpc2NyaXB0cycsICdtbicsICdtbycsICdtb3ZlcicsICdtcGFkZGVkJywgJ21waGFudG9tJywgJ21yb290JywgJ21yb3cnLCAnbXMnLCAnbXNwYWNlJywgJ21zcXJ0JywgJ21zdHlsZScsICdtc3ViJywgJ21zdXAnLCAnbXN1YnN1cCcsICdtdGFibGUnLCAnbXRkJywgJ210ZXh0JywgJ210cicsICdtdW5kZXInLCAnbXVuZGVyb3ZlcicsICdtcHJlc2NyaXB0cyddKTtcbi8vIFNpbWlsYXJseSB0byBTVkcsIHdlIHdhbnQgdG8ga25vdyBhbGwgTWF0aE1MIGVsZW1lbnRzLFxuLy8gZXZlbiB0aG9zZSB0aGF0IHdlIGRpc2FsbG93IGJ5IGRlZmF1bHQuXG5jb25zdCBtYXRoTWxEaXNhbGxvd2VkID0gZnJlZXplKFsnbWFjdGlvbicsICdtYWxpZ25ncm91cCcsICdtYWxpZ25tYXJrJywgJ21sb25nZGl2JywgJ21zY2FycmllcycsICdtc2NhcnJ5JywgJ21zZ3JvdXAnLCAnbXN0YWNrJywgJ21zbGluZScsICdtc3JvdycsICdzZW1hbnRpY3MnLCAnYW5ub3RhdGlvbicsICdhbm5vdGF0aW9uLXhtbCcsICdtcHJlc2NyaXB0cycsICdub25lJ10pO1xuY29uc3QgdGV4dCA9IGZyZWV6ZShbJyN0ZXh0J10pO1xuXG5jb25zdCBodG1sID0gZnJlZXplKFsnYWNjZXB0JywgJ2FjdGlvbicsICdhbGlnbicsICdhbHQnLCAnYXV0b2NhcGl0YWxpemUnLCAnYXV0b2NvbXBsZXRlJywgJ2F1dG9waWN0dXJlaW5waWN0dXJlJywgJ2F1dG9wbGF5JywgJ2JhY2tncm91bmQnLCAnYmdjb2xvcicsICdib3JkZXInLCAnY2FwdHVyZScsICdjZWxscGFkZGluZycsICdjZWxsc3BhY2luZycsICdjaGVja2VkJywgJ2NpdGUnLCAnY2xhc3MnLCAnY2xlYXInLCAnY29sb3InLCAnY29scycsICdjb2xzcGFuJywgJ2NvbnRyb2xzJywgJ2NvbnRyb2xzbGlzdCcsICdjb29yZHMnLCAnY3Jvc3NvcmlnaW4nLCAnZGF0ZXRpbWUnLCAnZGVjb2RpbmcnLCAnZGVmYXVsdCcsICdkaXInLCAnZGlzYWJsZWQnLCAnZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUnLCAnZGlzYWJsZXJlbW90ZXBsYXliYWNrJywgJ2Rvd25sb2FkJywgJ2RyYWdnYWJsZScsICdlbmN0eXBlJywgJ2VudGVya2V5aGludCcsICdleHBvcnRwYXJ0cycsICdmYWNlJywgJ2ZvcicsICdoZWFkZXJzJywgJ2hlaWdodCcsICdoaWRkZW4nLCAnaGlnaCcsICdocmVmJywgJ2hyZWZsYW5nJywgJ2lkJywgJ2luZXJ0JywgJ2lucHV0bW9kZScsICdpbnRlZ3JpdHknLCAnaXNtYXAnLCAna2luZCcsICdsYWJlbCcsICdsYW5nJywgJ2xpc3QnLCAnbG9hZGluZycsICdsb29wJywgJ2xvdycsICdtYXgnLCAnbWF4bGVuZ3RoJywgJ21lZGlhJywgJ21ldGhvZCcsICdtaW4nLCAnbWlubGVuZ3RoJywgJ211bHRpcGxlJywgJ211dGVkJywgJ25hbWUnLCAnbm9uY2UnLCAnbm9zaGFkZScsICdub3ZhbGlkYXRlJywgJ25vd3JhcCcsICdvcGVuJywgJ29wdGltdW0nLCAncGFydCcsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3BsYXlzaW5saW5lJywgJ3BvcG92ZXInLCAncG9wb3ZlcnRhcmdldCcsICdwb3BvdmVydGFyZ2V0YWN0aW9uJywgJ3Bvc3RlcicsICdwcmVsb2FkJywgJ3B1YmRhdGUnLCAncmFkaW9ncm91cCcsICdyZWFkb25seScsICdyZWwnLCAncmVxdWlyZWQnLCAncmV2JywgJ3JldmVyc2VkJywgJ3JvbGUnLCAncm93cycsICdyb3dzcGFuJywgJ3NwZWxsY2hlY2snLCAnc2NvcGUnLCAnc2VsZWN0ZWQnLCAnc2hhcGUnLCAnc2l6ZScsICdzaXplcycsICdzbG90JywgJ3NwYW4nLCAnc3JjbGFuZycsICdzdGFydCcsICdzcmMnLCAnc3Jjc2V0JywgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJpbmRleCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLCAndmFsaWduJywgJ3ZhbHVlJywgJ3dpZHRoJywgJ3dyYXAnLCAneG1sbnMnLCAnc2xvdCddKTtcbmNvbnN0IHN2ZyA9IGZyZWV6ZShbJ2FjY2VudC1oZWlnaHQnLCAnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYW1wbGl0dWRlJywgJ2FzY2VudCcsICdhdHRyaWJ1dGVuYW1lJywgJ2F0dHJpYnV0ZXR5cGUnLCAnYXppbXV0aCcsICdiYXNlZnJlcXVlbmN5JywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2JlZ2luJywgJ2JpYXMnLCAnYnknLCAnY2xhc3MnLCAnY2xpcCcsICdjbGlwcGF0aHVuaXRzJywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3InLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnY3gnLCAnY3knLCAnZCcsICdkeCcsICdkeScsICdkaWZmdXNlY29uc3RhbnQnLCAnZGlyZWN0aW9uJywgJ2Rpc3BsYXknLCAnZGl2aXNvcicsICdkdXInLCAnZWRnZW1vZGUnLCAnZWxldmF0aW9uJywgJ2VuZCcsICdleHBvbmVudCcsICdmaWxsJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmlsdGVyJywgJ2ZpbHRlcnVuaXRzJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2Z4JywgJ2Z5JywgJ2cxJywgJ2cyJywgJ2dseXBoLW5hbWUnLCAnZ2x5cGhyZWYnLCAnZ3JhZGllbnR1bml0cycsICdncmFkaWVudHRyYW5zZm9ybScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnaW4nLCAnaW4yJywgJ2ludGVyY2VwdCcsICdrJywgJ2sxJywgJ2syJywgJ2szJywgJ2s0JywgJ2tlcm5pbmcnLCAna2V5cG9pbnRzJywgJ2tleXNwbGluZXMnLCAna2V5dGltZXMnLCAnbGFuZycsICdsZW5ndGhhZGp1c3QnLCAnbGV0dGVyLXNwYWNpbmcnLCAna2VybmVsbWF0cml4JywgJ2tlcm5lbHVuaXRsZW5ndGgnLCAnbGlnaHRpbmctY29sb3InLCAnbG9jYWwnLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdtYXJrZXJoZWlnaHQnLCAnbWFya2VydW5pdHMnLCAnbWFya2Vyd2lkdGgnLCAnbWFza2NvbnRlbnR1bml0cycsICdtYXNrdW5pdHMnLCAnbWF4JywgJ21hc2snLCAnbWFzay10eXBlJywgJ21lZGlhJywgJ21ldGhvZCcsICdtb2RlJywgJ21pbicsICduYW1lJywgJ251bW9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wZXJhdG9yJywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdwYWludC1vcmRlcicsICdwYXRoJywgJ3BhdGhsZW5ndGgnLCAncGF0dGVybmNvbnRlbnR1bml0cycsICdwYXR0ZXJudHJhbnNmb3JtJywgJ3BhdHRlcm51bml0cycsICdwb2ludHMnLCAncHJlc2VydmVhbHBoYScsICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJywgJ3ByaW1pdGl2ZXVuaXRzJywgJ3InLCAncngnLCAncnknLCAncmFkaXVzJywgJ3JlZngnLCAncmVmeScsICdyZXBlYXRjb3VudCcsICdyZXBlYXRkdXInLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3NjYWxlJywgJ3NlZWQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3Nsb3BlJywgJ3NwZWN1bGFyY29uc3RhbnQnLCAnc3BlY3VsYXJleHBvbmVudCcsICdzcHJlYWRtZXRob2QnLCAnc3RhcnRvZmZzZXQnLCAnc3RkZGV2aWF0aW9uJywgJ3N0aXRjaHRpbGVzJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3R5bGUnLCAnc3VyZmFjZXNjYWxlJywgJ3N5c3RlbWxhbmd1YWdlJywgJ3RhYmluZGV4JywgJ3RhYmxldmFsdWVzJywgJ3RhcmdldHgnLCAndGFyZ2V0eScsICd0cmFuc2Zvcm0nLCAndHJhbnNmb3JtLW9yaWdpbicsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndGV4dGxlbmd0aCcsICd0eXBlJywgJ3UxJywgJ3UyJywgJ3VuaWNvZGUnLCAndmFsdWVzJywgJ3ZpZXdib3gnLCAndmlzaWJpbGl0eScsICd2ZXJzaW9uJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dpZHRoJywgJ3dvcmQtc3BhY2luZycsICd3cmFwJywgJ3dyaXRpbmctbW9kZScsICd4Y2hhbm5lbHNlbGVjdG9yJywgJ3ljaGFubmVsc2VsZWN0b3InLCAneCcsICd4MScsICd4MicsICd4bWxucycsICd5JywgJ3kxJywgJ3kyJywgJ3onLCAnem9vbWFuZHBhbiddKTtcbmNvbnN0IG1hdGhNbCA9IGZyZWV6ZShbJ2FjY2VudCcsICdhY2NlbnR1bmRlcicsICdhbGlnbicsICdiZXZlbGxlZCcsICdjbG9zZScsICdjb2x1bW5zYWxpZ24nLCAnY29sdW1ubGluZXMnLCAnY29sdW1uc3BhbicsICdkZW5vbWFsaWduJywgJ2RlcHRoJywgJ2RpcicsICdkaXNwbGF5JywgJ2Rpc3BsYXlzdHlsZScsICdlbmNvZGluZycsICdmZW5jZScsICdmcmFtZScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdsYXJnZW9wJywgJ2xlbmd0aCcsICdsaW5ldGhpY2tuZXNzJywgJ2xzcGFjZScsICdscXVvdGUnLCAnbWF0aGJhY2tncm91bmQnLCAnbWF0aGNvbG9yJywgJ21hdGhzaXplJywgJ21hdGh2YXJpYW50JywgJ21heHNpemUnLCAnbWluc2l6ZScsICdtb3ZhYmxlbGltaXRzJywgJ25vdGF0aW9uJywgJ251bWFsaWduJywgJ29wZW4nLCAncm93YWxpZ24nLCAncm93bGluZXMnLCAncm93c3BhY2luZycsICdyb3dzcGFuJywgJ3JzcGFjZScsICdycXVvdGUnLCAnc2NyaXB0bGV2ZWwnLCAnc2NyaXB0bWluc2l6ZScsICdzY3JpcHRzaXplbXVsdGlwbGllcicsICdzZWxlY3Rpb24nLCAnc2VwYXJhdG9yJywgJ3NlcGFyYXRvcnMnLCAnc3RyZXRjaHknLCAnc3Vic2NyaXB0c2hpZnQnLCAnc3Vwc2NyaXB0c2hpZnQnLCAnc3ltbWV0cmljJywgJ3ZvZmZzZXQnLCAnd2lkdGgnLCAneG1sbnMnXSk7XG5jb25zdCB4bWwgPSBmcmVlemUoWyd4bGluazpocmVmJywgJ3htbDppZCcsICd4bGluazp0aXRsZScsICd4bWw6c3BhY2UnLCAneG1sbnM6eGxpbmsnXSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuY29uc3QgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHdcXFddKnxbXFx3XFxXXSpcXH1cXH0vZ20pOyAvLyBTcGVjaWZ5IHRlbXBsYXRlIGRldGVjdGlvbiByZWdleCBmb3IgU0FGRV9GT1JfVEVNUExBVEVTIG1vZGVcbmNvbnN0IEVSQl9FWFBSID0gc2VhbCgvPCVbXFx3XFxXXSp8W1xcd1xcV10qJT4vZ20pO1xuY29uc3QgVE1QTElUX0VYUFIgPSBzZWFsKC9cXCRcXHtbXFx3XFxXXSovZ20pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG5jb25zdCBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBBUklBX0FUVFIgPSBzZWFsKC9eYXJpYS1bXFwtXFx3XSskLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IElTX0FMTE9XRURfVVJJID0gc2VhbCgvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xzbXN8Y2lkfHhtcHB8bWF0cml4KTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbik7XG5jb25zdCBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbmNvbnN0IEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbik7XG5jb25zdCBET0NUWVBFX05BTUUgPSBzZWFsKC9eaHRtbCQvaSk7XG5jb25zdCBDVVNUT01fRUxFTUVOVCA9IHNlYWwoL15bYS16XVsuXFx3XSooLVsuXFx3XSspKyQvaSk7XG5cbnZhciBFWFBSRVNTSU9OUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBUklBX0FUVFI6IEFSSUFfQVRUUixcbiAgQVRUUl9XSElURVNQQUNFOiBBVFRSX1dISVRFU1BBQ0UsXG4gIENVU1RPTV9FTEVNRU5UOiBDVVNUT01fRUxFTUVOVCxcbiAgREFUQV9BVFRSOiBEQVRBX0FUVFIsXG4gIERPQ1RZUEVfTkFNRTogRE9DVFlQRV9OQU1FLFxuICBFUkJfRVhQUjogRVJCX0VYUFIsXG4gIElTX0FMTE9XRURfVVJJOiBJU19BTExPV0VEX1VSSSxcbiAgSVNfU0NSSVBUX09SX0RBVEE6IElTX1NDUklQVF9PUl9EQVRBLFxuICBNVVNUQUNIRV9FWFBSOiBNVVNUQUNIRV9FWFBSLFxuICBUTVBMSVRfRVhQUjogVE1QTElUX0VYUFJcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvaW5kZW50ICovXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9ub2RlVHlwZVxuY29uc3QgTk9ERV9UWVBFID0ge1xuICBlbGVtZW50OiAxLFxuICBhdHRyaWJ1dGU6IDIsXG4gIHRleHQ6IDMsXG4gIGNkYXRhU2VjdGlvbjogNCxcbiAgZW50aXR5UmVmZXJlbmNlOiA1LFxuICAvLyBEZXByZWNhdGVkXG4gIGVudGl0eU5vZGU6IDYsXG4gIC8vIERlcHJlY2F0ZWRcbiAgcHJvZ3Jlc3NpbmdJbnN0cnVjdGlvbjogNyxcbiAgY29tbWVudDogOCxcbiAgZG9jdW1lbnQ6IDksXG4gIGRvY3VtZW50VHlwZTogMTAsXG4gIGRvY3VtZW50RnJhZ21lbnQ6IDExLFxuICBub3RhdGlvbjogMTIgLy8gRGVwcmVjYXRlZFxufTtcbmNvbnN0IGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuby1vcCBwb2xpY3kgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICogRG9uJ3QgZXhwb3J0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSFcbiAqIEBwYXJhbSB0cnVzdGVkVHlwZXMgVGhlIHBvbGljeSBmYWN0b3J5LlxuICogQHBhcmFtIHB1cmlmeUhvc3RFbGVtZW50IFRoZSBTY3JpcHQgZWxlbWVudCB1c2VkIHRvIGxvYWQgRE9NUHVyaWZ5ICh0byBkZXRlcm1pbmUgcG9saWN5IG5hbWUgc3VmZml4KS5cbiAqIEByZXR1cm4gVGhlIHBvbGljeSBjcmVhdGVkIChvciBudWxsLCBpZiBUcnVzdGVkIFR5cGVzXG4gKiBhcmUgbm90IHN1cHBvcnRlZCBvciBjcmVhdGluZyB0aGUgcG9saWN5IGZhaWxlZCkuXG4gKi9cbmNvbnN0IF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kgPSBmdW5jdGlvbiBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgcHVyaWZ5SG9zdEVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiB0cnVzdGVkVHlwZXMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gQWxsb3cgdGhlIGNhbGxlcnMgdG8gY29udHJvbCB0aGUgdW5pcXVlIHBvbGljeSBuYW1lXG4gIC8vIGJ5IGFkZGluZyBhIGRhdGEtdHQtcG9saWN5LXN1ZmZpeCB0byB0aGUgc2NyaXB0IGVsZW1lbnQgd2l0aCB0aGUgRE9NUHVyaWZ5LlxuICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG4gIGxldCBzdWZmaXggPSBudWxsO1xuICBjb25zdCBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcbiAgaWYgKHB1cmlmeUhvc3RFbGVtZW50ICYmIHB1cmlmeUhvc3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKSB7XG4gICAgc3VmZml4ID0gcHVyaWZ5SG9zdEVsZW1lbnQuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSk7XG4gIH1cbiAgY29uc3QgcG9saWN5TmFtZSA9ICdkb21wdXJpZnknICsgKHN1ZmZpeCA/ICcjJyArIHN1ZmZpeCA6ICcnKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICBjcmVhdGVIVE1MKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU2NyaXB0VVJMKHNjcmlwdFVybCkge1xuICAgICAgICByZXR1cm4gc2NyaXB0VXJsO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gUG9saWN5IGNyZWF0aW9uIGZhaWxlZCAobW9zdCBsaWtlbHkgYW5vdGhlciBET01QdXJpZnkgc2NyaXB0IGhhc1xuICAgIC8vIGFscmVhZHkgcnVuKS4gU2tpcCBjcmVhdGluZyB0aGUgcG9saWN5LCBhcyB0aGlzIHdpbGwgb25seSBjYXVzZSBlcnJvcnNcbiAgICAvLyBpZiBUVCBhcmUgZW5mb3JjZWQuXG4gICAgY29uc29sZS53YXJuKCdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbmNvbnN0IF9jcmVhdGVIb29rc01hcCA9IGZ1bmN0aW9uIF9jcmVhdGVIb29rc01hcCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhZnRlclNhbml0aXplQXR0cmlidXRlczogW10sXG4gICAgYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzOiBbXSxcbiAgICBhZnRlclNhbml0aXplU2hhZG93RE9NOiBbXSxcbiAgICBiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXM6IFtdLFxuICAgIGJlZm9yZVNhbml0aXplRWxlbWVudHM6IFtdLFxuICAgIGJlZm9yZVNhbml0aXplU2hhZG93RE9NOiBbXSxcbiAgICB1cG9uU2FuaXRpemVBdHRyaWJ1dGU6IFtdLFxuICAgIHVwb25TYW5pdGl6ZUVsZW1lbnQ6IFtdLFxuICAgIHVwb25TYW5pdGl6ZVNoYWRvd05vZGU6IFtdXG4gIH07XG59O1xuZnVuY3Rpb24gY3JlYXRlRE9NUHVyaWZ5KCkge1xuICBsZXQgd2luZG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBnZXRHbG9iYWwoKTtcbiAgY29uc3QgRE9NUHVyaWZ5ID0gcm9vdCA9PiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gIERPTVB1cmlmeS52ZXJzaW9uID0gJzMuMy4wJztcbiAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQubm9kZVR5cGUgIT09IE5PREVfVFlQRS5kb2N1bWVudCB8fCAhd2luZG93LkVsZW1lbnQpIHtcbiAgICAvLyBOb3QgcnVubmluZyBpbiBhIGJyb3dzZXIsIHByb3ZpZGUgYSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCB5b3UgY2FuIHBhc3MgeW91ciBvd24gV2luZG93XG4gICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuICBsZXQge1xuICAgIGRvY3VtZW50XG4gIH0gPSB3aW5kb3c7XG4gIGNvbnN0IG9yaWdpbmFsRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgY29uc3QgY3VycmVudFNjcmlwdCA9IG9yaWdpbmFsRG9jdW1lbnQuY3VycmVudFNjcmlwdDtcbiAgY29uc3Qge1xuICAgIERvY3VtZW50RnJhZ21lbnQsXG4gICAgSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICBOb2RlLFxuICAgIEVsZW1lbnQsXG4gICAgTm9kZUZpbHRlcixcbiAgICBOYW1lZE5vZGVNYXAgPSB3aW5kb3cuTmFtZWROb2RlTWFwIHx8IHdpbmRvdy5Nb3pOYW1lZEF0dHJNYXAsXG4gICAgSFRNTEZvcm1FbGVtZW50LFxuICAgIERPTVBhcnNlcixcbiAgICB0cnVzdGVkVHlwZXNcbiAgfSA9IHdpbmRvdztcbiAgY29uc3QgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuICBjb25zdCBjbG9uZU5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2Nsb25lTm9kZScpO1xuICBjb25zdCByZW1vdmUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3JlbW92ZScpO1xuICBjb25zdCBnZXROZXh0U2libGluZyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKTtcbiAgY29uc3QgZ2V0Q2hpbGROb2RlcyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2hpbGROb2RlcycpO1xuICBjb25zdCBnZXRQYXJlbnROb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdwYXJlbnROb2RlJyk7XG4gIC8vIEFzIHBlciBpc3N1ZSAjNDcsIHRoZSB3ZWItY29tcG9uZW50cyByZWdpc3RyeSBpcyBpbmhlcml0ZWQgYnkgYVxuICAvLyBuZXcgZG9jdW1lbnQgY3JlYXRlZCB2aWEgY3JlYXRlSFRNTERvY3VtZW50LiBBcyBwZXIgdGhlIHNwZWNcbiAgLy8gKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2NyZWF0aW5nLWFuZC1wYXNzaW5nLXJlZ2lzdHJpZXMpXG4gIC8vIGEgbmV3IGVtcHR5IHJlZ2lzdHJ5IGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIHRlbXBsYXRlIGNvbnRlbnRzIG93bmVyXG4gIC8vIGRvY3VtZW50LCBzbyB3ZSB1c2UgdGhhdCBhcyBvdXIgcGFyZW50IGRvY3VtZW50IHRvIGVuc3VyZSBub3RoaW5nXG4gIC8vIGlzIGluaGVyaXRlZC5cbiAgaWYgKHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIGlmICh0ZW1wbGF0ZS5jb250ZW50ICYmIHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgZG9jdW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICB9XG4gIGxldCB0cnVzdGVkVHlwZXNQb2xpY3k7XG4gIGxldCBlbXB0eUhUTUwgPSAnJztcbiAgY29uc3Qge1xuICAgIGltcGxlbWVudGF0aW9uLFxuICAgIGNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lXG4gIH0gPSBkb2N1bWVudDtcbiAgY29uc3Qge1xuICAgIGltcG9ydE5vZGVcbiAgfSA9IG9yaWdpbmFsRG9jdW1lbnQ7XG4gIGxldCBob29rcyA9IF9jcmVhdGVIb29rc01hcCgpO1xuICAvKipcbiAgICogRXhwb3NlIHdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHJ1bm5pbmcgdGhlIGZ1bGwgRE9NUHVyaWZ5LlxuICAgKi9cbiAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gdHlwZW9mIGVudHJpZXMgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGdldFBhcmVudE5vZGUgPT09ICdmdW5jdGlvbicgJiYgaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50ICE9PSB1bmRlZmluZWQ7XG4gIGNvbnN0IHtcbiAgICBNVVNUQUNIRV9FWFBSLFxuICAgIEVSQl9FWFBSLFxuICAgIFRNUExJVF9FWFBSLFxuICAgIERBVEFfQVRUUixcbiAgICBBUklBX0FUVFIsXG4gICAgSVNfU0NSSVBUX09SX0RBVEEsXG4gICAgQVRUUl9XSElURVNQQUNFLFxuICAgIENVU1RPTV9FTEVNRU5UXG4gIH0gPSBFWFBSRVNTSU9OUztcbiAgbGV0IHtcbiAgICBJU19BTExPV0VEX1VSSTogSVNfQUxMT1dFRF9VUkkkMVxuICB9ID0gRVhQUkVTU0lPTlM7XG4gIC8qKlxuICAgKiBXZSBjb25zaWRlciB0aGUgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXMgYmVsb3cgdG8gYmUgc2FmZS4gSWRlYWxseVxuICAgKiBkb24ndCBhZGQgYW55IG5ldyBvbmVzIGJ1dCBmZWVsIGZyZWUgdG8gcmVtb3ZlIHVud2FudGVkIG9uZXMuXG4gICAqL1xuICAvKiBhbGxvd2VkIGVsZW1lbnQgbmFtZXMgKi9cbiAgbGV0IEFMTE9XRURfVEFHUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5odG1sJDEsIC4uLnN2ZyQxLCAuLi5zdmdGaWx0ZXJzLCAuLi5tYXRoTWwkMSwgLi4udGV4dF0pO1xuICAvKiBBbGxvd2VkIGF0dHJpYnV0ZSBuYW1lcyAqL1xuICBsZXQgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9BTExPV0VEX0FUVFIgPSBhZGRUb1NldCh7fSwgWy4uLmh0bWwsIC4uLnN2ZywgLi4ubWF0aE1sLCAuLi54bWxdKTtcbiAgLypcbiAgICogQ29uZmlndXJlIGhvdyBET01QdXJpZnkgc2hvdWxkIGhhbmRsZSBjdXN0b20gZWxlbWVudHMgYW5kIHRoZWlyIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBjdXN0b21pemVkIGJ1aWx0LWluIGVsZW1lbnRzLlxuICAgKiBAcHJvcGVydHkge1JlZ0V4cHxGdW5jdGlvbnxudWxsfSB0YWdOYW1lQ2hlY2sgb25lIG9mIFtudWxsLCByZWdleFBhdHRlcm4sIHByZWRpY2F0ZV0uIERlZmF1bHQ6IGBudWxsYCAoZGlzYWxsb3cgYW55IGN1c3RvbSBlbGVtZW50cylcbiAgICogQHByb3BlcnR5IHtSZWdFeHB8RnVuY3Rpb258bnVsbH0gYXR0cmlidXRlTmFtZUNoZWNrIG9uZSBvZiBbbnVsbCwgcmVnZXhQYXR0ZXJuLCBwcmVkaWNhdGVdLiBEZWZhdWx0OiBgbnVsbGAgKGRpc2FsbG93IGFueSBhdHRyaWJ1dGVzIG5vdCBvbiB0aGUgYWxsb3cgbGlzdClcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgYWxsb3cgY3VzdG9tIGVsZW1lbnRzIGRlcml2ZWQgZnJvbSBidWlsdC1pbnMgaWYgdGhleSBwYXNzIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjay4gRGVmYXVsdDogYGZhbHNlYC5cbiAgICovXG4gIGxldCBDVVNUT01fRUxFTUVOVF9IQU5ETElORyA9IE9iamVjdC5zZWFsKGNyZWF0ZShudWxsLCB7XG4gICAgdGFnTmFtZUNoZWNrOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGF0dHJpYnV0ZU5hbWVDaGVjazoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHM6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9XG4gIH0pKTtcbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gdGFncyAob3ZlcnJpZGVzIEFMTE9XRURfVEFHUy9BRERfVEFHUykgKi9cbiAgbGV0IEZPUkJJRF9UQUdTID0gbnVsbDtcbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gYXR0cmlidXRlcyAob3ZlcnJpZGVzIEFMTE9XRURfQVRUUi9BRERfQVRUUikgKi9cbiAgbGV0IEZPUkJJRF9BVFRSID0gbnVsbDtcbiAgLyogQ29uZmlnIG9iamVjdCB0byBzdG9yZSBBRERfVEFHUy9BRERfQVRUUiBmdW5jdGlvbnMgKHdoZW4gdXNlZCBhcyBmdW5jdGlvbnMpICovXG4gIGNvbnN0IEVYVFJBX0VMRU1FTlRfSEFORExJTkcgPSBPYmplY3Quc2VhbChjcmVhdGUobnVsbCwge1xuICAgIHRhZ0NoZWNrOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGF0dHJpYnV0ZUNoZWNrOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9XG4gIH0pKTtcbiAgLyogRGVjaWRlIGlmIEFSSUEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICBsZXQgQUxMT1dfQVJJQV9BVFRSID0gdHJ1ZTtcbiAgLyogRGVjaWRlIGlmIGN1c3RvbSBkYXRhIGF0dHJpYnV0ZXMgYXJlIG9rYXkgKi9cbiAgbGV0IEFMTE9XX0RBVEFfQVRUUiA9IHRydWU7XG4gIC8qIERlY2lkZSBpZiB1bmtub3duIHByb3RvY29scyBhcmUgb2theSAqL1xuICBsZXQgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIHNlbGYtY2xvc2luZyB0YWdzIGluIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQuXG4gICAqIFVzdWFsbHkgcmVtb3ZlZCBkdWUgdG8gYSBtWFNTIGlzc3VlIGluIGpRdWVyeSAzLjAgKi9cbiAgbGV0IEFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiA9IHRydWU7XG4gIC8qIE91dHB1dCBzaG91bGQgYmUgc2FmZSBmb3IgY29tbW9uIHRlbXBsYXRlIGVuZ2luZXMuXG4gICAqIFRoaXMgbWVhbnMsIERPTVB1cmlmeSByZW1vdmVzIGRhdGEgYXR0cmlidXRlcywgbXVzdGFjaGVzIGFuZCBFUkJcbiAgICovXG4gIGxldCBTQUZFX0ZPUl9URU1QTEFURVMgPSBmYWxzZTtcbiAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGV2ZW4gZm9yIFhNTCB1c2VkIHdpdGhpbiBIVE1MIGFuZCBhbGlrZS5cbiAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgY29tbWVudHMgd2hlbiBjb250YWluaW5nIHJpc2t5IGNvbnRlbnQuXG4gICAqL1xuICBsZXQgU0FGRV9GT1JfWE1MID0gdHJ1ZTtcbiAgLyogRGVjaWRlIGlmIGRvY3VtZW50IHdpdGggPGh0bWw+Li4uIHNob3VsZCBiZSByZXR1cm5lZCAqL1xuICBsZXQgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcbiAgLyogVHJhY2sgd2hldGhlciBjb25maWcgaXMgYWxyZWFkeSBzZXQgb24gdGhpcyBpbnN0YW5jZSBvZiBET01QdXJpZnkuICovXG4gIGxldCBTRVRfQ09ORklHID0gZmFsc2U7XG4gIC8qIERlY2lkZSBpZiBhbGwgZWxlbWVudHMgKGUuZy4gc3R5bGUsIHNjcmlwdCkgbXVzdCBiZSBjaGlsZHJlbiBvZlxuICAgKiBkb2N1bWVudC5ib2R5LiBCeSBkZWZhdWx0LCBicm93c2VycyBtaWdodCBtb3ZlIHRoZW0gdG8gZG9jdW1lbnQuaGVhZCAqL1xuICBsZXQgRk9SQ0VfQk9EWSA9IGZhbHNlO1xuICAvKiBEZWNpZGUgaWYgYSBET00gYEhUTUxCb2R5RWxlbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgKiBzdHJpbmcgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkuXG4gICAqIElmIGBXSE9MRV9ET0NVTUVOVGAgaXMgZW5hYmxlZCBhIGBIVE1MSHRtbEVsZW1lbnRgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZFxuICAgKi9cbiAgbGV0IFJFVFVSTl9ET00gPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBEb2N1bWVudEZyYWdtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cbiAgbGV0IFJFVFVSTl9ET01fRlJBR01FTlQgPSBmYWxzZTtcbiAgLyogVHJ5IHRvIHJldHVybiBhIFRydXN0ZWQgVHlwZSBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZywgcmV0dXJuIGEgc3RyaW5nIGluXG4gICAqIGNhc2UgVHJ1c3RlZCBUeXBlcyBhcmUgbm90IHN1cHBvcnRlZCAgKi9cbiAgbGV0IFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBmYWxzZTtcbiAgLyogT3V0cHV0IHNob3VsZCBiZSBmcmVlIGZyb20gRE9NIGNsb2JiZXJpbmcgYXR0YWNrcz9cbiAgICogVGhpcyBzYW5pdGl6ZXMgbWFya3VwcyBuYW1lZCB3aXRoIGNvbGxpZGluZywgY2xvYmJlcmFibGUgYnVpbHQtaW4gRE9NIEFQSXMuXG4gICAqL1xuICBsZXQgU0FOSVRJWkVfRE9NID0gdHJ1ZTtcbiAgLyogQWNoaWV2ZSBmdWxsIERPTSBDbG9iYmVyaW5nIHByb3RlY3Rpb24gYnkgaXNvbGF0aW5nIHRoZSBuYW1lc3BhY2Ugb2YgbmFtZWRcbiAgICogcHJvcGVydGllcyBhbmQgSlMgdmFyaWFibGVzLCBtaXRpZ2F0aW5nIGF0dGFja3MgdGhhdCBhYnVzZSB0aGUgSFRNTC9ET00gc3BlYyBydWxlcy5cbiAgICpcbiAgICogSFRNTC9ET00gc3BlYyBydWxlcyB0aGF0IGVuYWJsZSBET00gQ2xvYmJlcmluZzpcbiAgICogICAtIE5hbWVkIEFjY2VzcyBvbiBXaW5kb3cgKMKnNy4zLjMpXG4gICAqICAgLSBET00gVHJlZSBBY2Nlc3NvcnMgKMKnMy4xLjUpXG4gICAqICAgLSBGb3JtIEVsZW1lbnQgUGFyZW50LUNoaWxkIFJlbGF0aW9ucyAowqc0LjEwLjMpXG4gICAqICAgLSBJZnJhbWUgc3JjZG9jIC8gTmVzdGVkIFdpbmRvd1Byb3hpZXMgKMKnNC44LjUpXG4gICAqICAgLSBIVE1MQ29sbGVjdGlvbiAowqc0LjIuMTAuMilcbiAgICpcbiAgICogTmFtZXNwYWNlIGlzb2xhdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBwcmVmaXhpbmcgYGlkYCBhbmQgYG5hbWVgIGF0dHJpYnV0ZXNcbiAgICogd2l0aCBhIGNvbnN0YW50IHN0cmluZywgaS5lLiwgYHVzZXItY29udGVudC1gXG4gICAqL1xuICBsZXQgU0FOSVRJWkVfTkFNRURfUFJPUFMgPSBmYWxzZTtcbiAgY29uc3QgU0FOSVRJWkVfTkFNRURfUFJPUFNfUFJFRklYID0gJ3VzZXItY29udGVudC0nO1xuICAvKiBLZWVwIGVsZW1lbnQgY29udGVudCB3aGVuIHJlbW92aW5nIGVsZW1lbnQ/ICovXG4gIGxldCBLRUVQX0NPTlRFTlQgPSB0cnVlO1xuICAvKiBJZiBhIGBOb2RlYCBpcyBwYXNzZWQgdG8gc2FuaXRpemUoKSwgdGhlbiBwZXJmb3JtcyBzYW5pdGl6YXRpb24gaW4tcGxhY2UgaW5zdGVhZFxuICAgKiBvZiBpbXBvcnRpbmcgaXQgaW50byBhIG5ldyBEb2N1bWVudCBhbmQgcmV0dXJuaW5nIGEgc2FuaXRpemVkIGNvcHkgKi9cbiAgbGV0IElOX1BMQUNFID0gZmFsc2U7XG4gIC8qIEFsbG93IHVzYWdlIG9mIHByb2ZpbGVzIGxpa2UgaHRtbCwgc3ZnIGFuZCBtYXRoTWwgKi9cbiAgbGV0IFVTRV9QUk9GSUxFUyA9IHt9O1xuICAvKiBUYWdzIHRvIGlnbm9yZSBjb250ZW50IG9mIHdoZW4gS0VFUF9DT05URU5UIGlzIHRydWUgKi9cbiAgbGV0IEZPUkJJRF9DT05URU5UUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTID0gYWRkVG9TZXQoe30sIFsnYW5ub3RhdGlvbi14bWwnLCAnYXVkaW8nLCAnY29sZ3JvdXAnLCAnZGVzYycsICdmb3JlaWdub2JqZWN0JywgJ2hlYWQnLCAnaWZyYW1lJywgJ21hdGgnLCAnbWknLCAnbW4nLCAnbW8nLCAnbXMnLCAnbXRleHQnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdwbGFpbnRleHQnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0aGVhZCcsICd0aXRsZScsICd2aWRlbycsICd4bXAnXSk7XG4gIC8qIFRhZ3MgdGhhdCBhcmUgc2FmZSBmb3IgZGF0YTogVVJJcyAqL1xuICBsZXQgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfREFUQV9VUklfVEFHUyA9IGFkZFRvU2V0KHt9LCBbJ2F1ZGlvJywgJ3ZpZGVvJywgJ2ltZycsICdzb3VyY2UnLCAnaW1hZ2UnLCAndHJhY2snXSk7XG4gIC8qIEF0dHJpYnV0ZXMgc2FmZSBmb3IgdmFsdWVzIGxpa2UgXCJqYXZhc2NyaXB0OlwiICovXG4gIGxldCBVUklfU0FGRV9BVFRSSUJVVEVTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTID0gYWRkVG9TZXQoe30sIFsnYWx0JywgJ2NsYXNzJywgJ2ZvcicsICdpZCcsICdsYWJlbCcsICduYW1lJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncm9sZScsICdzdW1tYXJ5JywgJ3RpdGxlJywgJ3ZhbHVlJywgJ3N0eWxlJywgJ3htbG5zJ10pO1xuICBjb25zdCBNQVRITUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuICBjb25zdCBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgY29uc3QgSFRNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG4gIC8qIERvY3VtZW50IG5hbWVzcGFjZSAqL1xuICBsZXQgTkFNRVNQQUNFID0gSFRNTF9OQU1FU1BBQ0U7XG4gIGxldCBJU19FTVBUWV9JTlBVVCA9IGZhbHNlO1xuICAvKiBBbGxvd2VkIFhIVE1MK1hNTCBuYW1lc3BhY2VzICovXG4gIGxldCBBTExPV0VEX05BTUVTUEFDRVMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUyA9IGFkZFRvU2V0KHt9LCBbTUFUSE1MX05BTUVTUEFDRSwgU1ZHX05BTUVTUEFDRSwgSFRNTF9OQU1FU1BBQ0VdLCBzdHJpbmdUb1N0cmluZyk7XG4gIGxldCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydtaScsICdtbycsICdtbicsICdtcycsICdtdGV4dCddKTtcbiAgbGV0IEhUTUxfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnYW5ub3RhdGlvbi14bWwnXSk7XG4gIC8vIENlcnRhaW4gZWxlbWVudHMgYXJlIGFsbG93ZWQgaW4gYm90aCBTVkcgYW5kIEhUTUxcbiAgLy8gbmFtZXNwYWNlLiBXZSBuZWVkIHRvIHNwZWNpZnkgdGhlbSBleHBsaWNpdGx5XG4gIC8vIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgZXJyb25lb3VzbHkgZGVsZXRlZCBmcm9tXG4gIC8vIEhUTUwgbmFtZXNwYWNlLlxuICBjb25zdCBDT01NT05fU1ZHX0FORF9IVE1MX0VMRU1FTlRTID0gYWRkVG9TZXQoe30sIFsndGl0bGUnLCAnc3R5bGUnLCAnZm9udCcsICdhJywgJ3NjcmlwdCddKTtcbiAgLyogUGFyc2luZyBvZiBzdHJpY3QgWEhUTUwgZG9jdW1lbnRzICovXG4gIGxldCBQQVJTRVJfTUVESUFfVFlQRSA9IG51bGw7XG4gIGNvbnN0IFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMgPSBbJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsICd0ZXh0L2h0bWwnXTtcbiAgY29uc3QgREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA9ICd0ZXh0L2h0bWwnO1xuICBsZXQgdHJhbnNmb3JtQ2FzZUZ1bmMgPSBudWxsO1xuICAvKiBLZWVwIGEgcmVmZXJlbmNlIHRvIGNvbmZpZyB0byBwYXNzIHRvIGhvb2tzICovXG4gIGxldCBDT05GSUcgPSBudWxsO1xuICAvKiBJZGVhbGx5LCBkbyBub3QgdG91Y2ggYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lICovXG4gIC8qIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gKi9cbiAgY29uc3QgZm9ybUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGNvbnN0IGlzUmVnZXhPckZ1bmN0aW9uID0gZnVuY3Rpb24gaXNSZWdleE9yRnVuY3Rpb24odGVzdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRlc3RWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0ZXN0VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfTtcbiAgLyoqXG4gICAqIF9wYXJzZUNvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0gY2ZnIG9wdGlvbmFsIGNvbmZpZyBsaXRlcmFsXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdCBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoKSB7XG4gICAgbGV0IGNmZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB0YW1wZXJpbmcgKi9cbiAgICBpZiAoIWNmZyB8fCB0eXBlb2YgY2ZnICE9PSAnb2JqZWN0Jykge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHByb3RvdHlwZSBwb2xsdXRpb24gKi9cbiAgICBjZmcgPSBjbG9uZShjZmcpO1xuICAgIFBBUlNFUl9NRURJQV9UWVBFID1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICBTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTLmluZGV4T2YoY2ZnLlBBUlNFUl9NRURJQV9UWVBFKSA9PT0gLTEgPyBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogY2ZnLlBBUlNFUl9NRURJQV9UWVBFO1xuICAgIC8vIEhUTUwgdGFncyBhbmQgYXR0cmlidXRlcyBhcmUgbm90IGNhc2Utc2Vuc2l0aXZlLCBjb252ZXJ0aW5nIHRvIGxvd2VyY2FzZS4gS2VlcGluZyBYSFRNTCBhcyBpcy5cbiAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyA/IHN0cmluZ1RvU3RyaW5nIDogc3RyaW5nVG9Mb3dlckNhc2U7XG4gICAgLyogU2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIEFMTE9XRURfVEFHUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FMTE9XRURfVEFHUycpID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgIEFMTE9XRURfQVRUUiA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FMTE9XRURfQVRUUicpID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfQUxMT1dFRF9BVFRSO1xuICAgIEFMTE9XRURfTkFNRVNQQUNFUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FMTE9XRURfTkFNRVNQQUNFUycpID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX05BTUVTUEFDRVMsIHN0cmluZ1RvU3RyaW5nKSA6IERFRkFVTFRfQUxMT1dFRF9OQU1FU1BBQ0VTO1xuICAgIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdBRERfVVJJX1NBRkVfQVRUUicpID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVM7XG4gICAgREFUQV9VUklfVEFHUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FERF9EQVRBX1VSSV9UQUdTJykgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX0RBVEFfVVJJX1RBR1MpLCBjZmcuQUREX0RBVEFfVVJJX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICBGT1JCSURfQ09OVEVOVFMgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdGT1JCSURfQ09OVEVOVFMnKSA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0NPTlRFTlRTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICBGT1JCSURfVEFHUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0ZPUkJJRF9UQUdTJykgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBjbG9uZSh7fSk7XG4gICAgRk9SQklEX0FUVFIgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdGT1JCSURfQVRUUicpID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogY2xvbmUoe30pO1xuICAgIFVTRV9QUk9GSUxFUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ1VTRV9QUk9GSUxFUycpID8gY2ZnLlVTRV9QUk9GSUxFUyA6IGZhbHNlO1xuICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBjZmcuQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgPSBjZmcuQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgU0FGRV9GT1JfVEVNUExBVEVTID0gY2ZnLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBRkVfRk9SX1hNTCA9IGNmZy5TQUZFX0ZPUl9YTUwgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEZPUkNFX0JPRFkgPSBjZmcuRk9SQ0VfQk9EWSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGNmZy5TQU5JVElaRV9OQU1FRF9QUk9QUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBJTl9QTEFDRSA9IGNmZy5JTl9QTEFDRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIElTX0FMTE9XRURfVVJJJDEgPSBjZmcuQUxMT1dFRF9VUklfUkVHRVhQIHx8IElTX0FMTE9XRURfVVJJO1xuICAgIE5BTUVTUEFDRSA9IGNmZy5OQU1FU1BBQ0UgfHwgSFRNTF9OQU1FU1BBQ0U7XG4gICAgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gY2ZnLk1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFM7XG4gICAgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBjZmcuSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgfHwgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFM7XG4gICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgfHwge307XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKSkge1xuICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaztcbiAgICB9XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKSkge1xuICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaztcbiAgICB9XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiB0eXBlb2YgY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzO1xuICAgIH1cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICBBTExPV19EQVRBX0FUVFIgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgIFJFVFVSTl9ET00gPSB0cnVlO1xuICAgIH1cbiAgICAvKiBQYXJzZSBwcm9maWxlIGluZm8gKi9cbiAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICBBTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgdGV4dCk7XG4gICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2ZyQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2Z0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIG1hdGhNbCQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBtYXRoTWwpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIE1lcmdlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIGlmIChjZmcuQUREX1RBR1MpIHtcbiAgICAgIGlmICh0eXBlb2YgY2ZnLkFERF9UQUdTID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEVYVFJBX0VMRU1FTlRfSEFORExJTkcudGFnQ2hlY2sgPSBjZmcuQUREX1RBR1M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQUxMT1dFRF9UQUdTID09PSBERUZBVUxUX0FMTE9XRURfVEFHUykge1xuICAgICAgICAgIEFMTE9XRURfVEFHUyA9IGNsb25lKEFMTE9XRURfVEFHUyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBjZmcuQUREX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgaWYgKHR5cGVvZiBjZmcuQUREX0FUVFIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgRVhUUkFfRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVDaGVjayA9IGNmZy5BRERfQVRUUjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChBTExPV0VEX0FUVFIgPT09IERFRkFVTFRfQUxMT1dFRF9BVFRSKSB7XG4gICAgICAgICAgQUxMT1dFRF9BVFRSID0gY2xvbmUoQUxMT1dFRF9BVFRSKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGNmZy5BRERfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2ZnLkFERF9VUklfU0FGRV9BVFRSKSB7XG4gICAgICBhZGRUb1NldChVUklfU0FGRV9BVFRSSUJVVEVTLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICB9XG4gICAgaWYgKGNmZy5GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgIGlmIChGT1JCSURfQ09OVEVOVFMgPT09IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICAgIEZPUkJJRF9DT05URU5UUyA9IGNsb25lKEZPUkJJRF9DT05URU5UUyk7XG4gICAgICB9XG4gICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5GT1JCSURfQ09OVEVOVFMsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICB9XG4gICAgLyogQWRkICN0ZXh0IGluIGNhc2UgS0VFUF9DT05URU5UIGlzIHNldCB0byB0cnVlICovXG4gICAgaWYgKEtFRVBfQ09OVEVOVCkge1xuICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogQWRkIGh0bWwsIGhlYWQgYW5kIGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgV0hPTEVfRE9DVU1FTlQgaXMgdHJ1ZSAqL1xuICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ2h0bWwnLCAnaGVhZCcsICdib2R5J10pO1xuICAgIH1cbiAgICAvKiBBZGQgdGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgdGFibGVzIGFyZSBwZXJtaXR0ZWQsIHNlZSAjMjg2LCAjMzY1ICovXG4gICAgaWYgKEFMTE9XRURfVEFHUy50YWJsZSkge1xuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ3Rib2R5J10pO1xuICAgICAgZGVsZXRlIEZPUkJJRF9UQUdTLnRib2R5O1xuICAgIH1cbiAgICBpZiAoY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZKSB7XG4gICAgICBpZiAodHlwZW9mIGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWS5jcmVhdGVIVE1MICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgnVFJVU1RFRF9UWVBFU19QT0xJQ1kgY29uZmlndXJhdGlvbiBvcHRpb24gbXVzdCBwcm92aWRlIGEgXCJjcmVhdGVIVE1MXCIgaG9vay4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZLmNyZWF0ZVNjcmlwdFVSTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhIFwiY3JlYXRlU2NyaXB0VVJMXCIgaG9vay4nKTtcbiAgICAgIH1cbiAgICAgIC8vIE92ZXJ3cml0ZSBleGlzdGluZyBUcnVzdGVkVHlwZXMgcG9saWN5LlxuICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZO1xuICAgICAgLy8gU2lnbiBsb2NhbCB2YXJpYWJsZXMgcmVxdWlyZWQgYnkgYHNhbml0aXplYC5cbiAgICAgIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5pbml0aWFsaXplZCBwb2xpY3ksIGF0dGVtcHQgdG8gaW5pdGlhbGl6ZSB0aGUgaW50ZXJuYWwgZG9tcHVyaWZ5IHBvbGljeS5cbiAgICAgIGlmICh0cnVzdGVkVHlwZXNQb2xpY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgY3VycmVudFNjcmlwdCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBjcmVhdGluZyB0aGUgaW50ZXJuYWwgcG9saWN5IHN1Y2NlZWRlZCBzaWduIGludGVybmFsIHZhcmlhYmxlcy5cbiAgICAgIGlmICh0cnVzdGVkVHlwZXNQb2xpY3kgIT09IG51bGwgJiYgdHlwZW9mIGVtcHR5SFRNTCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW1wdHlIVE1MID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQcmV2ZW50IGZ1cnRoZXIgbWFuaXB1bGF0aW9uIG9mIGNvbmZpZ3VyYXRpb24uXG4gICAgLy8gTm90IGF2YWlsYWJsZSBpbiBJRTgsIFNhZmFyaSA1LCBldGMuXG4gICAgaWYgKGZyZWV6ZSkge1xuICAgICAgZnJlZXplKGNmZyk7XG4gICAgfVxuICAgIENPTkZJRyA9IGNmZztcbiAgfTtcbiAgLyogS2VlcCB0cmFjayBvZiBhbGwgcG9zc2libGUgU1ZHIGFuZCBNYXRoTUwgdGFnc1xuICAgKiBzbyB0aGF0IHdlIGNhbiBwZXJmb3JtIHRoZSBuYW1lc3BhY2UgY2hlY2tzXG4gICAqIGNvcnJlY3RseS4gKi9cbiAgY29uc3QgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5zdmckMSwgLi4uc3ZnRmlsdGVycywgLi4uc3ZnRGlzYWxsb3dlZF0pO1xuICBjb25zdCBBTExfTUFUSE1MX1RBR1MgPSBhZGRUb1NldCh7fSwgWy4uLm1hdGhNbCQxLCAuLi5tYXRoTWxEaXNhbGxvd2VkXSk7XG4gIC8qKlxuICAgKiBAcGFyYW0gZWxlbWVudCBhIERPTSBlbGVtZW50IHdob3NlIG5hbWVzcGFjZSBpcyBiZWluZyBjaGVja2VkXG4gICAqIEByZXR1cm5zIFJldHVybiBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYVxuICAgKiAgbmFtZXNwYWNlIHRoYXQgYSBzcGVjLWNvbXBsaWFudCBwYXJzZXIgd291bGQgbmV2ZXJcbiAgICogIHJldHVybi4gUmV0dXJuIHRydWUgb3RoZXJ3aXNlLlxuICAgKi9cbiAgY29uc3QgX2NoZWNrVmFsaWROYW1lc3BhY2UgPSBmdW5jdGlvbiBfY2hlY2tWYWxpZE5hbWVzcGFjZShlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gICAgLy8gSW4gSlNET00sIGlmIHdlJ3JlIGluc2lkZSBzaGFkb3cgRE9NLCB0aGVuIHBhcmVudE5vZGVcbiAgICAvLyBjYW4gYmUgbnVsbC4gV2UganVzdCBzaW11bGF0ZSBwYXJlbnQgaW4gdGhpcyBjYXNlLlxuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQudGFnTmFtZSkge1xuICAgICAgcGFyZW50ID0ge1xuICAgICAgICBuYW1lc3BhY2VVUkk6IE5BTUVTUEFDRSxcbiAgICAgICAgdGFnTmFtZTogJ3RlbXBsYXRlJ1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgY29uc3QgcGFyZW50VGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKHBhcmVudC50YWdOYW1lKTtcbiAgICBpZiAoIUFMTE9XRURfTkFNRVNQQUNFU1tlbGVtZW50Lm5hbWVzcGFjZVVSSV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gU1ZHXG4gICAgICAvLyBpcyB2aWEgPHN2Zz4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgfVxuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIE1hdGhNTCB0byBTVkcgaXMgdmlhYFxuICAgICAgLy8gc3ZnIGlmIHBhcmVudCBpcyBlaXRoZXIgPGFubm90YXRpb24teG1sPiBvciBNYXRoTUxcbiAgICAgIC8vIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnICYmIChwYXJlbnRUYWdOYW1lID09PSAnYW5ub3RhdGlvbi14bWwnIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gU1ZHXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIFNWRyBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBNYXRoTUxcbiAgICAgIC8vIGlzIHZpYSA8bWF0aD4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJztcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gTWF0aE1MIGlzIHZpYVxuICAgICAgLy8gPG1hdGg+IGFuZCBIVE1MIGludGVncmF0aW9uIHBvaW50c1xuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBNYXRoTUxcbiAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gTWF0aE1MIG5hbWVzcGFjZS5cbiAgICAgIHJldHVybiBCb29sZWFuKEFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gSFRNTCBpcyB2aWFcbiAgICAgIC8vIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzLCBhbmQgZnJvbSBNYXRoTUwgdG8gSFRNTFxuICAgICAgLy8gaXMgdmlhIE1hdGhNTCB0ZXh0IGludGVncmF0aW9uIHBvaW50c1xuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gV2UgZGlzYWxsb3cgdGFncyB0aGF0IGFyZSBzcGVjaWZpYyBmb3IgTWF0aE1MXG4gICAgICAvLyBvciBTVkcgYW5kIHNob3VsZCBuZXZlciBhcHBlYXIgaW4gSFRNTCBuYW1lc3BhY2VcbiAgICAgIHJldHVybiAhQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdICYmIChDT01NT05fU1ZHX0FORF9IVE1MX0VMRU1FTlRTW3RhZ05hbWVdIHx8ICFBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cbiAgICAvLyBGb3IgWEhUTUwgYW5kIFhNTCBkb2N1bWVudHMgdGhhdCBzdXBwb3J0IGN1c3RvbSBuYW1lc3BhY2VzXG4gICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyAmJiBBTExPV0VEX05BTUVTUEFDRVNbZWxlbWVudC5uYW1lc3BhY2VVUkldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVGhlIGNvZGUgc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcGxhY2UgKHRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IHRoZSBlbGVtZW50IHNvbWVob3cgZ290IG5hbWVzcGFjZSB0aGF0IGlzIG5vdFxuICAgIC8vIEhUTUwsIFNWRywgTWF0aE1MIG9yIGFsbG93ZWQgdmlhIEFMTE9XRURfTkFNRVNQQUNFUykuXG4gICAgLy8gUmV0dXJuIGZhbHNlIGp1c3QgaW4gY2FzZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiBfZm9yY2VSZW1vdmVcbiAgICpcbiAgICogQHBhcmFtIG5vZGUgYSBET00gbm9kZVxuICAgKi9cbiAgY29uc3QgX2ZvcmNlUmVtb3ZlID0gZnVuY3Rpb24gX2ZvcmNlUmVtb3ZlKG5vZGUpIHtcbiAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLXJlbW92ZVxuICAgICAgZ2V0UGFyZW50Tm9kZShub2RlKS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZW1vdmUobm9kZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogX3JlbW92ZUF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBhbiBBdHRyaWJ1dGUgbmFtZVxuICAgKiBAcGFyYW0gZWxlbWVudCBhIERPTSBub2RlXG4gICAqL1xuICBjb25zdCBfcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IGVsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZShuYW1lKSxcbiAgICAgICAgZnJvbTogZWxlbWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgZnJvbTogZWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIC8vIFdlIHZvaWQgYXR0cmlidXRlIHZhbHVlcyBmb3IgdW5yZW1vdmFibGUgXCJpc1wiIGF0dHJpYnV0ZXNcbiAgICBpZiAobmFtZSA9PT0gJ2lzJykge1xuICAgICAgaWYgKFJFVFVSTl9ET00gfHwgUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIF9pbml0RG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGRpcnR5IC0gYSBzdHJpbmcgb2YgZGlydHkgbWFya3VwXG4gICAqIEByZXR1cm4gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICovXG4gIGNvbnN0IF9pbml0RG9jdW1lbnQgPSBmdW5jdGlvbiBfaW5pdERvY3VtZW50KGRpcnR5KSB7XG4gICAgLyogQ3JlYXRlIGEgSFRNTCBkb2N1bWVudCAqL1xuICAgIGxldCBkb2MgPSBudWxsO1xuICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZSA9IG51bGw7XG4gICAgaWYgKEZPUkNFX0JPRFkpIHtcbiAgICAgIGRpcnR5ID0gJzxyZW1vdmU+PC9yZW1vdmU+JyArIGRpcnR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBJZiBGT1JDRV9CT0RZIGlzbid0IHVzZWQsIGxlYWRpbmcgd2hpdGVzcGFjZSBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgbWFudWFsbHkgKi9cbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbiAgICB9XG4gICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyAmJiBOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBSb290IG9mIFhIVE1MIGRvYyBtdXN0IGNvbnRhaW4geG1sbnMgZGVjbGFyYXRpb24gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIveGh0bWwxL25vcm1hdGl2ZS5odG1sI3N0cmljdClcbiAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgIH1cbiAgICBjb25zdCBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAvKlxuICAgICAqIFVzZSB0aGUgRE9NUGFyc2VyIEFQSSBieSBkZWZhdWx0LCBmYWxsYmFjayBsYXRlciBpZiBuZWVkcyBiZVxuICAgICAqIERPTVBhcnNlciBub3Qgd29yayBmb3Igc3ZnIHdoZW4gaGFzIG11bHRpcGxlIHJvb3QgZWxlbWVudC5cbiAgICAgKi9cbiAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsIFBBUlNFUl9NRURJQV9UWVBFKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgfVxuICAgIC8qIFVzZSBjcmVhdGVIVE1MRG9jdW1lbnQgaW4gY2FzZSBET01QYXJzZXIgaXMgbm90IGF2YWlsYWJsZSAqL1xuICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBkb2MgPSBpbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudChOQU1FU1BBQ0UsICd0ZW1wbGF0ZScsIG51bGwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/IGVtcHR5SFRNTCA6IGRpcnR5UGF5bG9hZDtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gU3ludGF4IGVycm9yIGlmIGRpcnR5UGF5bG9hZCBpcyBpbnZhbGlkIHhtbFxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBib2R5ID0gZG9jLmJvZHkgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxlYWRpbmdXaGl0ZXNwYWNlKSwgYm9keS5jaGlsZE5vZGVzWzBdIHx8IG51bGwpO1xuICAgIH1cbiAgICAvKiBXb3JrIG9uIHdob2xlIGRvY3VtZW50IG9yIGp1c3QgaXRzIGJvZHkgKi9cbiAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlUYWdOYW1lLmNhbGwoZG9jLCBXSE9MRV9ET0NVTUVOVCA/ICdodG1sJyA6ICdib2R5JylbMF07XG4gICAgfVxuICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIE5vZGVJdGVyYXRvciBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSB0byB0cmF2ZXJzZSBmaWx0ZXJlZCBsaXN0cyBvZiBub2RlcyBvciBlbGVtZW50cyBpbiBhIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcm9vdCBUaGUgcm9vdCBlbGVtZW50IG9yIG5vZGUgdG8gc3RhcnQgdHJhdmVyc2luZyBvbi5cbiAgICogQHJldHVybiBUaGUgY3JlYXRlZCBOb2RlSXRlcmF0b3JcbiAgICovXG4gIGNvbnN0IF9jcmVhdGVOb2RlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlTm9kZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQgfCBOb2RlRmlsdGVyLlNIT1dfUFJPQ0VTU0lOR19JTlNUUlVDVElPTiB8IE5vZGVGaWx0ZXIuU0hPV19DREFUQV9TRUNUSU9OLCBudWxsKTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc0Nsb2JiZXJlZFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50IHRvIGNoZWNrIGZvciBjbG9iYmVyaW5nIGF0dGFja3NcbiAgICogQHJldHVybiB0cnVlIGlmIGNsb2JiZXJlZCwgZmFsc2UgaWYgc2FmZVxuICAgKi9cbiAgY29uc3QgX2lzQ2xvYmJlcmVkID0gZnVuY3Rpb24gX2lzQ2xvYmJlcmVkKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50LnRleHRDb250ZW50ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC5yZW1vdmVDaGlsZCAhPT0gJ2Z1bmN0aW9uJyB8fCAhKGVsZW1lbnQuYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbGVtZW50LnNldEF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50Lmluc2VydEJlZm9yZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC5oYXNDaGlsZE5vZGVzICE9PSAnZnVuY3Rpb24nKTtcbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSBET00gbm9kZVxuICAgKiBAcmV0dXJuIHRydWUgaXMgb2JqZWN0IGlzIGEgRE9NIG5vZGVcbiAgICovXG4gIGNvbnN0IF9pc05vZGUgPSBmdW5jdGlvbiBfaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgTm9kZTtcbiAgfTtcbiAgZnVuY3Rpb24gX2V4ZWN1dGVIb29rcyhob29rcywgY3VycmVudE5vZGUsIGRhdGEpIHtcbiAgICBhcnJheUZvckVhY2goaG9va3MsIGhvb2sgPT4ge1xuICAgICAgaG9vay5jYWxsKERPTVB1cmlmeSwgY3VycmVudE5vZGUsIGRhdGEsIENPTkZJRyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUVsZW1lbnRzXG4gICAqXG4gICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAqIEBwcm90ZWN0IHRleHRDb250ZW50XG4gICAqIEBwcm90ZWN0IHJlbW92ZUNoaWxkXG4gICAqIEBwYXJhbSBjdXJyZW50Tm9kZSB0byBjaGVjayBmb3IgcGVybWlzc2lvbiB0byBleGlzdFxuICAgKiBAcmV0dXJuIHRydWUgaWYgbm9kZSB3YXMga2lsbGVkLCBmYWxzZSBpZiBsZWZ0IGFsaXZlXG4gICAqL1xuICBjb25zdCBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBudWxsO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmJlZm9yZVNhbml0aXplRWxlbWVudHMsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgICAvKiBDaGVjayBpZiBlbGVtZW50IGlzIGNsb2JiZXJlZCBvciBjYW4gY2xvYmJlciAqL1xuICAgIGlmIChfaXNDbG9iYmVyZWQoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIE5vdyBsZXQncyBjaGVjayB0aGUgZWxlbWVudCdzIHR5cGUgYW5kIG5hbWUgKi9cbiAgICBjb25zdCB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLnVwb25TYW5pdGl6ZUVsZW1lbnQsIGN1cnJlbnROb2RlLCB7XG4gICAgICB0YWdOYW1lLFxuICAgICAgYWxsb3dlZFRhZ3M6IEFMTE9XRURfVEFHU1xuICAgIH0pO1xuICAgIC8qIERldGVjdCBtWFNTIGF0dGVtcHRzIGFidXNpbmcgbmFtZXNwYWNlIGNvbmZ1c2lvbiAqL1xuICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgY3VycmVudE5vZGUuaGFzQ2hpbGROb2RlcygpICYmICFfaXNOb2RlKGN1cnJlbnROb2RlLmZpcnN0RWxlbWVudENoaWxkKSAmJiByZWdFeHBUZXN0KC88Wy9cXHchXS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcdyFdL2csIGN1cnJlbnROb2RlLnRleHRDb250ZW50KSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgYW55IG9jY3VycmVuY2Ugb2YgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnMgKi9cbiAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS5wcm9ncmVzc2luZ0luc3RydWN0aW9uKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIFJlbW92ZSBhbnkga2luZCBvZiBwb3NzaWJseSBoYXJtZnVsIGNvbW1lbnRzICovXG4gICAgaWYgKFNBRkVfRk9SX1hNTCAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTk9ERV9UWVBFLmNvbW1lbnQgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5kYXRhKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgZWxlbWVudCBpZiBhbnl0aGluZyBmb3JiaWRzIGl0cyBwcmVzZW5jZSAqL1xuICAgIGlmICghKEVYVFJBX0VMRU1FTlRfSEFORExJTkcudGFnQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBFWFRSQV9FTEVNRU5UX0hBTkRMSU5HLnRhZ0NoZWNrKHRhZ05hbWUpKSAmJiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkpIHtcbiAgICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYSBjdXN0b20gZWxlbWVudCB0byBoYW5kbGUgKi9cbiAgICAgIGlmICghRk9SQklEX1RBR1NbdGFnTmFtZV0gJiYgX2lzQmFzaWNDdXN0b21FbGVtZW50KHRhZ05hbWUpKSB7XG4gICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHRhZ05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodGFnTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIEtlZXAgY29udGVudCBleGNlcHQgZm9yIGJhZC1saXN0ZWQgZWxlbWVudHMgKi9cbiAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzICYmIHBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZENvdW50ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkQ291bnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDbG9uZSA9IGNsb25lTm9kZShjaGlsZE5vZGVzW2ldLCB0cnVlKTtcbiAgICAgICAgICAgIGNoaWxkQ2xvbmUuX19yZW1vdmFsQ291bnQgPSAoY3VycmVudE5vZGUuX19yZW1vdmFsQ291bnQgfHwgMCkgKyAxO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGRDbG9uZSwgZ2V0TmV4dFNpYmxpbmcoY3VycmVudE5vZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogQ2hlY2sgd2hldGhlciBlbGVtZW50IGhhcyBhIHZhbGlkIG5hbWVzcGFjZSAqL1xuICAgIGlmIChjdXJyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIV9jaGVja1ZhbGlkTmFtZXNwYWNlKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBNYWtlIHN1cmUgdGhhdCBvbGRlciBicm93c2VycyBkb24ndCBnZXQgZmFsbGJhY2stdGFnIG1YU1MgKi9cbiAgICBpZiAoKHRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHwgdGFnTmFtZSA9PT0gJ25vZW1iZWQnIHx8IHRhZ05hbWUgPT09ICdub2ZyYW1lcycpICYmIHJlZ0V4cFRlc3QoLzxcXC9ubyhzY3JpcHR8ZW1iZWR8ZnJhbWVzKS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIFNhbml0aXplIGVsZW1lbnQgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUyAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTk9ERV9UWVBFLnRleHQpIHtcbiAgICAgIC8qIEdldCB0aGUgZWxlbWVudCdzIHRleHQgY29udGVudCAqL1xuICAgICAgY29udGVudCA9IGN1cnJlbnROb2RlLnRleHRDb250ZW50O1xuICAgICAgYXJyYXlGb3JFYWNoKFtNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiwgVE1QTElUX0VYUFJdLCBleHByID0+IHtcbiAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgZXhwciwgJyAnKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgIGVsZW1lbnQ6IGN1cnJlbnROb2RlLmNsb25lTm9kZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmFmdGVyU2FuaXRpemVFbGVtZW50cywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc1ZhbGlkQXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSBsY1RhZyBMb3dlcmNhc2UgdGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0gbGNOYW1lIExvd2VyY2FzZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICogQHBhcmFtIHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogQHJldHVybiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgY29uc3QgX2lzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkge1xuICAgIC8qIE1ha2Ugc3VyZSBhdHRyaWJ1dGUgY2Fubm90IGNsb2JiZXIgKi9cbiAgICBpZiAoU0FOSVRJWkVfRE9NICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpICYmICh2YWx1ZSBpbiBkb2N1bWVudCB8fCB2YWx1ZSBpbiBmb3JtRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyogQWxsb3cgdmFsaWQgZGF0YS0qIGF0dHJpYnV0ZXM6IEF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgYWZ0ZXIgXCItXCJcbiAgICAgICAgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI2VtYmVkZGluZy1jdXN0b20tbm9uLXZpc2libGUtZGF0YS13aXRoLXRoZS1kYXRhLSotYXR0cmlidXRlcylcbiAgICAgICAgWE1MLWNvbXBhdGlibGUgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjeG1sLWNvbXBhdGlibGUgYW5kIGh0dHA6Ly93d3cudzMub3JnL1RSL3htbC8jZDBlODA0KVxuICAgICAgICBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIHRoZSB2YWx1ZTsgaXQncyBhbHdheXMgVVJJIHNhZmUuICovXG4gICAgaWYgKEFMTE9XX0RBVEFfQVRUUiAmJiAhRk9SQklEX0FUVFJbbGNOYW1lXSAmJiByZWdFeHBUZXN0KERBVEFfQVRUUiwgbGNOYW1lKSkgOyBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIsIGxjTmFtZSkpIDsgZWxzZSBpZiAoRVhUUkFfRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIEVYVFJBX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlQ2hlY2sobGNOYW1lLCBsY1RhZykpIDsgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgIGlmIChcbiAgICAgIC8vIEZpcnN0IGNvbmRpdGlvbiBkb2VzIGEgdmVyeSBiYXNpYyBjaGVjayBpZiBhKSBpdCdzIGJhc2ljYWxseSBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IHRhZ25hbWUgQU5EXG4gICAgICAvLyBiKSBpZiB0aGUgdGFnTmFtZSBwYXNzZXMgd2hhdGV2ZXIgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZm9yIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVja1xuICAgICAgLy8gYW5kIGMpIGlmIHRoZSBhdHRyaWJ1dGUgbmFtZSBwYXNzZXMgd2hhdGV2ZXIgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZm9yIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVja1xuICAgICAgX2lzQmFzaWNDdXN0b21FbGVtZW50KGxjVGFnKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrLCBsY1RhZykgfHwgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKGxjVGFnKSkgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaywgbGNOYW1lKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sobGNOYW1lLCBsY1RhZykpIHx8XG4gICAgICAvLyBBbHRlcm5hdGl2ZSwgc2Vjb25kIGNvbmRpdGlvbiBjaGVja3MgaWYgaXQncyBhbiBgaXNgLWF0dHJpYnV0ZSwgQU5EXG4gICAgICAvLyB0aGUgdmFsdWUgcGFzc2VzIHdoYXRldmVyIHRoZSB1c2VyIGhhcyBjb25maWd1cmVkIGZvciBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2tcbiAgICAgIGxjTmFtZSA9PT0gJ2lzJyAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdmFsdWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayh2YWx1ZSkpKSA7IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvKiBDaGVjayB2YWx1ZSBpcyBzYWZlLiBGaXJzdCwgaXMgYXR0ciBpbmVydD8gSWYgc28sIGlzIHNhZmUgKi9cbiAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSkgOyBlbHNlIGlmIChyZWdFeHBUZXN0KElTX0FMTE9XRURfVVJJJDEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSwgJycpKSkgOyBlbHNlIGlmICgobGNOYW1lID09PSAnc3JjJyB8fCBsY05hbWUgPT09ICd4bGluazpocmVmJyB8fCBsY05hbWUgPT09ICdocmVmJykgJiYgbGNUYWcgIT09ICdzY3JpcHQnICYmIHN0cmluZ0luZGV4T2YodmFsdWUsICdkYXRhOicpID09PSAwICYmIERBVEFfVVJJX1RBR1NbbGNUYWddKSA7IGVsc2UgaWYgKEFMTE9XX1VOS05PV05fUFJPVE9DT0xTICYmICFyZWdFeHBUZXN0KElTX1NDUklQVF9PUl9EQVRBLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UsICcnKSkpIDsgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogX2lzQmFzaWNDdXN0b21FbGVtZW50XG4gICAqIGNoZWNrcyBpZiBhdCBsZWFzdCBvbmUgZGFzaCBpcyBpbmNsdWRlZCBpbiB0YWdOYW1lLCBhbmQgaXQncyBub3QgdGhlIGZpcnN0IGNoYXJcbiAgICogZm9yIG1vcmUgc29waGlzdGljYXRlZCBjaGVja2luZyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy92YWxpZGF0ZS1lbGVtZW50LW5hbWVcbiAgICpcbiAgICogQHBhcmFtIHRhZ05hbWUgbmFtZSBvZiB0aGUgdGFnIG9mIHRoZSBub2RlIHRvIHNhbml0aXplXG4gICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIG5hbWUgbWVldHMgdGhlIGJhc2ljIGNyaXRlcmlhIGZvciBhIGN1c3RvbSBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBjb25zdCBfaXNCYXNpY0N1c3RvbUVsZW1lbnQgPSBmdW5jdGlvbiBfaXNCYXNpY0N1c3RvbUVsZW1lbnQodGFnTmFtZSkge1xuICAgIHJldHVybiB0YWdOYW1lICE9PSAnYW5ub3RhdGlvbi14bWwnICYmIHN0cmluZ01hdGNoKHRhZ05hbWUsIENVU1RPTV9FTEVNRU5UKTtcbiAgfTtcbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHByb3RlY3QgYXR0cmlidXRlc1xuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCByZW1vdmVBdHRyaWJ1dGVcbiAgICogQHByb3RlY3Qgc2V0QXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSBjdXJyZW50Tm9kZSB0byBzYW5pdGl6ZVxuICAgKi9cbiAgY29uc3QgX3Nhbml0aXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpIHtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5iZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGN1cnJlbnROb2RlO1xuICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYXR0cmlidXRlczsgaWYgbm90IHdlIG1pZ2h0IGhhdmUgYSB0ZXh0IG5vZGUgKi9cbiAgICBpZiAoIWF0dHJpYnV0ZXMgfHwgX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob29rRXZlbnQgPSB7XG4gICAgICBhdHRyTmFtZTogJycsXG4gICAgICBhdHRyVmFsdWU6ICcnLFxuICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICBhbGxvd2VkQXR0cmlidXRlczogQUxMT1dFRF9BVFRSLFxuICAgICAgZm9yY2VLZWVwQXR0cjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBsZXQgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgIC8qIEdvIGJhY2t3YXJkcyBvdmVyIGFsbCBhdHRyaWJ1dGVzOyBzYWZlbHkgcmVtb3ZlIGJhZCBvbmVzICovXG4gICAgd2hpbGUgKGwtLSkge1xuICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbbF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG5hbWVzcGFjZVVSSSxcbiAgICAgICAgdmFsdWU6IGF0dHJWYWx1ZVxuICAgICAgfSA9IGF0dHI7XG4gICAgICBjb25zdCBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhuYW1lKTtcbiAgICAgIGNvbnN0IGluaXRWYWx1ZSA9IGF0dHJWYWx1ZTtcbiAgICAgIGxldCB2YWx1ZSA9IG5hbWUgPT09ICd2YWx1ZScgPyBpbml0VmFsdWUgOiBzdHJpbmdUcmltKGluaXRWYWx1ZSk7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICBob29rRXZlbnQuYXR0clZhbHVlID0gdmFsdWU7XG4gICAgICBob29rRXZlbnQua2VlcEF0dHIgPSB0cnVlO1xuICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7IC8vIEFsbG93cyBkZXZlbG9wZXJzIHRvIHNlZSB0aGlzIGlzIGEgcHJvcGVydHkgdGhleSBjYW4gc2V0XG4gICAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLnVwb25TYW5pdGl6ZUF0dHJpYnV0ZSwgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG4gICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7XG4gICAgICAvKiBGdWxsIERPTSBDbG9iYmVyaW5nIHByb3RlY3Rpb24gdmlhIG5hbWVzcGFjZSBpc29sYXRpb24sXG4gICAgICAgKiBQcmVmaXggaWQgYW5kIG5hbWUgYXR0cmlidXRlcyB3aXRoIGB1c2VyLWNvbnRlbnQtYFxuICAgICAgICovXG4gICAgICBpZiAoU0FOSVRJWkVfTkFNRURfUFJPUFMgJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGlzIHZhbHVlXG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAvLyBQcmVmaXggdGhlIHZhbHVlIGFuZCBsYXRlciByZS1jcmVhdGUgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBzYW5pdGl6ZWQgdmFsdWVcbiAgICAgICAgdmFsdWUgPSBTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVggKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgd2l0aCBjb21tZW50cyBpbnNpZGUgYXR0cmlidXRlcyAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1hNTCAmJiByZWdFeHBUZXN0KC8oKC0tIT98XSk+KXw8XFwvKHN0eWxlfHRpdGxlfHRleHRhcmVhKS9pLCB2YWx1ZSkpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogTWFrZSBzdXJlIHdlIGNhbm5vdCBlYXNpbHkgdXNlIGFuaW1hdGVkIGhyZWZzLCBldmVuIGlmIGFuaW1hdGlvbnMgYXJlIGFsbG93ZWQgKi9cbiAgICAgIGlmIChsY05hbWUgPT09ICdhdHRyaWJ1dGVuYW1lJyAmJiBzdHJpbmdNYXRjaCh2YWx1ZSwgJ2hyZWYnKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogV29yayBhcm91bmQgYSBzZWN1cml0eSBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG4gICAgICBpZiAoIUFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiAmJiByZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBTYW5pdGl6ZSBhdHRyaWJ1dGUgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIGFycmF5Rm9yRWFjaChbTVVTVEFDSEVfRVhQUiwgRVJCX0VYUFIsIFRNUExJVF9FWFBSXSwgZXhwciA9PiB7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBleHByLCAnICcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qIElzIGB2YWx1ZWAgdmFsaWQgZm9yIHRoaXMgYXR0cmlidXRlPyAqL1xuICAgICAgY29uc3QgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG4gICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBIYW5kbGUgYXR0cmlidXRlcyB0aGF0IHJlcXVpcmUgVHJ1c3RlZCBUeXBlcyAqL1xuICAgICAgaWYgKHRydXN0ZWRUeXBlc1BvbGljeSAmJiB0eXBlb2YgdHJ1c3RlZFR5cGVzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHJ1c3RlZFR5cGVzLmdldEF0dHJpYnV0ZVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkgOyBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKHRydXN0ZWRUeXBlcy5nZXRBdHRyaWJ1dGVUeXBlKGxjVGFnLCBsY05hbWUpKSB7XG4gICAgICAgICAgICBjYXNlICdUcnVzdGVkSFRNTCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVHJ1c3RlZFNjcmlwdFVSTCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVTY3JpcHRVUkwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBIYW5kbGUgaW52YWxpZCBkYXRhLSogYXR0cmlidXRlIHNldCBieSB0cnktY2F0Y2hpbmcgaXQgKi9cbiAgICAgIGlmICh2YWx1ZSAhPT0gaW5pdFZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UG9wKERPTVB1cmlmeS5yZW1vdmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5hZnRlclNhbml0aXplQXR0cmlidXRlcywgY3VycmVudE5vZGUsIG51bGwpO1xuICB9O1xuICAvKipcbiAgICogX3Nhbml0aXplU2hhZG93RE9NXG4gICAqXG4gICAqIEBwYXJhbSBmcmFnbWVudCB0byBpdGVyYXRlIG92ZXIgcmVjdXJzaXZlbHlcbiAgICovXG4gIGNvbnN0IF9zYW5pdGl6ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uIF9zYW5pdGl6ZVNoYWRvd0RPTShmcmFnbWVudCkge1xuICAgIGxldCBzaGFkb3dOb2RlID0gbnVsbDtcbiAgICBjb25zdCBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVOb2RlSXRlcmF0b3IoZnJhZ21lbnQpO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmJlZm9yZVNhbml0aXplU2hhZG93RE9NLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgd2hpbGUgKHNoYWRvd05vZGUgPSBzaGFkb3dJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLnVwb25TYW5pdGl6ZVNoYWRvd05vZGUsIHNoYWRvd05vZGUsIG51bGwpO1xuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIF9zYW5pdGl6ZUVsZW1lbnRzKHNoYWRvd05vZGUpO1xuICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcyBuZXh0ICovXG4gICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKHNoYWRvd05vZGUpO1xuICAgICAgLyogRGVlcCBzaGFkb3cgRE9NIGRldGVjdGVkICovXG4gICAgICBpZiAoc2hhZG93Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTSwgZnJhZ21lbnQsIG51bGwpO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHkpIHtcbiAgICBsZXQgY2ZnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgbGV0IGltcG9ydGVkTm9kZSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbnVsbDtcbiAgICBsZXQgcmV0dXJuTm9kZSA9IG51bGw7XG4gICAgLyogTWFrZSBzdXJlIHdlIGhhdmUgYSBzdHJpbmcgdG8gc2FuaXRpemUuXG4gICAgICBETyBOT1QgcmV0dXJuIGVhcmx5LCBhcyB0aGlzIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyB0eXBlIGlmXG4gICAgICB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIGEgRE9NIG9iamVjdCByYXRoZXIgdGhhbiBhIHN0cmluZyAqL1xuICAgIElTX0VNUFRZX0lOUFVUID0gIWRpcnR5O1xuICAgIGlmIChJU19FTVBUWV9JTlBVVCkge1xuICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgIH1cbiAgICAvKiBTdHJpbmdpZnksIGluIGNhc2UgZGlydHkgaXMgYW4gb2JqZWN0ICovXG4gICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycgJiYgIV9pc05vZGUoZGlydHkpKSB7XG4gICAgICBpZiAodHlwZW9mIGRpcnR5LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnR5ID0gZGlydHkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ2RpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCd0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSZXR1cm4gZGlydHkgSFRNTCBpZiBET01QdXJpZnkgY2Fubm90IHJ1biAqL1xuICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIC8qIEFzc2lnbiBjb25maWcgdmFycyAqL1xuICAgIGlmICghU0VUX0NPTkZJRykge1xuICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgfVxuICAgIC8qIENsZWFuIHVwIHJlbW92ZWQgZWxlbWVudHMgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cbiAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICAvKiBEbyBzb21lIGVhcmx5IHByZS1zYW5pdGl6YXRpb24gdG8gYXZvaWQgdW5zYWZlIHJvb3Qgbm9kZXMgKi9cbiAgICAgIGlmIChkaXJ0eS5ub2RlTmFtZSkge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoZGlydHkubm9kZU5hbWUpO1xuICAgICAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgncm9vdCBub2RlIGlzIGZvcmJpZGRlbiBhbmQgY2Fubm90IGJlIHNhbml0aXplZCBpbi1wbGFjZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJ0eSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIC8qIElmIGRpcnR5IGlzIGEgRE9NIGVsZW1lbnQsIGFwcGVuZCB0byBhbiBlbXB0eSBkb2N1bWVudCB0byBhdm9pZFxuICAgICAgICAgZWxlbWVudHMgYmVpbmcgc3RyaXBwZWQgYnkgdGhlIHBhcnNlciAqL1xuICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoJzwhLS0tLT4nKTtcbiAgICAgIGltcG9ydGVkTm9kZSA9IGJvZHkub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKGRpcnR5LCB0cnVlKTtcbiAgICAgIGlmIChpbXBvcnRlZE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS5lbGVtZW50ICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIC8qIE5vZGUgaXMgYWxyZWFkeSBhIGJvZHksIHVzZSBhcyBpcyAqL1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGltcG9ydGVkTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIEV4aXQgZGlyZWN0bHkgaWYgd2UgaGF2ZSBub3RoaW5nIHRvIGRvICovXG4gICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIH1cbiAgICAgIC8qIEluaXRpYWxpemUgdGhlIGRvY3VtZW50IHRvIHdvcmsgb24gKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcbiAgICAgIC8qIENoZWNrIHdlIGhhdmUgYSBET00gbm9kZSBmcm9tIHRoZSBkYXRhICovXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIFJFVFVSTl9ET00gPyBudWxsIDogUkVUVVJOX1RSVVNURURfVFlQRSA/IGVtcHR5SFRNTCA6ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSZW1vdmUgZmlyc3QgZWxlbWVudCBub2RlIChvdXJzKSBpZiBGT1JDRV9CT0RZIGlzIHNldCAqL1xuICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvKiBHZXQgbm9kZSBpdGVyYXRvciAqL1xuICAgIGNvbnN0IG5vZGVJdGVyYXRvciA9IF9jcmVhdGVOb2RlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuICAgIC8qIE5vdyBzdGFydCBpdGVyYXRpbmcgb3ZlciB0aGUgY3JlYXRlZCBkb2N1bWVudCAqL1xuICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuICAgICAgX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpO1xuICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcyBuZXh0ICovXG4gICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKTtcbiAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICAvKiBSZXR1cm4gc2FuaXRpemVkIHN0cmluZyBvciBET00gKi9cbiAgICBpZiAoUkVUVVJOX0RPTSkge1xuICAgICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChib2R5Lm93bmVyRG9jdW1lbnQpO1xuICAgICAgICB3aGlsZSAoYm9keS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICB9XG4gICAgICBpZiAoQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3QgfHwgQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3Rtb2RlKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgQWRvcHROb2RlKCkgaXMgbm90IHVzZWQgYmVjYXVzZSBpbnRlcm5hbCBzdGF0ZSBpcyBub3QgcmVzZXRcbiAgICAgICAgICAoZS5nLiB0aGUgcGFzdCBuYW1lcyBtYXAgb2YgYSBIVE1MRm9ybUVsZW1lbnQpLCB0aGlzIGlzIHNhZmVcbiAgICAgICAgICBpbiB0aGVvcnkgYnV0IHdlIHdvdWxkIHJhdGhlciBub3QgcmlzayBhbm90aGVyIGF0dGFjayB2ZWN0b3IuXG4gICAgICAgICAgVGhlIHN0YXRlIHRoYXQgaXMgY2xvbmVkIGJ5IGltcG9ydE5vZGUoKSBpcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICBieSB0aGUgc3BlY3MuXG4gICAgICAgICovXG4gICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuTm9kZTtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuICAgIC8qIFNlcmlhbGl6ZSBkb2N0eXBlIGlmIGFsbG93ZWQgKi9cbiAgICBpZiAoV0hPTEVfRE9DVU1FTlQgJiYgQUxMT1dFRF9UQUdTWychZG9jdHlwZSddICYmIGJvZHkub3duZXJEb2N1bWVudCAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZSAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lICYmIHJlZ0V4cFRlc3QoRE9DVFlQRV9OQU1FLCBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lKSkge1xuICAgICAgc2VyaWFsaXplZEhUTUwgPSAnPCFET0NUWVBFICcgKyBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lICsgJz5cXG4nICsgc2VyaWFsaXplZEhUTUw7XG4gICAgfVxuICAgIC8qIFNhbml0aXplIGZpbmFsIHN0cmluZyB0ZW1wbGF0ZS1zYWZlICovXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgYXJyYXlGb3JFYWNoKFtNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiwgVE1QTElUX0VYUFJdLCBleHByID0+IHtcbiAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBleHByLCAnICcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICB9O1xuICBET01QdXJpZnkuc2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBjZmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIFNFVF9DT05GSUcgPSB0cnVlO1xuICB9O1xuICBET01QdXJpZnkuY2xlYXJDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgQ09ORklHID0gbnVsbDtcbiAgICBTRVRfQ09ORklHID0gZmFsc2U7XG4gIH07XG4gIERPTVB1cmlmeS5pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gKHRhZywgYXR0ciwgdmFsdWUpIHtcbiAgICAvKiBJbml0aWFsaXplIHNoYXJlZCBjb25maWcgdmFycyBpZiBuZWNlc3NhcnkuICovXG4gICAgaWYgKCFDT05GSUcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyh7fSk7XG4gICAgfVxuICAgIGNvbnN0IGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmModGFnKTtcbiAgICBjb25zdCBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhhdHRyKTtcbiAgICByZXR1cm4gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpO1xuICB9O1xuICBET01QdXJpZnkuYWRkSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIGhvb2tGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcnJheVB1c2goaG9va3NbZW50cnlQb2ludF0sIGhvb2tGdW5jdGlvbik7XG4gIH07XG4gIERPTVB1cmlmeS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGhvb2tGdW5jdGlvbikge1xuICAgIGlmIChob29rRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBhcnJheUxhc3RJbmRleE9mKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IHVuZGVmaW5lZCA6IGFycmF5U3BsaWNlKGhvb2tzW2VudHJ5UG9pbnRdLCBpbmRleCwgMSlbMF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gIH07XG4gIERPTVB1cmlmeS5yZW1vdmVIb29rcyA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgaG9va3NbZW50cnlQb2ludF0gPSBbXTtcbiAgfTtcbiAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgIGhvb2tzID0gX2NyZWF0ZUhvb2tzTWFwKCk7XG4gIH07XG4gIHJldHVybiBET01QdXJpZnk7XG59XG52YXIgcHVyaWZ5ID0gY3JlYXRlRE9NUHVyaWZ5KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcHVyaWZ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVyaWZ5LmNqcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJlbnRyaWVzIiwic2V0UHJvdG90eXBlT2YiLCJpc0Zyb3plbiIsImdldFByb3RvdHlwZU9mIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiT2JqZWN0IiwiZnJlZXplIiwic2VhbCIsImNyZWF0ZSIsImFwcGx5IiwiY29uc3RydWN0IiwiUmVmbGVjdCIsIngiLCJmdW5jIiwidGhpc0FyZyIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiRnVuYyIsIl9sZW4yIiwiX2tleTIiLCJhcnJheUZvckVhY2giLCJ1bmFwcGx5IiwicHJvdG90eXBlIiwiZm9yRWFjaCIsImFycmF5TGFzdEluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImFycmF5UG9wIiwicG9wIiwiYXJyYXlQdXNoIiwicHVzaCIsImFycmF5U3BsaWNlIiwic3BsaWNlIiwic3RyaW5nVG9Mb3dlckNhc2UiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInN0cmluZ1RvU3RyaW5nIiwidG9TdHJpbmciLCJzdHJpbmdNYXRjaCIsIm1hdGNoIiwic3RyaW5nUmVwbGFjZSIsInJlcGxhY2UiLCJzdHJpbmdJbmRleE9mIiwiaW5kZXhPZiIsInN0cmluZ1RyaW0iLCJ0cmltIiwib2JqZWN0SGFzT3duUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsInJlZ0V4cFRlc3QiLCJSZWdFeHAiLCJ0ZXN0IiwidHlwZUVycm9yQ3JlYXRlIiwidW5jb25zdHJ1Y3QiLCJUeXBlRXJyb3IiLCJsYXN0SW5kZXgiLCJfbGVuMyIsIl9rZXkzIiwiX2xlbjQiLCJfa2V5NCIsImFkZFRvU2V0Iiwic2V0IiwiYXJyYXkiLCJ0cmFuc2Zvcm1DYXNlRnVuYyIsInVuZGVmaW5lZCIsImwiLCJlbGVtZW50IiwibGNFbGVtZW50IiwiY2xlYW5BcnJheSIsImluZGV4IiwiaXNQcm9wZXJ0eUV4aXN0IiwiY2xvbmUiLCJvYmplY3QiLCJuZXdPYmplY3QiLCJwcm9wZXJ0eSIsInZhbHVlIiwiaXNBcnJheSIsImNvbnN0cnVjdG9yIiwibG9va3VwR2V0dGVyIiwicHJvcCIsImRlc2MiLCJnZXQiLCJmYWxsYmFja1ZhbHVlIiwiaHRtbCQxIiwic3ZnJDEiLCJzdmdGaWx0ZXJzIiwic3ZnRGlzYWxsb3dlZCIsIm1hdGhNbCQxIiwibWF0aE1sRGlzYWxsb3dlZCIsInRleHQiLCJodG1sIiwic3ZnIiwibWF0aE1sIiwieG1sIiwiTVVTVEFDSEVfRVhQUiIsIkVSQl9FWFBSIiwiVE1QTElUX0VYUFIiLCJEQVRBX0FUVFIiLCJBUklBX0FUVFIiLCJJU19BTExPV0VEX1VSSSIsIklTX1NDUklQVF9PUl9EQVRBIiwiQVRUUl9XSElURVNQQUNFIiwiRE9DVFlQRV9OQU1FIiwiQ1VTVE9NX0VMRU1FTlQiLCJFWFBSRVNTSU9OUyIsIl9fcHJvdG9fXyIsIk5PREVfVFlQRSIsImF0dHJpYnV0ZSIsImNkYXRhU2VjdGlvbiIsImVudGl0eVJlZmVyZW5jZSIsImVudGl0eU5vZGUiLCJwcm9ncmVzc2luZ0luc3RydWN0aW9uIiwiY29tbWVudCIsImRvY3VtZW50IiwiZG9jdW1lbnRUeXBlIiwiZG9jdW1lbnRGcmFnbWVudCIsIm5vdGF0aW9uIiwiZ2V0R2xvYmFsIiwid2luZG93IiwiX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSIsInRydXN0ZWRUeXBlcyIsInB1cmlmeUhvc3RFbGVtZW50IiwiY3JlYXRlUG9saWN5Iiwic3VmZml4IiwiQVRUUl9OQU1FIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicG9saWN5TmFtZSIsImNyZWF0ZUhUTUwiLCJjcmVhdGVTY3JpcHRVUkwiLCJzY3JpcHRVcmwiLCJfIiwiY29uc29sZSIsIndhcm4iLCJfY3JlYXRlSG9va3NNYXAiLCJhZnRlclNhbml0aXplQXR0cmlidXRlcyIsImFmdGVyU2FuaXRpemVFbGVtZW50cyIsImFmdGVyU2FuaXRpemVTaGFkb3dET00iLCJiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMiLCJiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzIiwiYmVmb3JlU2FuaXRpemVTaGFkb3dET00iLCJ1cG9uU2FuaXRpemVBdHRyaWJ1dGUiLCJ1cG9uU2FuaXRpemVFbGVtZW50IiwidXBvblNhbml0aXplU2hhZG93Tm9kZSIsImNyZWF0ZURPTVB1cmlmeSIsIkRPTVB1cmlmeSIsInJvb3QiLCJ2ZXJzaW9uIiwicmVtb3ZlZCIsIm5vZGVUeXBlIiwiRWxlbWVudCIsImlzU3VwcG9ydGVkIiwib3JpZ2luYWxEb2N1bWVudCIsImN1cnJlbnRTY3JpcHQiLCJEb2N1bWVudEZyYWdtZW50IiwiSFRNTFRlbXBsYXRlRWxlbWVudCIsIk5vZGUiLCJOb2RlRmlsdGVyIiwiTmFtZWROb2RlTWFwIiwiTW96TmFtZWRBdHRyTWFwIiwiSFRNTEZvcm1FbGVtZW50IiwiRE9NUGFyc2VyIiwiRWxlbWVudFByb3RvdHlwZSIsImNsb25lTm9kZSIsInJlbW92ZSIsImdldE5leHRTaWJsaW5nIiwiZ2V0Q2hpbGROb2RlcyIsImdldFBhcmVudE5vZGUiLCJ0ZW1wbGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZW50Iiwib3duZXJEb2N1bWVudCIsInRydXN0ZWRUeXBlc1BvbGljeSIsImVtcHR5SFRNTCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlTm9kZUl0ZXJhdG9yIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW1wb3J0Tm9kZSIsImhvb2tzIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiSVNfQUxMT1dFRF9VUkkkMSIsIkFMTE9XRURfVEFHUyIsIkRFRkFVTFRfQUxMT1dFRF9UQUdTIiwiQUxMT1dFRF9BVFRSIiwiREVGQVVMVF9BTExPV0VEX0FUVFIiLCJDVVNUT01fRUxFTUVOVF9IQU5ETElORyIsInRhZ05hbWVDaGVjayIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImF0dHJpYnV0ZU5hbWVDaGVjayIsImFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyIsIkZPUkJJRF9UQUdTIiwiRk9SQklEX0FUVFIiLCJFWFRSQV9FTEVNRU5UX0hBTkRMSU5HIiwidGFnQ2hlY2siLCJhdHRyaWJ1dGVDaGVjayIsIkFMTE9XX0FSSUFfQVRUUiIsIkFMTE9XX0RBVEFfQVRUUiIsIkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIiwiQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSIiwiU0FGRV9GT1JfVEVNUExBVEVTIiwiU0FGRV9GT1JfWE1MIiwiV0hPTEVfRE9DVU1FTlQiLCJTRVRfQ09ORklHIiwiRk9SQ0VfQk9EWSIsIlJFVFVSTl9ET00iLCJSRVRVUk5fRE9NX0ZSQUdNRU5UIiwiUkVUVVJOX1RSVVNURURfVFlQRSIsIlNBTklUSVpFX0RPTSIsIlNBTklUSVpFX05BTUVEX1BST1BTIiwiU0FOSVRJWkVfTkFNRURfUFJPUFNfUFJFRklYIiwiS0VFUF9DT05URU5UIiwiSU5fUExBQ0UiLCJVU0VfUFJPRklMRVMiLCJGT1JCSURfQ09OVEVOVFMiLCJERUZBVUxUX0ZPUkJJRF9DT05URU5UUyIsIkRBVEFfVVJJX1RBR1MiLCJERUZBVUxUX0RBVEFfVVJJX1RBR1MiLCJVUklfU0FGRV9BVFRSSUJVVEVTIiwiREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTIiwiTUFUSE1MX05BTUVTUEFDRSIsIlNWR19OQU1FU1BBQ0UiLCJIVE1MX05BTUVTUEFDRSIsIk5BTUVTUEFDRSIsIklTX0VNUFRZX0lOUFVUIiwiQUxMT1dFRF9OQU1FU1BBQ0VTIiwiREVGQVVMVF9BTExPV0VEX05BTUVTUEFDRVMiLCJNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMiLCJIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyIsIkNPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFMiLCJQQVJTRVJfTUVESUFfVFlQRSIsIlNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMiLCJERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIiwiQ09ORklHIiwiZm9ybUVsZW1lbnQiLCJpc1JlZ2V4T3JGdW5jdGlvbiIsInRlc3RWYWx1ZSIsIkZ1bmN0aW9uIiwiX3BhcnNlQ29uZmlnIiwiY2ZnIiwiQUREX1VSSV9TQUZFX0FUVFIiLCJBRERfREFUQV9VUklfVEFHUyIsIkFMTE9XRURfVVJJX1JFR0VYUCIsIkFERF9UQUdTIiwiQUREX0FUVFIiLCJ0YWJsZSIsInRib2R5IiwiVFJVU1RFRF9UWVBFU19QT0xJQ1kiLCJBTExfU1ZHX1RBR1MiLCJBTExfTUFUSE1MX1RBR1MiLCJfY2hlY2tWYWxpZE5hbWVzcGFjZSIsInBhcmVudCIsInRhZ05hbWUiLCJuYW1lc3BhY2VVUkkiLCJwYXJlbnRUYWdOYW1lIiwiQm9vbGVhbiIsIl9mb3JjZVJlbW92ZSIsIm5vZGUiLCJyZW1vdmVDaGlsZCIsIl9yZW1vdmVBdHRyaWJ1dGUiLCJuYW1lIiwiZ2V0QXR0cmlidXRlTm9kZSIsImZyb20iLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfaW5pdERvY3VtZW50IiwiZGlydHkiLCJkb2MiLCJsZWFkaW5nV2hpdGVzcGFjZSIsIm1hdGNoZXMiLCJkaXJ0eVBheWxvYWQiLCJwYXJzZUZyb21TdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJjcmVhdGVEb2N1bWVudCIsImlubmVySFRNTCIsImJvZHkiLCJpbnNlcnRCZWZvcmUiLCJjcmVhdGVUZXh0Tm9kZSIsImNoaWxkTm9kZXMiLCJjYWxsIiwiX2NyZWF0ZU5vZGVJdGVyYXRvciIsIlNIT1dfRUxFTUVOVCIsIlNIT1dfQ09NTUVOVCIsIlNIT1dfVEVYVCIsIlNIT1dfUFJPQ0VTU0lOR19JTlNUUlVDVElPTiIsIlNIT1dfQ0RBVEFfU0VDVElPTiIsIl9pc0Nsb2JiZXJlZCIsIm5vZGVOYW1lIiwidGV4dENvbnRlbnQiLCJhdHRyaWJ1dGVzIiwiaGFzQ2hpbGROb2RlcyIsIl9pc05vZGUiLCJfZXhlY3V0ZUhvb2tzIiwiY3VycmVudE5vZGUiLCJkYXRhIiwiaG9vayIsIl9zYW5pdGl6ZUVsZW1lbnRzIiwiYWxsb3dlZFRhZ3MiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIl9pc0Jhc2ljQ3VzdG9tRWxlbWVudCIsInBhcmVudE5vZGUiLCJjaGlsZENvdW50IiwiaSIsImNoaWxkQ2xvbmUiLCJfX3JlbW92YWxDb3VudCIsImV4cHIiLCJfaXNWYWxpZEF0dHJpYnV0ZSIsImxjVGFnIiwibGNOYW1lIiwiX3Nhbml0aXplQXR0cmlidXRlcyIsImhvb2tFdmVudCIsImF0dHJOYW1lIiwiYXR0clZhbHVlIiwia2VlcEF0dHIiLCJhbGxvd2VkQXR0cmlidXRlcyIsImZvcmNlS2VlcEF0dHIiLCJhdHRyIiwiaW5pdFZhbHVlIiwiZ2V0QXR0cmlidXRlVHlwZSIsInNldEF0dHJpYnV0ZU5TIiwiX3Nhbml0aXplU2hhZG93RE9NIiwiZnJhZ21lbnQiLCJzaGFkb3dOb2RlIiwic2hhZG93SXRlcmF0b3IiLCJuZXh0Tm9kZSIsInNhbml0aXplIiwiaW1wb3J0ZWROb2RlIiwicmV0dXJuTm9kZSIsImFwcGVuZENoaWxkIiwiZmlyc3RDaGlsZCIsIm5vZGVJdGVyYXRvciIsInNoYWRvd3Jvb3QiLCJzaGFkb3dyb290bW9kZSIsInNlcmlhbGl6ZWRIVE1MIiwib3V0ZXJIVE1MIiwiZG9jdHlwZSIsInNldENvbmZpZyIsImNsZWFyQ29uZmlnIiwiaXNWYWxpZEF0dHJpYnV0ZSIsInRhZyIsImFkZEhvb2siLCJlbnRyeVBvaW50IiwiaG9va0Z1bmN0aW9uIiwicmVtb3ZlSG9vayIsInJlbW92ZUhvb2tzIiwicmVtb3ZlQWxsSG9va3MiLCJwdXJpZnkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dompurify/dist/purify.cjs.js\n");

/***/ })

};
;